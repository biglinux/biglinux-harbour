[
  {
    "_COMPONENT": "hbxpp",
    "_LANG": "en",
    "_DOCSOURCE": "./hbxpp/doc/en/binnumx.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "Bin2U()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Conversion",
    "ONELINER": "Convert unsigned long encoded bytes into Harbour numeric",
    "SYNTAX": "Bin2U( <cBuffer> ) --> nNumber",
    "ARGUMENTS": "<cBuffer> is a character string that contains 32-bit encoded unsigned\nlong integer (least significant byte first). The first four bytes\nare taken into account, the rest if any are ignored.",
    "RETURNS": "Bin2U() return numeric integer (or 0 if <cBuffer> is not a string).",
    "DESCRIPTION": "Bin2U() is one of the low-level binary conversion functions, those\nfunctions convert between Harbour numeric and a character\nrepresentation of numeric value. Bin2U() take four bytes of encoded\n32-bit unsigned long integer and convert it into standard Harbour\nnumeric value.\n\nYou might ask what is the need for such functions, well, first of\nall it allow you to read/write information from/to a binary file\n(like extracting information from DBF header), it is also a useful\nway to share information from source other than Harbour (C for\ninstance).\n\nBin2U() is the opposite of U2Bin()",
    "EXAMPLES": "// Show number of records in DBF\n#include \"fileio.ch\"\nLOCAL hFile, cBuffer := Space( 4 )\nIF ( hFile := hb_vfOpen( \"test.dbf\", FO_READ ) ) != NIL\n   hb_vfSeek( hFile, 4 )\n   hb_vfRead( hFile, @cBuffer, hb_BLen( cBuffer ) )\n   ? \"Number of records in file:\", Bin2U( cBuffer )\n   hb_vfClose( hFile )\nELSE\n   ? \"Cannot open file\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "XPP",
    "FILES": "Library is core",
    "SEEALSO": "Bin2I(), Bin2L(), Bin2W(), I2Bin(), L2Bin(), W2Bin(), Word(), U2Bin()"
  },
  {
    "_COMPONENT": "hbxpp",
    "_LANG": "en",
    "_DOCSOURCE": "./hbxpp/doc/en/binnumx.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "W2Bin()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Conversion",
    "ONELINER": "Convert Harbour numeric into unsigned short encoded bytes",
    "SYNTAX": "W2Bin( <nNumber> ) --> cBuffer",
    "ARGUMENTS": "<nNumber> is a numeric value to convert (decimal digits are ignored).",
    "RETURNS": "W2Bin() return two bytes character string that contains 16-bit\nencoded unsigned short integer (least significant byte first).",
    "DESCRIPTION": "W2Bin() is one of the low-level binary conversion functions, those\nfunctions convert between Harbour numeric and a character\nrepresentation of numeric value. W2Bin() take a numeric integer\nvalue and convert it into two bytes of encoded 16-bit unsigned short\ninteger.\n\nYou might ask what is the need for such functions, well, first of\nall it allow you to read/write information from/to a binary file\n(like extracting information from DBF header), it is also a useful\nway to share information from source other than Harbour (C for\ninstance).\n\nW2Bin() is the opposite of Bin2W()",
    "STATUS": "R",
    "COMPLIANCE": "XPP",
    "FILES": "Library is core",
    "SEEALSO": "Bin2I(), Bin2L(), Bin2U(), Bin2W(), I2Bin(), L2Bin(), Word(), U2Bin()"
  },
  {
    "_COMPONENT": "hbxpp",
    "_LANG": "en",
    "_DOCSOURCE": "./hbxpp/doc/en/binnumx.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "U2Bin()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Conversion",
    "ONELINER": "Convert Harbour numeric into unsigned long encoded bytes",
    "SYNTAX": "U2Bin( <nNumber> ) --> cBuffer",
    "ARGUMENTS": "<nNumber> is a numeric value to convert (decimal digits are ignored).",
    "RETURNS": "U2Bin() return four bytes character string that contains 32-bit\nencoded unsigned long integer (least significant byte first).",
    "DESCRIPTION": "U2Bin() is one of the low-level binary conversion functions, those\nfunctions convert between Harbour numeric and a character\nrepresentation of numeric value. U2Bin() take a numeric integer\nvalue and convert it into four bytes of encoded 32-bit unsigned long\ninteger.\n\nYou might ask what is the need for such functions, well, first of\nall it allow you to read/write information from/to a binary file\n(like extracting information from DBF header), it is also a useful\nway to share information from source other than Harbour (C for\ninstance).\n\nU2Bin() is the opposite of Bin2U()",
    "STATUS": "R",
    "COMPLIANCE": "XPP",
    "FILES": "Library is core",
    "SEEALSO": "Bin2I(), Bin2L(), Bin2U(), Bin2W(), I2Bin(), L2Bin(), W2Bin(), Word()"
  },
  {
    "_COMPONENT": "hbxpp",
    "_LANG": "en",
    "_DOCSOURCE": "./hbxpp/doc/en/dbcmdx.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "dbSkipper()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Helper function to skip a database",
    "SYNTAX": "dbSkipper( <nRecs> ) --> nSkipped",
    "ARGUMENTS": "<nRecs> is the number of records to skip relative to current record.\nPositive number would try to move the record pointer forward, while\na negative number would try to move the record pointer back <nRecs>\nrecords.",
    "RETURNS": "dbSkipper() return the number of actual record skipped.",
    "DESCRIPTION": "dbSkipper() is a helper function used in browse mechanism to skip\na number of records while giving the caller indication about the\nactual records skipped.",
    "EXAMPLES": "// open a file and find if we've got enough records in it\nUSE test\nIF dbSkipper( 100 ) == 100\n   ? \"Good work! You can party now\"\nELSE\n   ? \"Too bad, you should really work harder\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "XPP",
    "FILES": "Library is core",
    "SEEALSO": "dbSkip(), SKIP"
  }
]
