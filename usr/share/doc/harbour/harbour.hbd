[
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/1stread.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Document",
    "NAME": "Welcome to Harbour",
    "CATEGORY": "Document",
    "SUBCATEGORY": "Intro",
    "ONELINER": "A starter's guide",
    "DESCRIPTION": "Clipper is a trademark of Computer Associates and will often be\nreferred to as CA-Cl*pper within Harbour documents. Regardless of this\nvariant, Clipper is recognized as Computer Associates' trademark.\n\nHarbour is a free software compiler for the xBase superset language often\nreferred to as Clipper (the language that is implemented by the compiler\nClipper). The goal of Harbour is to produce a cross platform CA-Cl*pper\ncompatible compiler.\n\nThe Harbour website is at <https://vszakats.github.io/harbour-core/>.\nIf you have any problem with this copy of Harbour please visit our web\nsite and ensure that you are using the latest release.\n\nIf you are reading this file as part of a source distribution of Harbour you\nprobably want to start by reading doc/dirstruc.txt because this is your map to\nthe Harbour source directories.\n\nHarbour is a superset of Clipper and is backwards compatible with nearly\n100% of all Clipper 5.2x or 5.3 code. Most Clipper S'87 code will also\ncompile and run fine, but may require some modifications to run well.",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/arrayshb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Array()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Array",
    "ONELINER": "Create an uninitialized array of specified length",
    "SYNTAX": "Array( <nElements>[, <nElements>...] ) --> aArray",
    "ARGUMENTS": "<nElements> is the number of elements in the specified dimension.",
    "RETURNS": "<aArray> an array of specified dimensions.",
    "DESCRIPTION": "This function returns an uninitialized array with the length of\n<nElements>.\n\nNested arrays are uninitialized within the same array\npointer reference if additional parameters are specified.\n\nEstablishing a memory variable with the same name as the array may\ndestroy the original array and release the entire contents of the\narray. This depends, of course, on the data storage type of either\nthe array or the variable with the same name as the array.\n\nCA-Cl*pper v5.x compliant except that arrays in Harbour can have\nan unlimited number of elements.",
    "EXAMPLES": "LOCAL aArray := Array( 10 ), tmp\nFOR tmp := 1 TO Len( aArray )\n   aArray[ tmp ] := Array( tmp )\nNEXT\n? hb_ValToExp( aArray )  // --> { { NIL }, { NIL, NIL }, ... }",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "AAdd(), ADel(), AFill(), AIns()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/arrayshb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "AAdd()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Array",
    "ONELINER": "Dynamically add an element to an array",
    "SYNTAX": "AAdd( <aArray>, [<xValue>] ) --> xValue",
    "ARGUMENTS": "<aArray> The name of an array\n\n<xValue> Element to add to array <aArray>",
    "RETURNS": "<xValue> if specified <xValue>, <xValue> will be returned,\notherwise this function returns a NIL value.",
    "DESCRIPTION": "This function dynamically increases the length of the <aArray>\nby adding one new element to the end of the array and optionally\nstores the value <xValue> to that newly created element.\n\n<xValue> may be of an data type, including an array reference pointer,\nwhich in turn may be stored to an array's subscript position.",
    "EXAMPLES": "LOCAL aArray := {}, tmp\nAAdd( aArray, 10 )\nFOR tmp := 1 TO 10\n   AAdd( aArray, tmp )\nNEXT\n? hb_ValToExp( aArray )  // --> { 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "AIns(), ASize()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/arrayshb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "ASize()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Array",
    "ONELINER": "Adjust the size of an array",
    "SYNTAX": "ASize( <aArray>, <nLen> ) --> aArray",
    "ARGUMENTS": "<aArray> Name of array to be dynamically altered\n\n<nLen>  Numeric value representing the new size (i.e. number of elements)\n        of <aArray>",
    "RETURNS": "The function returns a reference to <aArray>.",
    "DESCRIPTION": "This function will dynamically increase or decrease the size of\n<aArray> by adjusting the length of the array to <nLen> subscript\npositions.\n\nIf the length of the array <aArray> is shortened, the redundant elements\nare removed from the end of array. If the length of the array is lengthened\nthe new elements are added to the end of array and they are assigned a NIL value.",
    "EXAMPLES": "LOCAL aArray := { 1 }\n? hb_ValToExp( aArray )  // --> { 1 }\nASize( aArray, 3 )\n? hb_ValToExp( aArray )  // --> { 1, NIL, NIL }\nASize( aArray, 1 )\n? hb_ValToExp( aArray )  // --> { 1 }",
    "STATUS": "R",
    "COMPLIANCE": "If HB_COMPAT_C53 is defined, the function generates an Error,\nelse it will return the array itself.",
    "FILES": "Library is core",
    "SEEALSO": "AAdd(), ADel(), AFill(), AIns()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/arrayshb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "ATail()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Array",
    "ONELINER": "Returns the last element of an array",
    "SYNTAX": "ATail( <aArray> ) --> xValue",
    "ARGUMENTS": "<aArray> is the array.",
    "RETURNS": "<xValue> the value of the last element in the array.",
    "DESCRIPTION": "This function return the value of the last element in the array\nnamed <aArray>. Same as `xValue := aArray[ Len( aArray ) ]`",
    "EXAMPLES": "LOCAL aArray := { \"Harbour\", \"is\", \"Supreme\", \"Power\" }\n? ATail( aArray )  // --> \"Power\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "Len(), Array(), ASize(), AAdd()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/arrayshb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "AIns()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Array",
    "ONELINER": "Insert a NIL value at an array subscript position.",
    "SYNTAX": "AIns( <aArray>, <nPos> ) --> aArray",
    "ARGUMENTS": "<aArray> Array name.\n\n<nPos> Subscript position in <aArray>",
    "RETURNS": "a reference to <aArray>.",
    "DESCRIPTION": "This function inserts a NIL value in the array named <aArray>\nat the <nPos>th position.\n\nAll array elements starting with the <nPos>th position will be\nshifted down one subscript position in the array list and the\nlast item in the array will be removed completely. In other words,\nif an array element were to be inserted at the fifth subscript\nposition, the element previously in the fifth position would now\nbe located at the sixth position. The length of the array <aArray>\nwill remain unchanged.\n\nNote: To avoid loosing last element, you can use hb_AIns()\nwhich supports auto-sizing of array.",
    "EXAMPLES": "LOCAL aArray := { \"Harbour\", \"is\", \"Power!\", \"!!!\" }\nAIns( aArray, 4 )\n? hb_ValToExp( aArray )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "hb_AIns(), AAdd(), ACopy(), ADel(), AEval(), AFill(), ASize()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/arrayshb.txt",
    "AUTHOR": "2016 Pete D. <pete_westg@yahoo.gr>",
    "TEMPLATE": "Function",
    "NAME": "hb_AIns()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Array",
    "ONELINER": "Inserts a value at an array subscript position and optionally increases\nthe length of array.",
    "SYNTAX": "hb_AIns( <aArray>, [<nPos>], [<xValue>], [<lAutoSize>] ) --> aArray",
    "ARGUMENTS": "<aArray> The array name into which the value <xValue> will be inserted.\n\n<nPos> Subscript position in <aArray>. Default: 1st position\n\n<xValue> Value to be inserted\n\n<lAutoSize> Boolean flag to increase or not the size of <aArray>.\n            Default value: .F.",
    "RETURNS": "A reference to array <aArray>",
    "DESCRIPTION": "This function inserts <xValue> in the <nPos> position of the array,\nmoving all the items one position down in the array list.\nIf <lAutoSize> is .T., a new element will be added at the end of array,\nmaking room for the previous last element, which means the length of array\nwill be increased by 1.\n\nIf <lAutoSize> is .F. (or is not passed) the function behaves like AIns(),\nthat is, the size of <aArray> won't change and the last item of <aArray>\nwill be lost.",
    "EXAMPLES": "LOCAL aArray := { \"Harbour\", \"Power!\" }\nhb_AIns( aArray, 2, \"is\", .F. )\n? hb_ValToExp( aArray )  // --> { \"Harbour\", \"is\" }\nhb_AIns( aArray, 2, \"is\", .T. )\n? hb_ValToExp( aArray )  // --> { \"Harbour\", \"is\", \"Power!\" }",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "AIns(), AAdd(), ADel(), AFill(), ASize()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/arrayshb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "ADel()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Array",
    "ONELINER": "Delete an element from an array.",
    "SYNTAX": "ADel( <aArray>, <nPos> ) --> aArray",
    "ARGUMENTS": "<aArray> Name of array from which an element is to be removed.\n\n<nPos>   Subscript of the element to be removed.",
    "RETURNS": "<aArray> an array pointer reference.",
    "DESCRIPTION": "This function deletes the element found at <nPos> subscript position\nin the array <aArray>. All elements in the array <aArray> below the\ngiven subscript position <nPos> will move up one position in the array.\n\nIn other words, what was formerly the sixth subscript position\nwill become the fifth subscript position. The length of the array\n<aArray> will remain unchanged, as the last element in the array will\nbecome a NIL data type.\n\nNote: To completely remove an element and decrease the length of array\nyou can use hb_ADel() that supports auto-sizing.",
    "EXAMPLES": "LOCAL aArray := { \"Harbour\", \"is\", \"Power\" }\nADel( aArray, 2 )\n? hb_ValToExp( aArray )  // --> { \"Harbour\", \"Power\", NIL }",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "hb_ADel(), ACopy(), AIns(), AFill()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/arrayshb.txt",
    "AUTHOR": "2016 Pete D. <pete_westg@yahoo.gr>",
    "TEMPLATE": "Function",
    "NAME": "hb_ADel()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Array",
    "ONELINER": "Delete an element from an array.",
    "SYNTAX": "hb_ADel( <aArray>, [<nPos>], [<lAutoSize>] ) --> aArray",
    "ARGUMENTS": "<aArray> Name of array from which an element is to be removed.\n\n<nPos>  Subscript of the element to be removed. Default value: 1.\n\n<lAutoSize> Boolean flag specifying if the array will be resized or not.\n            Default value: .F. (no resize).",
    "RETURNS": "<aArray> an array pointer reference.",
    "DESCRIPTION": "This function deletes the element value (not the element itself!)\nstored in position <nPos> and shifts all the following values,\none position up.\n\nIf <lAutoSize> is .T., then the last element is removed and the size\nof the array is decreased by one, otherwise the length of the array\nremains unchanged and a NIL value will be stored in the last element,\njust like in ADel().",
    "EXAMPLES": "LOCAL aArray := { \"Harbour\", \"is\", \"Power\" }\nhb_ADel( aArray, 2 )\n? hb_ValToExp( aArray )  // --> { \"Harbour\", \"Power\", NIL } - length unchanged\nhb_ADel( aArray, 2, .T. )\n? hb_ValToExp( aArray )  // --> a{ \"Harbour\", \"Power\" } - length decreased",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "ADel(), ACopy(), AIns(), AFill()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/arrayshb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "AFill()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Array",
    "ONELINER": "Fill an array with a specified value",
    "SYNTAX": "AFill( <aArray>, <xValue>, [<nStart>], [<nCount>] ) --> aArray",
    "ARGUMENTS": "<aArray> Name of array to be filled.\n\n<xValue> Expression to be globally filled in <aArray>\n\n<nStart> Subscript starting position\n\n<nCount> Number of subscript to be filled",
    "RETURNS": "<aArray> pointer to the array.",
    "DESCRIPTION": "This function will fill each element of an array named <aArray> with\nthe value <xValue>. If specified, <nStart> denotes the beginning\nelement to be filled and the array elements will continue to be\nfilled for <nCount> positions.\n\nIf neither <nStart>/<nCount> specified, the value of <nStart> will be 1,\nand the value of <nCount> will be the value of `Len( <aArray> )`;\nthus, all subscript positions in the array <aArray> will be filled\nwith the value of <xValue>.\n\nThis function will work on only a single dimension of <aArray>.\nIf there are array pointer references within a subscript <aArray>,\nthose values will be lost, since this function will overwrite those\nvalues with new values.",
    "EXAMPLES": "LOCAL aArray := { NIL, 0, 1, 2 }\nAFill( aArray, 5 )\n? hb_ValToExp( aArray )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "AAdd(), AEval(), dbStruct()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/arrayshb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "AScan()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Array",
    "ONELINER": "Scan array elements for a specified condition",
    "SYNTAX": "AScan( <aArray>, <xSearch>, [<nStart>], [<nCount>] ) --> nStoppedAt",
    "ARGUMENTS": "<aArray>    Array to be scanned.\n\n<xSearch>   Expression to search for in <aTarget>\n\n<nStart>    Beginning subscript position at which to start the search.\n\n<nCount>    Number of elements to scan with <aTarget>.",
    "RETURNS": "<nStoppedAt> A numeric value of subscript position where <xSearch>\nwas found, or 0 if <xSearch> is not found.",
    "DESCRIPTION": "This function scan the content of array named <aArray> for the\nvalue of <xSearch>. The return value is the position in the array\n<aArray> in which <xSearch> was found. If it was not found, the\nreturn value will be 0.\n\n<nStart> is the position from which to start scanning. The default\nis 1. (1st element)\n<nCount>, if specified, is the number of array elements to be scanned.\nThe default is all elements in the array <aArray>.\n\nIf <xSearch> is a code block, the operation of the function is\nslightly different. Each array subscript pointer reference is\npassed to the code block to be evaluated. The scanning routine\nwill continue until the value obtained from the code block is a\nlogical true (.T.) or until the end of the array has been reached.",
    "EXAMPLES": "#include \"directry.ch\"\nLOCAL aDir := hb_vfDirectory( \"*.prg\" )\n? AScan( aDir,,, ;\n   {| aFile, nPos | HB_SYMBOL_UNUSED( nPos ), aFile[ F_NAME ] == \"test.prg\" } )",
    "STATUS": "R",
    "COMPLIANCE": "This function is not CA-Cl*pper compatible.\nCA-Cl*pper AScan() is affected by the `SET EXACT ON`/`OFF` Condition",
    "FILES": "Library is core",
    "SEEALSO": "AEval()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/arrayshb.txt",
    "AUTHOR": "2016 Pete D. <pete_westg@yahoo.gr>",
    "TEMPLATE": "Function",
    "NAME": "hb_AScan()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Array",
    "ONELINER": "Scan array elements for a specified condition",
    "SYNTAX": "hb_AScan( <aArray>, <xSearch>, [<nStart>], [<nCount>], [<lExact>] ) --> nPosition",
    "ARGUMENTS": "<aArray>    Array to be scanned.\n\n<xSearch>   Expression to search for in <aArray>\n\n<nStart>    Beginning subscript position at which to start the search.\n            Default value: 1\n\n<nCount>    Number of elements to be scanned within <aArray>.\n            Default value: All elements.\n\n<lExact>    Boolean flag specifying if an \"Exact\" search will be\n            performed or not. Default value: .F.",
    "RETURNS": "<nPosition> A numeric value > 0 indicating the array position\nwhere <xSearch> was found, or 0 if nothing found.",
    "DESCRIPTION": "The function scans (left to right) for <xSearch> into <aArray>\nand returns <nPosition> of <aArray> in which <xSearch>\nwas found or 0 (zero) if nothing found.\n\nIf <lExact> is .T., then an exact search will be performed.\nWhen <xSearch> is a code block, the operation of the function\nis slightly different. See AScan() for details.",
    "EXAMPLES": "LOCAL a := { \"there\", \"here\" }\nSet( _SET_EXACT, .F. )\n? AScan( a, \"he\" )            // --> 2\n? hb_AScan( a, \"he\",,, .F. )  // --> 2\n? hb_AScan( a, \"he\",,, .T. )  // --> 0",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "AScan(), AEval()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/arrayshb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "AEval()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Array",
    "ONELINER": "Evaluates the subscript element of an array",
    "SYNTAX": "AEval( <aArray>, <bBlock>, [<nStart>], [<nCount>] ) --> aArray",
    "ARGUMENTS": "<aArray> Is the array to be evaluated.\n\n<bBlock> Is a code block to evaluate for each element processed.\n\n<nStart> The beginning array element index to evaluate.\n\n<nCount> The number of elements to process.",
    "RETURNS": "<aArray> an array pointer reference.",
    "DESCRIPTION": "This function evaluates the elements of <aArray>, and executes for each\nof them the processing that's defined with <bBlock>.\nBy default, all the elements of array are being processed, starting from\n1st and up to the last element.\n\nIf  <nStart> and/or <nCount> parameters are given, then the processing\nstarts from <nStart> element and continues for the next <nCount> elements\n(if defined) or up to the last element of the array.\n\nThe <bBlock> code block receives two parameters: the element value and\nelement's index (position) into the array. i.e. `{| xValue, nIndex | ... }`\nWorth to note that elements are passed to code block 'by value',\nthus any change being made to this value doesn't  affects the value of\nelement in the array.",
    "EXAMPLES": "LOCAL a := { 10, 20, 30 }\nAEval( a, {| e, n | QOut( e * n + 1 , a[ n ] ) } )\n? a[ 1 ], a[ 2 ], a[ 3 ]  // array elements unchanged\n? \"----\"\nAEval( a, {| e, n | QOut( e * n + 1, a[ n ] *= n + 1 ) }, 2, 1 )\n/* Here the 2nd element been changed, because we've explicitly used\n   its pointer 'a[ n ] *= ...' into array */\n? a[ 1 ], a[ 2 ], a[ 3 ]",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "Eval(), dbEval()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/arrayshb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "ACopy()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Array",
    "ONELINER": "Copy elements from one array to another",
    "SYNTAX": "ACopy( <aSource>, <aTarget>, [<nStart>], [<nCount>], [<nTargetPos>] ) --> aTarget",
    "ARGUMENTS": "<aSource> is the array to copy elements from.\n\n<aTarget> is the array to copy elements to.\n\n<nStart>  is the beginning subscript position to copy from <aSource>\n\n<nCount>  the number of subscript elements to copy from <aSource>.\n\n<nTargetPos> the starting subscript position in <aTarget> to copy\nelements to.",
    "RETURNS": "<aTarget> an array pointer reference",
    "DESCRIPTION": "This function copies array elements from <aSource> to <aTarget>.\n<nStart> is the beginning element to be copied from <aSource>;\nthe default is 1.\n\n<nCount> is the number of elements to be copied from <aSource>;\nthe default is the entire array.\n<nTargetPos> is the subscript number in the target array, <aTarget>,\nto which array elements are to be copied; the default is 1.\n\nThis function will copy all data types in <aSource> to <aTarget>.\nIf an array element in <aSource> is a pointer reference to another\narray, that array pointer will be copied to <aTarget>; not all\nsubdimensions will be copied from one array to the next. This must\nbe accomplished via the AClone() function.\n\nNote:\nIf array <aSource> is larger then <aTarget>, array elements will\nstart copying at <nTargetPos> and continue copying until the end\nof array <aTarget> is reached. The ACopy() function doesn't append\nsubscript positions to the target array, the size of the target\narray <aTarget> remains constant.",
    "EXAMPLES": "LOCAL nCount := 2, nStart := 1\nLOCAL aOne := { \"Harbour\", \" is \", \"Power\" }\nLOCAL aTwo := { \"Clipper\", \" was \", \"Power\" }\nACopy( aOne, aTwo, nStart, nCount )\n? hb_ValToExp( aTwo )  // --> { \"Harbour\", \" is \", \"Power\" }",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "AClone(), ADel(), AEval(), AFill(), AIns(), ASort()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/arrayshb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "AClone()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Array",
    "ONELINER": "Duplicate a  multidimensional array",
    "SYNTAX": "AClone( <aSource> ) --> aDuplicate",
    "ARGUMENTS": "<aSource> Name of the array to be cloned.",
    "RETURNS": "<aDuplicate> A new array pointer reference complete with nested\narray values.",
    "DESCRIPTION": "This function makes a complete copy of the array expressed as\n<aSource> and return a cloned set of array values. This provides\na complete set of arrays values for all dimensions within the\noriginal array <aSource>",
    "EXAMPLES": "LOCAL aOne := { \"Harbour\", \" is \", \"POWER\" }\nLOCAL aTwo := AClone( aOne )\n? hb_ValToExp( aTwo )  // --> { \"Harbour\", \" is \", \"POWER\" }\naOne[ 1 ] := \"The Harbour Compiler\"\n? hb_ValToExp( aOne )  // --> { \"The Harbour Compiler\", \" is \", \"POWER\" }\n? hb_ValToExp( aTwo )  // --> { \"Harbour\", \" is \", \"POWER\" }",
    "STATUS": "R",
    "COMPLIANCE": "CA-Cl*pper will return NIL if the parameter is not an array.",
    "FILES": "Library is core",
    "SEEALSO": "ACopy(), ADel(), AIns(), ASize()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/arrayshb.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "ASort()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Array",
    "ONELINER": "Sort an array",
    "SYNTAX": "ASort( <aArray>, [<nStart>], [<nCount>], [<bSort>] ) --> aArray",
    "ARGUMENTS": "<aArray> Array to be sorted.\n\n<nStart> The first element to start the sort from, default is 1.\n\n<nCount> Number of elements starting from <nStart> to sort, default\n         is all elements.\n\n<bSort> Code block for sorting order, default is ascending order\n`{| x, y | x < y }`. The code block should accept two parameters and\nmust return .T. if the sort is in order, .F. if not.",
    "RETURNS": "<aArray> reference to the now sorted <aArray> or NIL if the\npassed <aArray> is not an array.",
    "DESCRIPTION": "ASort() sort all or part of a given array. If <bSort> is omitted,\nthe function expect <aArray> to be one dimensional array containing\nsingle data type (one of: Character, Date, Logical, Numeric) and sort\nthis array in ascending order: Character are sorted by their ASCII\nvalue, Dates are sorted chronologically, Logical put .F. values before\n.T., Numeric are sorted by their value.\nIf <bSort> is specified, it is used to handle the sorting order. With\neach time the block is evaluate, two array elements are passed to the\ncode block, and <bSort> must return a logical value that state if\nthose elements are in order (.T.) or not (.F.). Using this block you\ncan sort multidimensional array, descending orders or even (but why\nwould you want to do that) sort array that contain different data\ntype.\n\nCodeblock calling frequency and order differs from CA-Cl*pper, since\nHarbour uses a different (faster) sorting algorithm (quicksort).",
    "EXAMPLES": "LOCAL aKeys, bSort, aPair\n\n// Sort numeric values in ascending order\naKeys := { 3, 1, 4, 42, 5, 9 }\nASort( aKeys )\n? hb_ValToExp( aKeys )  // --> { 1, 3, 4, 5, 9, 42 }\n\n// Sort character strings in descending lexical order\naKeys := { \"Ctrl\", \"Alt\", \"Delete\" }\nbSort := {| x, y | Upper( x ) > Upper( y ) }\nASort( aKeys,,, bSort )\n? hb_ValToExp( aKeys )  // --> { \"Delete\", \"Ctrl\", \"Alt\" }\n\n// Sort two-dimensional array according to 2nd element of each pair\naPair := { { \"Sun\", 8 }, { \"Mon\", 1 }, { \"Tue\", 57 }, { \"Wed\", -6 } }\nASort( aPair,,, {| x, y | x[ 2 ] < y[ 2 ] } )\n? hb_ValToExp( aPair )  // --> { { \"Wed\", -6 }, { \"Mon\", 1 }, { \"Sun\", 8 }, { \"Tue\", 57 } }",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "AScan(), Eval(), SORT"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/ati.txt",
    "AUTHOR": "2016 Pete D. <pete_westg@yahoo.gr>",
    "TEMPLATE": "Function",
    "NAME": "hb_AtI()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Locates the position of a substring in a main string.",
    "SYNTAX": "hb_AtI( <cSearch>, <cString>, [<nStart>], [<nEnd>] ) --> nPos",
    "ARGUMENTS": "<cSearch> the sub-string to search for\n\n<cString> The main string to search into, for <cSearch>\n\n<nStart> Beginning search position into <cString>, default: 1\n\n<nEnd> Ending search position, default: Length of <cString> (i.e. entire <cString>)\n",
    "RETURNS": "hb_AtI() returns the position (if any), into main string,\nwhere first time the substring appears.",
    "DESCRIPTION": "This function has same functionality as hb_At() with the significant\ndifference that it's case Insensitive.\n\nOptionally, with <nStart> can be defined the position into main string\nfrom where the search of <cSearch> must begin and with <nEnd> the position\nwhere it must stop. If neither of them is defined, <nStart> is 1st position\nand <nEnd> the ending of <cString>.",
    "EXAMPLES": "? hb_At( \"AS\", \"as simple as possible\", 5 )   // --> 0\n? hb_AtI( \"AS\", \"as simple as possible\", 5 )  // --> 11",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "hb_At()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/binnum.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "Bin2I()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Conversion",
    "ONELINER": "Convert signed short encoded bytes into Harbour numeric",
    "SYNTAX": "Bin2I( <cBuffer> ) --> nNumber",
    "ARGUMENTS": "<cBuffer> is a character string that contains 16-bit encoded signed\nshort integer (least significant byte first). The first two bytes\nare taken into account, the rest if any are ignored.",
    "RETURNS": "Bin2I() return numeric integer (or 0 if <cBuffer> is not a string).",
    "DESCRIPTION": "Bin2I() is one of the low-level binary conversion functions, those\nfunctions convert between Harbour numeric and a character\nrepresentation of numeric value. Bin2I() take two bytes of encoded\n16-bit signed short integer and convert it into standard Harbour\nnumeric value.\n\nYou might ask what is the need for such functions, well, first of\nall it allow you to read/write information from/to a binary file\n(like extracting information from DBF header), it is also a useful\nway to share information from source other than Harbour (C for\ninstance).\n\nBin2I() is the opposite of I2Bin()",
    "EXAMPLES": "// Show DBF last update date\n#include \"fileio.ch\"\nLOCAL hFile, cYear, cMonth, cDay\nIF ( hFile := hb_vfOpen( \"test.dbf\", FO_READ ) ) != NIL\n   hb_vfSeek( hFile, 1 )\n   cYear := cMonth := cDay := hb_BChar( 0 )\n   hb_vfRead( hFile, @cYear , hb_BLen( cYear ) )\n   hb_vfRead( hFile, @cMonth, hb_BLen( cMonth ) )\n   hb_vfRead( hFile, @cDay  , hb_BLen( cDay ) )\n   ? \"Last update:\", Bin2I( cYear ), Bin2I( cMonth ), Bin2I( cDay )\n   hb_vfClose( hFile )\nELSE\n   ? \"Cannot open file\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "Bin2L(), Bin2U(), Bin2W(), I2Bin(), L2Bin(), W2Bin(), Word(), U2Bin()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/binnum.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "Bin2L()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Conversion",
    "ONELINER": "Convert signed long encoded bytes into Harbour numeric",
    "SYNTAX": "Bin2L( <cBuffer> ) --> nNumber",
    "ARGUMENTS": "<cBuffer> is a character string that contains 32-bit encoded signed\nlong integer (least significant byte first). The first four bytes\nare taken into account, the rest if any are ignored.",
    "RETURNS": "Bin2L() return numeric integer (or 0 if <cBuffer> is not a string).",
    "DESCRIPTION": "Bin2L() is one of the low-level binary conversion functions, those\nfunctions convert between Harbour numeric and a character\nrepresentation of numeric value. Bin2L() take four bytes of encoded\n32-bit signed long integer and convert it into standard Harbour\nnumeric value.\n\nYou might ask what is the need for such functions, well, first of\nall it allow you to read/write information from/to a binary file\n(like extracting information from DBF header), it is also a useful\nway to share information from source other than Harbour (C for\ninstance).\n\nBin2L() is the opposite of L2Bin()",
    "EXAMPLES": "// Show number of records in DBF\n#include \"fileio.ch\"\nLOCAL hFile, cBuffer := Space( 4 )\nIF ( hFile := hb_vfOpen( \"test.dbf\", FO_READ ) ) != NIL\n   hb_vfSeek( hFile, 4 )\n   hb_vfRead( hFile, @cBuffer, hb_BLen( cBuffer ) )\n   ? \"Number of records in file:\", Bin2L( cBuffer )\n   hb_vfClose( hFile )\nELSE\n   ? \"Cannot open file\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "Bin2I(), Bin2U(), Bin2W(), I2Bin(), L2Bin(), W2Bin(), Word(), U2Bin()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/binnum.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "Bin2W()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Conversion",
    "ONELINER": "Convert unsigned short encoded bytes into Harbour numeric",
    "SYNTAX": "Bin2W( <cBuffer> ) --> nNumber",
    "ARGUMENTS": "<cBuffer> is a character string that contains 16-bit encoded unsigned\nshort integer (least significant byte first). The first two bytes\nare taken into account, the rest if any are ignored.",
    "RETURNS": "Bin2W() return numeric integer (or 0 if <cBuffer> is not a string).",
    "DESCRIPTION": "Bin2W() is one of the low-level binary conversion functions, those\nfunctions convert between Harbour numeric and a character\nrepresentation of numeric value. Bin2W() take two bytes of encoded\n16-bit unsigned short integer and convert it into standard Harbour\nnumeric value.\n\nYou might ask what is the need for such functions, well, first of\nall it allow you to read/write information from/to a binary file\n(like extracting information from DBF header), it is also a useful\nway to share information from source other than Harbour (C for\ninstance).\n\nBin2W() is the opposite of W2Bin()",
    "EXAMPLES": "// Show header length of a DBF\n#include \"fileio.ch\"\nLOCAL hFile, cBuffer := Space( 2 )\nIF ( hFile := hb_vfOpen( \"test.dbf\", FO_READ ) ) != NIL\n   hb_vfSeek( hFile, 8 )\n   hb_vfRead( hFile, @cBuffer, hb_BLen( cBuffer ) )\n   ? \"Length of DBF header in bytes:\", Bin2W( cBuffer )\n   hb_vfClose( hFile )\nELSE\n   ? \"Cannot open file\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "Bin2I(), Bin2L(), Bin2U(), I2Bin(), L2Bin(), W2Bin(), Word(), U2Bin()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/binnum.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "I2Bin()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Conversion",
    "ONELINER": "Convert Harbour numeric into signed short encoded bytes",
    "SYNTAX": "I2Bin( <nNumber> ) --> cBuffer",
    "ARGUMENTS": "<nNumber> is a numeric value to convert (decimal digits are ignored).",
    "RETURNS": "I2Bin() return two bytes character string that contains 16-bit\nencoded signed short integer (least significant byte first).",
    "DESCRIPTION": "I2Bin() is one of the low-level binary conversion functions, those\nfunctions convert between Harbour numeric and a character\nrepresentation of numeric value. I2Bin() take a numeric integer\nvalue and convert it into two bytes of encoded 16-bit signed short\ninteger.\n\nYou might ask what is the need for such functions, well, first of\nall it allow you to read/write information from/to a binary file\n(like extracting information from DBF header), it is also a useful\nway to share information from source other than Harbour (C for\ninstance).\n\nI2Bin() is the opposite of Bin2I()",
    "EXAMPLES": "// Update DBF \"last update\" date\n#include \"fileio.ch\"\nLOCAL hFile, cYear, cMonth, cDay\nUSE test\n? \"Original update date is:\", LUpdate()\ndbCloseArea()\nIF ( hFile := hb_vfOpen( \"test.dbf\", FO_READWRITE ) ) != NIL\n   hb_vfSeek( hFile, 1 )\n   cYear  := I2Bin( 68 )\n   cMonth := I2Bin(  8 )\n   cDay   := I2Bin(  1 )\n   hb_vfWrite( hFile, cYear , 1 )  // write only the first byte\n   hb_vfWrite( hFile, cMonth, 1 )\n   hb_vfWrite( hFile, cDay  , 1 )\n   hb_vfClose( hFile )\n   USE test\n   ? \"New update date is:\", LUpdate()\n   dbCloseArea()\nELSE\n   ? \"Cannot open file\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "Bin2I(), Bin2L(), Bin2U(), Bin2W(), L2Bin(), W2Bin(), Word(), U2Bin()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/binnum.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "L2Bin()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Conversion",
    "ONELINER": "Convert Harbour numeric into signed long encoded bytes",
    "SYNTAX": "L2Bin( <nNumber> ) --> cBuffer",
    "ARGUMENTS": "<nNumber> is a numeric value to convert (decimal digits are ignored).",
    "RETURNS": "L2Bin() return four bytes character string that contains 32-bit\nencoded signed long integer (least significant byte first).",
    "DESCRIPTION": "L2Bin() is one of the low-level binary conversion functions, those\nfunctions convert between Harbour numeric and a character\nrepresentation of numeric value. L2Bin() take a numeric integer\nvalue and convert it into four bytes of encoded 32-bit signed long\ninteger.\n\nYou might ask what is the need for such functions, well, first of\nall it allow you to read/write information from/to a binary file\n(like extracting information from DBF header), it is also a useful\nway to share information from source other than Harbour (C for\ninstance).\n\nL2Bin() is the opposite of Bin2L()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "Bin2I(), Bin2L(), Bin2U(), Bin2W(), I2Bin(), W2Bin(), Word(), U2Bin()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/binnum.txt",
    "TEMPLATE": "Function",
    "NAME": "Word()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Conversion",
    "ONELINER": "Converts double to integer values.",
    "SYNTAX": "Word( <nDouble> ) --> nInteger",
    "ARGUMENTS": "<nDouble> is a numeric double value.",
    "RETURNS": "Word() return an integer in the range +-32767",
    "DESCRIPTION": "This function converts double values to integers to use\nwithin the CALL command",
    "STATUS": "R",
    "COMPLIANCE": "The CA-Cl*pper NG states that Word() will only work when used in CALL\ncommands parameter list, otherwise it will return NIL, in Harbour\nit will work anywhere.",
    "FILES": "Library is core",
    "SEEALSO": "CALL"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/browse.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "dbEdit()*",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Browse records in a table",
    "SYNTAX": "dbEdit( [<nTop>], [<nLeft>], [<nBottom>], [<nRight>], [<acColumns>], [<xUserFunc>], [<xColumnSayPictures>], [<xColumnHeaders>], [<xHeadingSeparators>], [<xColumnSeparators>], [<xFootingSeparators>], [<xColumnFootings>] ) --> lOk",
    "ARGUMENTS": "<nTop> coordinate for top row display. <nTop> could range from 0\nto MaxRow(), default is 0.\n\n<nLeft> coordinate for left column display. <nLeft> could range\nfrom 0 to MaxCol(), default is 0.\n\n<nBottom> coordinate for bottom row display. <nBottom> could range\nfrom 0 to MaxRow(), default is MaxRow().\n\n<nRight> coordinate for right column display. <nRight> could range\nfrom 0 to MaxCol(), default is MaxCol().\n\n<acColumns> is an array of character expressions that contain\ndatabase fields names or expressions to display in each column.\nIf not specified, the default is to display all fields from the\ndatabase in the current work area.\n\n<xUserFunc> is a name of a user defined function or a code block\nthat would be called every time unrecognized key is been pressed or\nwhen there are no keys waiting to be processed and dbEdit() goes\ninto idle mode. If <xUserFunc> is a character string, it must\ncontain root name of a valid user define function without\nparentheses. Both the user define function or the code block should\naccept two parameters: <nMode>, <nCurrentColumn>. Both should return\na numeric value that correspond to one of the expected return codes\n(see table below for a list of <nMode> and return codes).\n\n<xColumnSayPictures> is an optional picture. If <xColumnSayPictures>\nis a character string, all columns would used this value as a\npicture string. If <xColumnSayPictures> is an array, each element\nshould be a character string that correspond to a picture string\nfor the column with the same index. Look at the help for `@...SAY`\nto get more information about picture values.\n\n<xColumnHeaders> contain the header titles for each column, if this\nis a character string, all columns would have that same header, if\nthis is an array, each element is a character string that contain\nthe header title for one column. Header may be split to more than\none line by placing semicolon `;` in places where you want to break\nline. If omitted, the default value for each column header is taken\nfrom <acColumns> or field name if <acColumns> was not specified.\n\n<xHeadingSeparators> is an array that contain characters that draw\nthe lines separating the headers and the fields data. Instead of an\narray you can use a character string that would be used to display\nthe same line for all fields. Default value is a double line.\n\n<xColumnSeparators> is an array that contain characters that draw\nthe lines separating displayed columns. Instead of an array you can\nuse a character string that would be used to display the same line\nfor all fields. Default value is a single line.\n\n<xFootingSeparators> is an array that contain characters that draw\nthe lines separating the fields data area and the footing area.\nInstead of an array you can use a character string that would be\nused to display the same line for all footers. Default is to have to\nno footing separators.\n\n<xColumnFootings> contain the footing to be displayed at the bottom\nof each column, if this is a character string, all columns would\nhave that same footer, if this is an array, each element is a\ncharacter string that contain the footer for one column. Footer may\nbe split to more than one line by placing semicolon `;` in places\nwhere you want to break line. If omitted, no footer are displayed.",
    "RETURNS": "dbEdit() return .F. if there is no database in use or if the number\nof columns to display is zero, else dbEdit() return .T.",
    "DESCRIPTION": "dbEdit() display and edit records from one or more work areas in\na grid on screen. Each column is defined by element from <acColumns>\nand is the equivalent of one field. Each row is equivalent of one\ndatabase record.\n\nFollowing are active keys that handled by dbEdit():\n\n<table>\n Key              Meaning\n\n Left             Move one column to the left (previous field)\n Right            Move one column to the right (next field)\n Up               Move up one row (previous record)\n Down             Move down one row (next record)\n PgUp             Move to the previous screen\n PgDn             Move to the next screen\n Ctrl+PgUp        Move to the top of the file\n Ctrl+PgDn        Move to the end of the file\n Home             Move to the leftmost visible column\n End              Move to the rightmost visible column\n Ctrl+Left        Pan one column to the left\n Ctrl+Right       Pan one column to the right\n Ctrl+Home        Move to the leftmost column\n Ctrl+End         Move to the rightmost column\n</table>\n\nWhen <xUserFunc> is omitted, two more keys are active:\n\n<table>\n Key              Meaning\n\n Esc              Terminate Browse()\n Enter            Terminate Browse()\n</table>\n\nWhen dbEdit() execute <xUserFunc> it pass the following arguments:\n<nMode> and the index of current record in <acColumns>. If <acColumns>\nis omitted, the index number is the FieldName() number of the open\ndatabase structure.\n\ndbEdit() <nMode> could be one of the following:\n\n<table>\n dbedit.ch      Meaning\n\n DE_IDLE        dbEdit() is idle, all movement keys have been handled.\n DE_HITTOP      Attempt to cursor past top of file.\n DE_HITBOTTOM   Attempt to cursor past bottom of file.\n DE_EMPTY       No records in work area, database is empty.\n DE_EXCEPT      Key exception.\n</table>\n\nThe user define function or code block must return a value that tell\ndbEdit() what to do next.\n\nUser function return codes:\n\n<table>\n dbedit.ch    Meaning\n\n DE_ABORT     Abort dbEdit().\n DE_CONT      Continue dbEdit() as is.\n DE_REFRESH   Force reread/redisplay of all data rows.\n</table>\n\nThe user function is called once in each of the following cases:\n- The database is empty.\n- The user try to move past top of file or past bottom file.\n- Key exception, the uses had pressed a key that is not handled by dbEdit().\n- The keyboard buffer is empty or a screen refresh had just occurred\ndbEdit() is a compatibility function, it is superseded by the\nTBrowse class and there for not recommended for new applications.",
    "EXAMPLES": "// Browse a file using default values\nUSE test\ndbEdit()",
    "STATUS": "S",
    "COMPLIANCE": "<xUserFunc> can take a code block value, this is a Harbour\nextension.\n\nCA-Cl*pper will throw an error if there's no database open, Harbour\nwould return .F.\n\nCA-Cl*pper is buggy and will throw an error if the number of columns\nis zero, Harbour would return .F.\n\nThe CA-Cl*pper 5.2 NG state that the return value is NIL, this is\nwrong and should be read logical.\n\nThere is an undocumented result code (3) from the user defined\nfunction in CA-Cl*pper (both 87 and 5.x). This is an Append Mode which:\n\"split the screen to allow data to be appended in windowed area\".\nThis mode is not supported by Harbour.",
    "FILES": "Header files are dbedit.ch, inkey.ch\nLibrary is core",
    "SEEALSO": "@...SAY, Browse(), TBrowse class, Transform()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/browse.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "Browse()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Browse a database file",
    "SYNTAX": "Browse( [<nTop>, <nLeft>, <nBottom>, <nRight>] ) --> lOk",
    "ARGUMENTS": "<nTop> coordinate for top row display.\n\n<nLeft> coordinate for left column display.\n\n<nBottom> coordinate for bottom row display.\n\n<nRight> coordinate for right column display.",
    "RETURNS": "Browse() return .F. if there is no database open in this work area,\nelse it return .T.",
    "DESCRIPTION": "Browse() is a general purpose database browser, without any\nthinking you can browse a file using the following keys:\n\n<table>\n Key              Meaning\n\n Left             Move one column to the left (previous field)\n Right            Move one column to the right (next field)\n Up               Move up one row (previous record)\n Down             Move down one row (next record)\n PgUp             Move to the previous screen\n PgDn             Move to the next screen\n Ctrl+PgUp        Move to the top of the file\n Ctrl+PgDn        Move to the end of the file\n Home             Move to the leftmost visible column\n End              Move to the rightmost visible column\n Ctrl+Left        Pan one column to the left\n Ctrl+Right       Pan one column to the right\n Ctrl+Home        Move to the leftmost column\n Ctrl+End         Move to the rightmost column\n Esc              Terminate Browse()\n</table>\n\nOn top of the screen you see a status line with the following\nindication:\n\n<table>\n Record ###/###   Current record number / Total number of records.\n <none>           There are no records, the file is empty.\n <new>            You are in append mode at the bottom of file.\n <Deleted>        Current record is deleted.\n <bof>            You are at the top of file.\n</table>\n\nYou should pass whole four valid coordinate, if less than four\nparameters are passed to Browse() the coordinate are default to:\n1, 0, MaxRow(), MaxCol().",
    "EXAMPLES": "// this one shows you how to browse around\nUSE test\nBrowse()",
    "STATUS": "S",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "dbEdit()*, TBrowse class"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/browse.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "TBrowseDB()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Create a new TBrowse object to be used with database file",
    "SYNTAX": "TBrowseDB( [<nTop>], [<nLeft>], [<nBottom>], [<nRight>] ) --> oBrowse",
    "ARGUMENTS": "<nTop> coordinate for top row display.\n\n<nLeft> coordinate for left column display.\n\n<nBottom> coordinate for bottom row display.\n\n<nRight> coordinate for right column display.",
    "RETURNS": "TBrowseDB() return new TBrowse object with the specified coordinate\nand a default :SkipBlock, :GoTopBlock and :GoBottomBlock to browse\na database file.",
    "DESCRIPTION": "TBrowseDB() is a quick way to create a TBrowse() object along with\nthe minimal support needed to browse a database. Note that the\nreturned TBrowse() object contain no TBColumn() objects and you need\nto add column for each field by your self.",
    "EXAMPLES": "// For a good example, look at the source code for Browse() function\n// at src/rtl/browse.prg",
    "STATUS": "S",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "Browse(), TBColumn class, TBrowse class, TBrowseNew()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/command.txt",
    "AUTHOR": "Copyright 2000 Brian Hays <bhays@abacuslaw.com>",
    "TEMPLATE": "Command",
    "NAME": "CLASS",
    "CATEGORY": "Class",
    "SUBCATEGORY": "Definition",
    "ONELINER": "Define a Class for Object Oriented Programming",
    "SYNTAX": "[CREATE] CLASS <ClassName> [ <FROM, INHERIT> <SuperClass1> [, <SuperClassN>] ] [STATIC]",
    "ARGUMENTS": "<ClassName>  Name of the class to define. By tradition, Harbour\n             classes start with \"T\" to avoid collisions with user-\n             created classes.\n\n<SuperClass1...n> The Parent class(es) to use for inheritance.\n             Harbour supports Multiple Inheritance.\n\nSTATIC       This clause causes the class function to be declared\n             as a static function. It will therefore not be available outside the current module.",
    "DESCRIPTION": "CLASS creates a class from which you can create objects.\nThe CLASS command begins the class specification, in which the VAR\nelements (also known as instance variables) and METHODS of the\nclass are named. The following scoping commands may also appear.\nThey control the default scope of VAR and METHOD commands that follow them.\n\n<fixed>\n   EXPORTED:\n   VISIBLE:\n   HIDDEN:\n   PROTECTED:\n</fixed>\nThe class specification ends with the END CLASS command.\n\nClasses can inherit from multiple <SuperClasses>, and the chain of\ninheritance can extend to many levels.\n\nA program uses a Class by calling the Class Constructor, usually the\n`:New()` method, to create an object. That object is usually assigned\nto a variable, which is used to access the VAR elements and\nmethods.\n\nHarbour's OOP syntax and implementation supports Scoping (Protect, Hidden and Readonly)\nand Delegating, and is largely compatible with Class(y)(tm), TopClass(tm)\nand Visual Objects(tm).",
    "EXAMPLES": "#include \"hbclass.ch\"\n\nCREATE CLASS TBColumn\n\n   VAR Block      // Code block to retrieve data for the column\n   VAR Cargo      // User-definable variable\n   VAR ColorBlock // Code block that determines color of data items\n   VAR ColSep     // Column separator character\n   VAR DefColor   // Array of numeric indexes into the color table\n   VAR Footing    // Column footing\n   VAR FootSep    // Footing separator character\n   VAR Heading    // Column heading\n   VAR HeadSep    // Heading separator character\n   VAR Width      // Column display width\n   VAR ColPos     // Temporary column position on screen\n\n   METHOD New()    // Constructor\n\nENDCLASS\n\nMETHOD New() CLASS TBColumn\n   RETURN Self",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "SEEALSO": "HBClass(), VAR, METHOD"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/command.txt",
    "AUTHOR": "Copyright 2000 Brian Hays <bhays@abacuslaw.com>",
    "TEMPLATE": "Command",
    "NAME": "VAR",
    "CATEGORY": "Class",
    "SUBCATEGORY": "Data",
    "ONELINER": "Alternate syntax for VAR: instance variable for the objects.",
    "SYNTAX": "VAR <DataName1> [, <DataNameN>] [ AS <type> ] [ INIT <uValue> ]\n[[EXPORTED | VISIBLE] | [PROTECTED] | [HIDDEN]] [READONLY | RO]",
    "ARGUMENTS": "<DataName1>  Name of the VAR\n\n<type>       Optional data type specification from the following:\n             Character, Numeric, Date, Logical, Codeblock, NIL.\n\n<uValue>     Optional initial value when creating a new object.\n\nEXPORTED     Specifies that this VAR is accessible to functions and\n             methods outside of the class.  VISIBLE is a synonym for EXPORTED.\n\nPROTECTED    Specifies that this VAR is only accessible to functions and methods within this class and its subclasses.\n\nHIDDEN       Specifies that this VAR is only accessible to the\n             class where it was defined, and is not inherited by the\n             subclasses.\n\nREADONLY     Restricts assignment to the variable. If specified with\n             the EXPORTED clause, assignment is only permitted from the current\n             class and its subclasses.  If specified with the PROTECTED clause,\n             assignment is only permitted from the current class.\n             RO is a synonym for READONLY.",
    "DESCRIPTION": "VAR elements can also be thought of as the \"properties\" of an\nobject. They can be of any data type, including codeblock.\nOnce an object has been created, the VAR elements are referenced\nwith the colon `:` as in `MyObject:Heading := \"Last name\"`.\nUsually a class also defines methods to manipulate the VAR.\n\nYou can use the `AS <type>` clause to enforce that the VAR is\nmaintained as a certain type. Otherwise it will take on the type of\nwhatever value is first assigned to it.\n\nUse the `INIT <uValue>` clause to initialize that VAR to <uValue>\nwhenever a new object is created.\n\nVAR can be a synonym for VAR, or it can use a slightly different\nsyntax for compatibility with other dialects.",
    "EXAMPLES": "#include \"hbclass.ch\"\n\nCREATE CLASS TBColumn\n\n   VAR Block      // Code block to retrieve data for the column\n   VAR Cargo      // User-definable variable\n   VAR ColorBlock // Code block that determines color of data items\n   VAR ColSep     // Column separator character\n   VAR DefColor   // Array of numeric indexes into the color table\n   VAR Footing    // Column footing\n   VAR FootSep    // Footing separator character\n   VAR Heading    // Column heading\n   VAR HeadSep    // Heading separator character\n   VAR Width      // Column display width\n   VAR ColPos     // Temporary column position on screen\n\n   METHOD New()   // Constructor\n\nENDCLASS\n\nMETHOD New() CLASS TBColumn\n   RETURN Self",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "SEEALSO": "CLASS, METHOD, CLASS VAR, VAR"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/command.txt",
    "AUTHOR": "Copyright 2000 Brian Hays <bhays@abacuslaw.com>",
    "TEMPLATE": "Command",
    "NAME": "CLASS VAR",
    "CATEGORY": "Class",
    "SUBCATEGORY": "Data",
    "ONELINER": "Define a CLASS VAR variable for a class (NOT for an Object!)",
    "SYNTAX": "CLASS VAR <DataName1> [, <DataNameN>] [ AS <type> ] [ INIT <uValue> ]",
    "ARGUMENTS": "<DataName1>  Name of the VAR\n\n<type>       Optional data type specification from the following:\n                Character, Numeric, Date, Logical, Codeblock, NIL\n\n<uValue>     Optional initial value at program startup",
    "DESCRIPTION": "`CLASS VAR` variables can also be thought of as the \"properties\" of an\nentire class. Each `CLASS VAR` exists only once, no matter how many\nobjects are created. A common usage is for a counter that is\nincremented whenever an object is created and decremented when one\nis destroyed, thus monitoring the number of objects in existence\nfor this class.\n\nYou can use the `AS <type>` clause to enforce that the `CLASS VAR` is\nmaintained as a certain type. Otherwise it will take on the type of\nwhatever value is first assigned to it.\nUse the `INIT <uValue>` clause to initialize that `VAR` to <uValue>\nwhenever the class is first used.",
    "EXAMPLES": "#include \"hbclass.ch\"\nCREATE CLASS TWindow\n   VAR   hWnd, nOldProc\n   CLASS VAR lRegistered AS LOGICAL\nENDCLASS",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "SEEALSO": "CLASS, METHOD, VAR"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/command.txt",
    "AUTHOR": "Copyright 2000 Brian Hays <bhays@abacuslaw.com>",
    "TEMPLATE": "Command",
    "NAME": "METHOD",
    "CATEGORY": "Class",
    "SUBCATEGORY": "Method",
    "ONELINER": "Declare a METHOD for a class in the class header",
    "SYNTAX": "METHOD <MethodName>( [<params,...>] ) [CONSTRUCTOR]\nMETHOD <MethodName>( [<params,...>] ) INLINE <Code,...>\nMETHOD <MethodName>( [<params,...>] ) BLOCK  <CodeBlock>\nMETHOD <MethodName>( [<params,...>] ) EXTERN <NAME>( [<args,...>] )\nMETHOD <MethodName>( [<params,...>] ) SETGET\nMETHOD <MethodName>( [<params,...>] ) VIRTUAL\nMETHOD <MethodName>( [<param>] )      OPERATOR <op>\nMETHOD <MethodName>( [<params,...>] ) CLASS <ClassName>",
    "ARGUMENTS": "<MethodName>  Name of the method to define\n\n<params,...>  Optional parameter list",
    "DESCRIPTION": "Methods are \"class functions\" which do the work of the class.\nAll methods must be defined in the class header between the\nCLASS and ENDCLASS commands.  If the body of a method is not fully\ndefined here, the full body is written below the ENDCLASS command\nusing this syntax:\n\nMETHOD <MethodName>( [<params,...>] ) CLASS <ClassName>\n\nMethods can reference the current object with the keyword `Self:` or\nits shorthand version `::`.\n\nCLAUSES:\n\nCONSTRUCTOR  Defines a special method Class Constructor method,\n             used to create objects.  This is usually the\n             New() method. Constructors always return the new\n             object.\n\nINLINE       Fast and easy to code, INLINE lets you define the\n             code for the method immediately within the definition\n             of the Class. Any methods not declared INLINE or BLOCK\n             must be fully defined after the ENDCLASS command.\n             The <Code, ...> following INLINE receives a parameter\n             of Self. If you need to receive more parameters, use\n             the BLOCK clause instead.\n\nBLOCK        Use this clause when you want to declare fast 'inline'\n             methods that need parameters. The first parameter to\n             <CodeBlock> must be Self, as in:\n\nMETHOD       `<MethodName> BLOCK {| Self, <arg1>, <arg2>, ..., <argN> | ... }`\n\nEXTERN       If an external function does what the method needs,\n             use this clause to make an optimized call to that\n             function directly.\n\nSETGET       For calculated Data. The name of the method can be\n             manipulated like a Data element to Set or Get a value.\n\nVIRTUAL      Methods that do nothing. Useful for Base classes where\n             the child class will define the method's behavior, or\n             when you are first creating and testing a Class.\n\nOPERATOR     Operator Overloading for classes.\n             See example tests/testop.prg for details.\n\nCLASS <ClassName>\n             Use this syntax only for defining a full method after\n             the ENDCLASS command.",
    "EXAMPLES": "// FIXME\n#include \"hbclass.ch\"\nCREATE CLASS TWindow\n   VAR    hWnd, nOldProc\n   METHOD New() CONSTRUCTOR\n   METHOD Capture() INLINE  SetCapture( ::hWnd )\n   METHOD End() BLOCK  {| Self, lEnd | iif( lEnd := ::lValid(), ;\n      ::PostMsg( \"close\" ), ), lEnd }\n   METHOD EraseBkGnd( hDC )\n   METHOD cTitle( cNewTitle ) SETGET\n   METHOD Close() VIRTUAL\nENDCLASS\n\nMETHOD New() CLASS TWindow\n   LOCAL nVar, cStr\n   // ... <code> ...\n   // ... <code> ...\n   RETURN Self",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "SEEALSO": "HBClass(), VAR, CLASS"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/command.txt",
    "AUTHOR": "Copyright 2000 Brian Hays <bhays@abacuslaw.com>",
    "TEMPLATE": "Command",
    "NAME": "MESSAGE",
    "CATEGORY": "Class",
    "SUBCATEGORY": "Method",
    "ONELINER": "Route a method call to another Method",
    "SYNTAX": "MESSAGE <MessageName>   METHOD <MethodName>( [<params,...>] )\nMESSAGE <MessageName>() METHOD <MethodName>( [<params,...>] )",
    "ARGUMENTS": "<MessageName>  The pseudo-method name to define\n\n<MethodName>   The method to create and call when <MessageName>\n               is invoked.\n\n<params,...>   Optional parameter list for the method",
    "DESCRIPTION": "The MESSAGE command is a seldom-used feature that lets you re-route\na call to a method with a different name. This can be necessary if\na method name conflicts with a public function that needs to be\ncalled from within the class methods.\n\nFor example, your app may have a public function called BeginPaint()\nthat is used in painting windows. It would also be natural to have a\nWindow class method called `:BeginPaint()` that the application can\ncall. But within the class method you would not be able to call the\npublic function because internally methods are based on static\nfunctions (which hide public functions of the same name).\n\nThe MESSAGE command lets you create the true method with a different\nname (`::xBeginPaint()`), yet still allow the `::BeginPaint()` syntax\nto call `::xBeginPaint()`.  This is then free to call the public\nfunction BeginPaint().",
    "EXAMPLES": "// FIXME\n#include \"hbclass.ch\"\nCREATE CLASS TWindow\n   VAR    hWnd, nOldProc\n   METHOD New() CONSTRUCTOR\n   MESSAGE BeginPaint METHOD xBeginPaint()\nENDCLASS",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "SEEALSO": "METHOD, VAR, CLASS"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/command.txt",
    "AUTHOR": "Copyright 2000 Brian Hays <bhays@abacuslaw.com>",
    "TEMPLATE": "Command",
    "NAME": "ERROR HANDLER",
    "CATEGORY": "Class",
    "SUBCATEGORY": "Method",
    "ONELINER": "Designate a method as an error handler for the class",
    "SYNTAX": "ERROR HANDLER <MethodName>( [<params,...>] )",
    "ARGUMENTS": "<MethodName>  Name of the method to define\n\n<params,...>  Optional parameter list",
    "DESCRIPTION": "`ERROR HANDLER` names the method that should handle errors for the\nclass being defined.",
    "EXAMPLES": "#include \"hbclass.ch\"\n\nCREATE CLASS TWindow\n   ERROR HANDLER MyErrHandler()\nENDCLASS\n\nMETHOD MyErrHandler() CLASS TWindow\n   RETURN Self",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "SEEALSO": "ON ERROR, CLASS, METHOD, VAR"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/command.txt",
    "AUTHOR": "Copyright 2000 Brian Hays <bhays@abacuslaw.com>",
    "TEMPLATE": "Command",
    "NAME": "ON ERROR",
    "CATEGORY": "Class",
    "SUBCATEGORY": "Method",
    "ONELINER": "Designate a method as an error handler for the class",
    "SYNTAX": "ON ERROR <MethodName>( [<params,...>] )",
    "ARGUMENTS": "<MethodName>  Name of the method to define\n\n<params,...>  Optional parameter list",
    "DESCRIPTION": "`ON ERROR` is a synonym for `ERROR HANDLER`.\nIt names the method that should handle errors for the\nclass being defined.",
    "EXAMPLES": "#include \"hbclass.ch\"\n\nCREATE CLASS TWindow\n   ON ERROR MyErrHandler()\nENDCLASS\n\nMETHOD MyErrHandler() CLASS TWindow\n   RETURN Self",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "SEEALSO": "ERROR HANDLER, CLASS, METHOD, VAR"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/command.txt",
    "AUTHOR": "Copyright 2000 Brian Hays <bhays@abacuslaw.com>",
    "TEMPLATE": "Command",
    "NAME": "ENDCLASS",
    "CATEGORY": "Class",
    "SUBCATEGORY": "Definition",
    "ONELINER": "End the declaration of a class.",
    "SYNTAX": "ENDCLASS",
    "ARGUMENTS": "(This statement has no arguments)",
    "DESCRIPTION": "ENDCLASS marks the end of a class declaration.\nIt is usually followed by the class methods that are not INLINE.",
    "EXAMPLES": "#include \"hbclass.ch\"\nCREATE CLASS TWindow\n   VAR hWnd, nOldProc\nENDCLASS",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "SEEALSO": "CLASS, METHOD, VAR"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/compiler.txt",
    "TEMPLATE": "Document",
    "NAME": "Compiler Options",
    "CATEGORY": "Document",
    "SUBCATEGORY": "Compiler",
    "DESCRIPTION": "<b>Invoking the Harbour compiler:</b>\n==============================\n\n```\nharbour <file[.prg]> [options]\n```\nor\n```\nharbour [options] <file[.prg]>\n```\nor\n```\nharbour [options] <file[.prg]> [options]\n```\n\nThe command-line options have to be separated by at least one space.\nThe option can start with either `-` character or `/` character.\n\n<b>The Harbour command-line options:</b>\n=================================\n\n`-a`               automatic memvar declaration\n\n    This causes all variables declared by PARAMETER, PRIVATE or PUBLIC\n    statements to be automatically declared as MEMVAR variables.\n\n=================\n`-b`               debug info\n\n    The compiler generates all information required for debugging\n\n=================\n`-build`           display detailed version info\n\n=================\n`-credits`         display credits\n\n=================\n`-d<id>[=<val>]`   `#define <id>`\n\n=================\n`-es[<level>]`     set exit severity\n\n    `-es` or `-es0` - all warnings are ignored and exit status returned\n                      by the compiler is equal to 0 if there are no\n                      errors in compiled source file.\n\n    `-es1`      - any warnings generate a non-zero exit status, but\n                  output is still created.\n\n    `-es2`      - all warnings are treated as errors and no output\n                  file is created. The exit status is set to a non-zero\n                  value.\n\n=================\n`-fn[:[l|u]|-]`    set file name casing (`l`=lower `u`=upper)\n\n=================\n`-fd[:[l|u]|-]`    set directory casing (`l`=lower `u`=upper)\n\n=================\n`-fp[:<char>]`     set path separator\n\n=================\n`-fs[-]`           turn file name space trimming on or off (default)\n\n=================\n`-g<type>`         output type generated is <type>\n\n    `-gc[<type>]`  output type: C source `.c` (default)\n                    <type>: `0`=compact (default) `1`=normal `2`=verbose\n                            `3`=generate real C code\n\n    `-gh`          output type: Harbour Portable Object `.hrb`\n\n    `-gd[.<destext>]`  generate dependencies list into `.d` file\n\n    `-ge[<mode>]`      error output <mode>: `0`=Clipper (default)\n                                            `1`=IDE friendly\n\n=================\n`-i<path>`         #include file search path\n\n=================\n`-i[-|+]`          disable/enable support for INCLUDE envvar\n\n=================\n`-j[<file>]`     generate i18n gettext file `.pot`\n\n=================\n`-k<mode>`       compilation mode (type `-k?` for more data)\n\n    `-kc`        clear all flags (strict Clipper mode)\n\n    `-kh`        Harbour mode (default)\n\n    `-ko`        allow operator optimizations\n\n    `-ki`        enable support for HB_INLINE (default)\n\n    `-kr`        runtime settings enabled\n\n    `-ks`        allow indexed assignment on all types\n\n    `-kx`        extended Xbase++ mode (default)\n\n    `-ku`        strings in user encoding\n\n    `-kd`        accept macros with declared symbols\n\n    `-km`        turn off macro-text substitution\n\n    `-kj`        turn off jump optimization in pcode\n\n    `-k?`        this info\n\n=================\n`-l`               suppress line number information\n\n    The compiler does not generate the source code line numbers in\n    the output file. The ProcLine() function will return 0 for\n    modules compiled using this option.\n\n=================\n`-m`               compile module only\n\n=================\n`-n[<type>]`       no implicit starting procedure\n\n                   <type>: `0`=no implicit starting procedure\n                           `1`=no starting procedure at all\n                           `2`=add starting procedure if necessary\n\n    The compiler does not create a procedure with the same name as\n    the compiled file. This means that any declarations placed\n    before the first PROCEDURE or FUNCTION statement have file-\n    wide scope and can be accessed/used in all functions/procedures\n    defined in the compiled source file. All executable statements\n    placed at the beginning of the file and before the first\n    PROCEDURE/FUNCTION statement are ignored.\n\n=================\n`-o<path>`         object file drive and/or path\n\n=================\n`-p`               generate pre-processed output `.ppo` file\n\n    The compiler only creates the file that contains the result of\n    pre-processing the source file.\n\n=================\n`-p+`              generate pre-processor trace `.ppt` file\n\n=================\n`-q`               quiet\n\n    The compiler does not print any messages during compiling\n    (except the copyright info).\n\n    `-q0`     quiet and don't display program header\n\n    `-q2`     disable all output messages\n\n    `-ql`     suppress line number information\n\n=================\n`-r[<lib>]`        request linker to search <lib> (or none)\n\n    Currently not supported in Harbour.\n\n=================\n`-r=<max>`         sets maximum number of preprocessor iterations\n\n    This set the maximum number of preprocessor iterations\n    during processing the source code. If this switch is not\n    used then the preprocessor stops after 1024 iterations.\n    This value is used to stop processing of infinite loops,\n    for example:\n    `#command ( => (,7`\n\n=================\n`-s[m]`            syntax check only [minimal for dependencies list]\n\n    The compiler checks the syntax only. No output file is generated.\n\n\n=================\n`-t<path>`         path for temp file creation\n\n    Currently not used in Harbour (the Harbour compiler does not\n    create any temporary files).\n\n=================\n`-u[<file>]`       use command def set in <file> (or none)\n\n=================\n`-u+<file>`        add command def set from <file>\n\n=================\n`-undef:<id>`      `#undef <id>`\n\n=================\n`-v`               variables are assumed `M->`\n\n    All undeclared or unaliased variables are assumed MEMVAR\n    variables (private or public variables). If this switch is not\n    used then the scope of such variables is checked at runtime.\n\n=================\n`-w[<level>]`     set warning level number (0..3, default 1)\n\n    `-w0`         - no warnings\n\n    `-w` or `-w1` - CA-Cl*pper compatible warnings\n\n    `-w2`         - some useful warnings missed in CA-Cl*pper\n\n    `-w3`         - warnings generated for Harbour language extensions\n                    and also enables strong type checking but only\n                    warns against declared types, or types which may be\n                    calculated at compile time\n\n=================\n`-x[<prefix>]`    set symbol init function name prefix (for `.c` only)\n\n    Sets the prefix added to the generated symbol init function name\n    (in C output currently). This function is generated\n    automatically for every PRG module compiled. This additional\n    prefix can be used to suppress problems with duplicated symbols\n    during linking an application with some third party libraries.\n\n=================\n`-z`               suppress shortcutting (`.AND.` & `.OR.`)\n\nCompilation in batch mode.\n==========================\n\n `@file`         compile list of modules in <file>\n\n    Not supported yet.\n\n<b>Known incompatibilities between Harbour and CA-Cl*pper compilers</b>\n=============================================================\n\nNote:\n\nIf you want a 100% compatible runtime libraries then you have\nto define HB_CLP_STRICT, using `HB_USER_CFLAGS=-DHB_CLP_STRICT`,\nthen rebuild.\n\n<b>Passing an undeclared variable by the reference</b>\n===============================================\n\nThe CA-Cl*pper compiler uses the special opcode PUSHP to pass a\nreference to an undeclared variable (`@` operator). The type of\npassed variable is checked at runtime (field or memvar). However,\nfield variables cannot be passed by reference. This means that\nCA-Cl*pper checks the memvar variable only and doesn't look for a field.\nThis is the reason why the Harbour compiler uses the usual\nPUSHMEMVARREF opcode in such cases. Notice that the runtime behavior\nis the same in CA-Cl*pper and in Harbour - only the generated opcodes\nare different.\n\nHandling of object messages\n===========================\n\nThe HB_CLP_STRICT setting determines\nthe way chained send messages are handled.\n\nFor example, the following code:\n\n`a:b( COUNT() ):c += 1`\n\nwill be handled as:\n\n`a:b( COUNT() ):c := a:b( COUNT() ):c + 1`\n\nin strict CA-Cl*pper compatibility mode and\n\n`temp := a:b( COUNT() ), temp:c += 1`\n\nin non-strict mode.\n\nIn practice, CA-Cl*pper will call the COUNT() function two times:\nthe first time before addition and the second one after addition.\nIn Harbour, COUNT() will be called only once, before addition.\n\nThe Harbour (non-strict) method is:\n\n1) faster\n\n2) it guarantees that the same instance variable of the same object\nwill be changed\n\n(See also: include/hbexpra.c, include/hbexprb.c)\n\n<b>Initialization of static variables</b>\n==================================\n\nThere is a difference in the initialization of static\nvariables that are initialized with a codeblock that refers to\na local variable. For example:\n\n<fixed>\nLOCAL MyLocalVar\nSTATIC s_MyStaticVar := {|| MyLocalVar }\n\nMyLocalVar := 0\n? Eval( s_MyStaticVar )\n</fixed>\n\nThe above code compiles fine in CA-Cl*pper, but it generates a\nruntime error `Error/BASE 1132 Bound error: array access\nCalled form (b)STATICS$(0)`\n\nIn Harbour this code generates a compile time error:\n`Error E0009 Illegal variable (b) initializer: 'MyLocalVar'`\n\nBoth CA-Cl*pper and Harbour are handling all local variables used in a\ncodeblock in a special way: they are detached from the local stack\nof function/procedure where they are declared. This allows access to\nthese variables after the exit from a function/procedure. However,\nall static variables are initialized in a separate procedure\n(`STATICS$` in CA-Cl*pper and `(_INITSTATICS)` in Harbour) before the\nmain procedure and before all INIT procedures. The local variables\ndon't exist on the eval stack when static variables are initialized,\nso they cannot be detached.\n"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "CDoW()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Converts a date to the day of week",
    "SYNTAX": "CDoW( <dDate> ) --> cDay",
    "ARGUMENTS": "<dDate>  Any date expression.",
    "RETURNS": "<cDay>  The current day of week.",
    "DESCRIPTION": "This function returns a character string of the day of the week,\nfrom a date expression <dDate> passed to it.\nIf a NULL date is passed to the function, the value of the function\nwill be a NULL byte.",
    "EXAMPLES": "? CDoW( Date() )\nIF CDoW( Date() + 10 ) == \"Sunday\"\n   ? \"This is a sunny day.\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Day(), DoW(), Date(), CMonth()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "CMonth()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Return the name of the month.",
    "SYNTAX": "CMonth( <dDate> ) --> cMonth",
    "ARGUMENTS": "<dDate>  Any date expression.",
    "RETURNS": "<cMonth>  The current month name",
    "DESCRIPTION": "This function returns the name of the month (January, February, etc.)\nfrom a date expression <dDate> passed to it.\nIf a NULL date is passed to the function, the value of the function\nwill be a NULL byte.",
    "EXAMPLES": "? CMonth( Date() )\nIF CMonth( Date() + 10 ) == \"March\"\n   ? \"Have you done your system backup?\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "CDoW(), Date(), Month(), Year(), DoW(), DToC()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Date()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Return the Current OS Date",
    "SYNTAX": "Date() --> dCurDate",
    "ARGUMENTS": "None",
    "RETURNS": "<dCurDate>  Current system date.",
    "DESCRIPTION": "This function returns the current system date.",
    "EXAMPLES": "? Date()\n? \"Today is\", hb_ntos( Day( Date() ) ), \"of\", CMonth( Date() ), \"of\", StrZero( Year( Date() ), 4 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "CToD(), DToS(), DToC(), Day(), Month(), CMonth()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "CToD()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Converts a character string to a date expression",
    "SYNTAX": "CToD( <cDateString> ) --> dDate",
    "ARGUMENTS": "<cDateString> A character date in format \"mm/dd/yy\"",
    "RETURNS": "<dDate> A date expression",
    "DESCRIPTION": "This function converts a date that has been entered as a character\nexpression to a date expression. The character expression will be in\nthe form `MM/DD/YY` (based on the default value in `SET DATE`) or in\nthe appropriate format specified by the `SET DATE TO` command. If an\nimproper character string is passed to the function, an empty date\nvalue will be returned.",
    "EXAMPLES": "Set( _SET_DATEFORMAT, \"yyyy-mm-dd\" )\n? CToD( \"2000-12-21\" )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "SET DATE, Date(), DToS()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Day()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Return the numeric day of the month.",
    "SYNTAX": "Day( <cDate> ) --> nMonth",
    "ARGUMENTS": "<cDate> Any valid date expression.",
    "RETURNS": "<nMonth> Numeric value of the day of month.",
    "DESCRIPTION": "This function returns the numeric value of the day of month from a\ndate.",
    "EXAMPLES": "? Day( Date() )\n? Day( Date() + 6325 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "CToD(), DToS(), DToC(), Date(), Month(), CMonth()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Days()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Convert elapsed seconds into days",
    "SYNTAX": "Days( <nSecs> ) --> nDay",
    "ARGUMENTS": "<nSecs> The number of seconds",
    "RETURNS": "<nDay>  The number of days",
    "DESCRIPTION": "This function converts <nSecs> seconds to the equivalent number\nof days; 86399 seconds represents one day, 0 seconds being midnight.",
    "EXAMPLES": "? Days( 2434234 )\n? Days( 63251 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Seconds(), Secs(), ElapTime()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "DoW()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Value for the day of week.",
    "SYNTAX": "DoW( <dDate> ) --> nDay",
    "ARGUMENTS": "<dDate>  Any valid date expression",
    "RETURNS": "<nDay>  The current day number",
    "DESCRIPTION": "This function returns the number representing the day of the week\nfor the date expressed as <dDate>.\nReturned value range is from 1 (Sunday) to 7 (Saturday).",
    "EXAMPLES": "? DoW( Date() )\n? DoW( Date() - 6584 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "DToC(), CDoW(), Date(), DToS(), Day()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "DToC()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Date to character conversion",
    "SYNTAX": "DToC( <dDateString> ) --> cDate",
    "ARGUMENTS": "<dDateString> Any date",
    "RETURNS": "<dDate> Character representation of date",
    "DESCRIPTION": "This function converts any date expression (a field or variable)\nexpressed as <dDateString> to a character expression in the default\nformat `MM/DD/YY`. The date format expressed by this function is\ncontrolled in part by the date format specified in the `SET DATE`\ncommand",
    "EXAMPLES": "? DToC( Date() )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "SET DATE, Date(), DToS()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "DToS()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Date to string conversion",
    "SYNTAX": "DToS( <dDateString> ) --> cDate",
    "ARGUMENTS": "<dDateString> Any date",
    "RETURNS": "<dDate> String notation of the date",
    "DESCRIPTION": "This function returns the value of <dDateString> as a character\nstring in the format of `YYYYMMDD`. If the value of <dDateString> is\nan empty date, this function will return eight blank spaces.",
    "EXAMPLES": "? DToS( Date() )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "DToC(), Date(), DToS()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "ElapTime()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Calculates elapsed time.",
    "SYNTAX": "ElapTime( <cStartTime>, <cEndTime> ) --> cDifference",
    "ARGUMENTS": "<cStartTime> Start in time as a string format\n<cEndTime>   End time as a string format",
    "RETURNS": "<cDifference>  Difference between the times",
    "DESCRIPTION": "This function returns a string that shows the difference between\nthe starting time represented as <cStartTime> and the ending time\nas <cEndTime>. If the stating time is greater then the ending\ntime, the function will assume that the date changed once.",
    "EXAMPLES": "STATIC s_cStartTime\nINIT PROCEDURE Startup()\n   s_cStartTime := Time()\n   RETURN\nEXIT PROCEDURE StartExit()\n   ? \"You used this program by\", ElapTime( s_cStartTime, Time() )\n   RETURN",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Secs(), Seconds(), Time(), Day()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "2017 Pete D. <pete_westg@yahoo.gr>",
    "TEMPLATE": "Function",
    "NAME": "hb_Week()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Returns the week number of year.",
    "SYNTAX": "hb_Week( <dDate>, [@<nYear>], [@<nDayOfWeek>] ) --> nWeekNumber",
    "ARGUMENTS": "<dDate> Any valid date expression.\n\n<nYear> Optional parameter to hold the year of the given date.\n\n<nDayOfWeek> Optional parameter to hold the day number of week.",
    "RETURNS": "<nWeekNumber> The ordinal week number of the year into which falls\n              the given <dDate>.",
    "DESCRIPTION": "This function returns the week number of year for the given <dDate>.\nThe returned value is an ISO 8601 compliant week number.\nOptionally, can also be obtained the year and/or the day number of\nthe week of the given <dDate>, if the <nYear> and/or <nDayOfWeek>\nparameters have been passed by reference.\nIf <dDate> is an empty date expression, the function returns zero(s).\nNote: new function available after 2017-02-08 19:36 UTC+0100 commit,\n      not found in earlier versions.",
    "EXAMPLES": "LOCAL nYear, nDayOfWeek\n? hb_Week( 0d20170215, @nYear, @nDayOfWeek ), nYear, nDayOfWeek  // --> 7, 2017, 3\n? hb_Week( 0d00000000, @nYear, @nDayOfWeek ), nYear, nDayOfWeek  // --> 0, 0, 0",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Year(), Month(), Day()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Month()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Converts a date expression to a month value",
    "SYNTAX": "Month( <dDate> ) --> nMonth",
    "ARGUMENTS": "<dDate> Any valid date expression",
    "RETURNS": "<nMonth> Corresponding number of the month in the year, ranging from\n 0 to 12",
    "DESCRIPTION": "This function returns a number that represents the month of a given\ndate expression <dDate>. If a NULL date (`hb_SToD()`) is passed to the\nfunction, the value of the function will be 0.",
    "EXAMPLES": "? Month( Date() )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "CDoW(), DoW(), Year(), CMonth()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Seconds()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Returns the number of elapsed seconds past midnight.",
    "SYNTAX": "Seconds() --> nSeconds",
    "ARGUMENTS": "None",
    "RETURNS": "<nSeconds> Number of seconds since midnight",
    "DESCRIPTION": "This function returns a numeric value representing the number of\nelapsed seconds based on the current system time.\nThe system time is considered to start at 0 (midnight); it continues\nup to 86399 seconds. The value of the return expression is displayed\nin both seconds and hundredths of seconds.",
    "EXAMPLES": "? Seconds()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Time()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Secs()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Return the number of seconds from the system date.",
    "SYNTAX": "Secs( <cTime> ) --> nSeconds",
    "ARGUMENTS": "<cTime> Character expression in a time string format",
    "RETURNS": "<nSeconds> Number of seconds",
    "DESCRIPTION": "This function returns a numeric value that is a number of elapsed\nseconds from midnight based on a time string given as <cTime>.",
    "EXAMPLES": "? Secs( Time() )\n? Secs( Time() - 10 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Seconds(), ElapTime(), Time()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Time()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Returns the system time as a string",
    "SYNTAX": "Time() --> cTime",
    "ARGUMENTS": "None",
    "RETURNS": "<cTime> Character string representing time",
    "DESCRIPTION": "This function returns the system time represented as a character\nexpression in the format of `HH:MM:SS`",
    "EXAMPLES": "? Time()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Date(), Seconds()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Year()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Extracts the year designator of a given date as a numeric value",
    "SYNTAX": "Year( <dDate> ) --> nYear",
    "ARGUMENTS": "<dDate> Any valid date expression",
    "RETURNS": "<nYear> The year portion of the date.",
    "DESCRIPTION": "This function returns the numeric value for the year in <dDate>.\nThe returned value is not affected by the `SET CENTURY` and `SET DATE`\nsettings and will always be a four-digit year number, unless the <dDate>\nis an empty date expression, in which case it will be zero.",
    "EXAMPLES": "? Year( Date() )\n? Year( 0d32510125 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Day(), Month()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/datetime.txt",
    "AUTHOR": "",
    "TEMPLATE": "Function",
    "NAME": "hb_DToT()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Date/Time",
    "ONELINER": "Create a <tDateTime> value from a <dDate> parameter",
    "SYNTAX": "hb_DToT( <dDate> [, <cTime|nSeconds>] ) --> <tDateTime>",
    "ARGUMENTS": "<dDate> Any valid date expression.\n\nOptional: <cTime|nSeconds> representing a time of the day value.\n<cTime> is a string in a valid time format: \"hh:mm:ss.nnn\".\n<nSeconds> is a numeric value in seconds in the range from\n0 to 86399.999~ ( 60 secs * 60 mins * 24 hours - 1 millisecond )",
    "RETURNS": "<tDateTime> a dateTime value",
    "DESCRIPTION": "This function returns a <tDateTime> value from a <dDate> value.\nOptionally, a second parameter with the time of the day value\ncan be provided which can be represented by either of a string\ntime value or a numeric value in seconds.",
    "EXAMPLES": "? hb_DToT( Date() )  // a dateTime with a empty time part\n? hb_DToT( Date(), \"14:30:00.500\" )  // a dateTime with time part 14:30pm with 500 milliseconds\n? hb_DToT( Date(), 3600 )  // a dateTime with time part 1:00am (one hour)",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Date()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dbdelim.txt",
    "AUTHOR": "Copyright 2001-2002 David G. Holm <dholm@jsd-llc.com>",
    "TEMPLATE": "Procedure",
    "NAME": "__dbDelim()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Copies the contents of a database to a delimited text file or\nappends the contents of a delimited text file to a database.",
    "SYNTAX": "__dbDelim( <lExport>, <xcFile>, [<xcDelim>], [<aFields>],\n[<bFor>], [<bWhile>], [<nNext>], [<nRecord>], <lRest>  )",
    "ARGUMENTS": "<lExport> If set to .T., copies records to a delimited file.\nIf set to .F., append records from a delimited file.\n\n<xcFile> The name of the text file to copy to or append from.\nIf a file extension is not specified, \".txt\" is used by default.\n\n<xcDelim> Either the character to use as the character field\ndelimiter (only the first character is used). or `\"BLANK\"` (not case\nsensitive), which eliminates the character field delimiters and\nsets the field separator to a single space instead of a comma.\n\n<aFields> An array of field names to limit the processing to. If\nnot specified, or if empty, then all fields are processed.\n\n<bFor> An optional code block containing a FOR expression that\nwill reduce the number of records to be processed.\n\n<bWhile> An optional code block containing a WHILE expression\nthat will reduce the number of records to be processed.\n\n<nNext> If present, but nRecord is not present, specifies to\nprocess this number of records, starting with the current record.\nA value of 0 means to process no records.\n\n<nRecord> If present, specifies the only record to process. A\nvalue of 0 means to process no records. Overrides <nNext> and <lRest>.\n\n<lRest> If <lExport> is .T., then if <lRest> is set to .T. and there are no\n<nRecord>, <nNext>, or <bWhile> arguments, processes all records from\ncurrent to last.",
    "DESCRIPTION": "__dbDelim() copies all or selected contents of a database table\nto an SDF text file or appends all or selected contents of an SDF\ntext file to a database table.",
    "EXAMPLES": "// Copy delinquent accounts into a delimited text file.\nUSE accounts NEW\nCOPY TO overdue DELIMITED FOR ! Empty( accounts->duedate ) ;\n   .AND. Date() - accounts->duedate > 30\n// Import new customer records.\nUSE customer NEW\nAPPEND FROM customer DELIMITED",
    "STATUS": "S",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "",
    "SEEALSO": "__dbSDF(), APPEND FROM, COPY TO"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dbsdf.txt",
    "AUTHOR": "Copyright 2001-2002 David G. Holm <dholm@jsd-llc.com>",
    "TEMPLATE": "Procedure",
    "NAME": "__dbSDF()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Copies the contents of a database to an SDF text file or appends the\ncontents of an SDF text file to a database.",
    "SYNTAX": "__dbSDF( <lExport>, <xcFile>, [<aFields>],\n   [<bFor>], [<bWhile>], [<nNext>], [<nRecord>], <lRest> )",
    "ARGUMENTS": "<lExport> If set to .T., copies records to an SDF file.\nIf set to .F., append records from an SDF file.\n\n<xcFile> The name of the text file to copy to or append from.\nIf a file extension is not specified, \".txt\" is used by default.\n\n<aFields> An array of field names to limit the processing to. If not\nspecified, or if empty, then all fields are processed.\n\n<bFor> An optional code block containing a FOR expression that will\nreduce the number of records to be processed.\n\n<bWhile> An optional code block containing a WHILE expression that will\nreduce the number of records to be processed.\n\n<nNext> If present, but <nRecord> is not present, specifies to process\nthis number of records, starting with the current record.\nA value of 0 means to process no records.\n\n<nRecord> If present, specifies the only record to process. A value of 0\nmeans to process no records. Overrides <nNext> and <lRest>.\n\n<lRest> If <lExport> is .T., then if <lRest> is set to .T. and there are\nno <nRecord>, <nNext>, or <bWhile> arguments, processes all records from\ncurrent to last.",
    "DESCRIPTION": "__dbSDF() copies all or selected contents of a database table to an SDF\ntext file or appends all or selected contents of an SDF text file to a\ndatabase table.",
    "EXAMPLES": "// Copy delinquent accounts into an SDF text file.\nUSE accounts NEW\nCOPY TO overdue SDF FOR ;\n   ! Empty( accounts->duedate ) .AND. ;\n   Date() - accounts->duedate > 30\n// Import new customer records.\nUSE customer NEW\nAPPEND FROM customer SDF",
    "STATUS": "S",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "",
    "SEEALSO": "__dbDelim(), APPEND FROM, COPY TO"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dbstrux.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Procedure",
    "NAME": "__dbCopyStruct()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Create a new database based on current database structure",
    "SYNTAX": "__dbCopyStruct( <cFileName>, [<aFieldList>] )",
    "ARGUMENTS": "<cFileName> is the name of the new database file to create. `.dbf`\nis the default extension if none is given.\n\n<aFieldList> is an array where each element is a field name.\nNames could be specified as uppercase or lowercase.",
    "DESCRIPTION": "__dbCopyStruct() create a new empty database file with a structure\nthat is based on the currently open database in this work-area. If\n<aFieldList> is empty, the newly created file would have the same\nstructure as the currently open database. Else, the new file would\ncontain only fields that exactly match <aFieldList>.\n\n__dbCopyStruct() can be use to create a sub-set of the currently\nopen database, based on a given field list.\n\n`COPY STRUCTURE` command is preprocessed into __dbCopyStruct()\nfunction during compile time.",
    "EXAMPLES": "// Create a new file that contain the same structure\nUSE test\n__dbCopyStruct( \"mycopy.dbf\" )\n\n// Create a new file that contain part of the original structure\nLOCAL aList\nUSE test\naList := { \"NAME\" }\n__dbCopyStruct( \"onlyname.dbf\", aList )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is rdd",
    "SEEALSO": "COPY STRUCTURE, COPY STRUCTURE EXTENDED, dbCreate(), dbStruct(), __dbCopyXStruct(), __dbCreate(), __dbStructFilter()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dbstrux.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Command",
    "NAME": "COPY STRUCTURE",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Database",
    "ONELINER": "Create a new database based on current database structure",
    "SYNTAX": "COPY STRUCTURE TO <xcFileName> [FIELDS <field,...>]",
    "ARGUMENTS": "`TO xcFileName` is the name of the new database file to\ncreate. `.dbf` is the default extension if none is given. It can be\nspecified as a literal file name or as a character expression\nenclosed in parentheses.\n\n`FIELDS `field,...` is an optional list of field names to copy\nfrom the currently open database in the specified order, the default\nis all fields. Names could be specified as uppercase or lowercase.",
    "DESCRIPTION": "`COPY STRUCTURE` create a new empty database file with a structure\nthat is based on the currently open database in this work-area.\n\n`COPY STRUCTURE` can be use to create a sub-set of the currently\nopen database, based on a given field list.\n\n`COPY STRUCTURE` command is preprocessed into __dbCopyStruct()\nfunction during compile time.",
    "EXAMPLES": "// Create a new file that contains the same structure\nUSE test\nCOPY STRUCTURE TO MyCopy\n\n// Create a new file that contains part of the original structure\nUSE test\nCOPY STRUCTURE TO SomePart FIELDS name, address",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "SEEALSO": "COPY STRUCTURE EXTENDED, dbCreate(), dbStruct(), __dbCopyStruct(), __dbCopyXStruct(), __dbCreate(), __dbStructFilter()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dbstrux.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__dbCopyXStruct()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Copy current database structure into a definition file",
    "SYNTAX": "__dbCopyXStruct( <cFileName> ) --> lSuccess",
    "ARGUMENTS": "<cFileName> is the name of target definition file to create. `.dbf`\nis the default extension if none is given.",
    "RETURNS": "__dbCopyXStruct() returns .F. if no database is *used* in the current\nwork-area, .T. on success, or a run-time error if the file create\noperation had failed.",
    "DESCRIPTION": "__dbCopyXStruct() create a new database named <cFileName> with a\npre-defined structure (also called \"structure extended file\"):\n\n<table>\n Field name   Type   Length   Decimals\n\n FIELD_NAME   C      10       0\n FIELD_TYPE   C      1        0\n FIELD_LEN    N      3        0\n FIELD_DEC    N      3        0\n</table>\n\nEach record in the new file contains information about one field in\nthe original file. `CREATE FROM` could be used to create a database\nfrom the structure extended file.\n\nFor prehistoric compatibility reasons, Character fields which are\nlonger than 255 characters are treated in a special way by writing\npart of the length in the FIELD_DEC according to the following\nformula (this is done internally):\n\n<fixed>\nFIELD->FIELD_DEC := Int( nLength / 256 )\nFIELD->FIELD_LEN :=      nLength % 256\n</fixed>\n\nLater if you want to calculate the length of a field you can use\nthe following formula:\n\n<fixed>\nnLength := iif( FIELD->FIELD_TYPE == \"C\", ;\n                FIELD->FIELD_DEC * 256 + FIELD->FIELD_LEN, ;\n                FIELD->FIELD_LEN )\n</fixed>\n\n`COPY STRUCTURE EXTENDED` command is preprocessed into\n__dbCopyXStruct() function during compile time.",
    "EXAMPLES": "// Open a database, then copy its structure to a new file,\n// Open the new file and list all its records\nUSE test\n__dbCopyXStruct( \"teststru\" )\nUSE teststru\nLIST",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is rdd",
    "SEEALSO": "COPY STRUCTURE, COPY STRUCTURE EXTENDED, CREATE, CREATE FROM, dbCreate(), dbStruct(), __dbCopyStruct(), __dbCreate()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dbstrux.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Command",
    "NAME": "COPY STRUCTURE EXTENDED",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Database",
    "ONELINER": "Copy current database structure into a definition file",
    "SYNTAX": "COPY STRUCTURE EXTENDED TO <xcFileName>",
    "ARGUMENTS": "<xcFileName> The name of the target definition file to\ncreate. `.dbf` is the default extension if none is given. It can be\nspecified as a literal file name or as a character expression\nenclosed in parentheses.",
    "DESCRIPTION": "`COPY STRUCTURE EXTENDED` create a new database named <cFileName> with\na pre-defined structure (also called \"structure extended file\"):\n\n<table>\n Field name   Type   Length   Decimals\n\n FIELD_NAME   C      10       0\n FIELD_TYPE   C      1        0\n FIELD_LEN    N      3        0\n FIELD_DEC    N      3        0\n</table>\n\nEach record in the new file contains information about one field in\nthe original file. `CREATE FROM` could be used to create a database\nfrom the structure extended file.\n\nFor prehistoric compatibility reasons, Character fields which are\nlonger than 255 characters are treated in a special way by writing\npart of the length in the FIELD_DEC according to the following\nformula (this is done internally):\n\n<fixed>\nFIELD->FIELD_DEC := Int( nLength / 256 )\nFIELD->FIELD_LEN :=      nLength % 256\n</fixed>\n\nLater if you want to calculate the length of a field you can use\nthe following formula:\n\n<fixed>\nnLength := iif( FIELD->FIELD_TYPE == \"C\", ;\n                FIELD->FIELD_DEC * 256 + FIELD->FIELD_LEN, ;\n                FIELD->FIELD_LEN )\n</fixed>\n\n`COPY STRUCTURE EXTENDED` command is preprocessed into\n__dbCopyXStruct() function during compile time.",
    "EXAMPLES": "// Open a database, then copy its structure to a new file,\n// Open the new file and list all its records\nUSE test\nCOPY STRUCTURE EXTENDED TO teststru\nUSE teststru\nLIST",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "SEEALSO": "COPY STRUCTURE, CREATE, CREATE FROM, dbCreate(), dbStruct(), __dbCopyStruct(), __dbCopyXStruct(), __dbCreate()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dbstrux.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__dbCreate()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Create structure extended file or use one to create new file",
    "SYNTAX": "__dbCreate( <cFileName>, [<cFileFrom>], [<cRDDName>], [<lNew>], [<cAlias>] ) --> lUsed",
    "ARGUMENTS": "<cFileName> is the target file name to create and then open. `.dbf`\nis the default extension if none is given.\n\n<cFileFrom> is an optional structure extended file name from which\nthe target file <cFileName> is going to be built. If omitted, a new\nempty structure extended file with the name <cFileName> is created\nand opened in the current work-area.\n\n<cRDDName> is RDD name to create target with. If omitted, the\ndefault RDD is used.\n\n<lNew> is an optional logical expression, (.T.) opens the target file\nname <cFileName> in the next available unused work-area and makes\nit the current work-area. (.F.) opens the target file in the current\nwork-area. Default value is (.F.). The value of <lNew> is ignored if\n<cFileFrom> is not specified.\n\n<cAlias> is an optional alias to USE the target file with. If not\nspecified, alias is based on the root name of <cFileName>.",
    "RETURNS": "__dbCreate() returns (.T.) if there is database *used* in the\ncurrent work-area (this might be the newly selected work-area), or\n(.F.) if there is no database *used*. Note that on success a (.T.)\nwould be returned, but on failure you probably end up with a\nrun-time error and not a (.F.) value.",
    "DESCRIPTION": "__dbCreate() works in two modes depending on the value of <cFileFrom>:\n\n<b>1)</b> If <cFileFrom> is empty or not specified a new empty\nstructure extended file with the name <cFileName> is created and\nthen opened in the current work-area (<lNew> is ignored). The new\nfile has the following structure:\n\n<table>\n Field name   Type   Length   Decimals\n\n FIELD_NAME   C      10       0\n FIELD_TYPE   C      1        0\n FIELD_LEN    N      3        0\n FIELD_DEC    N      3        0\n</table>\n\nThe CREATE command is preprocessed into the __dbCopyStruct() function\nduring compile time and uses this mode.\n\n<b>2)</b> If <cFileFrom> is specified, it is opened and assumed to\nbe a structure extended file where each record contains at least the\nfollowing fields (in no particular order): FIELD_NAME, FIELD_TYPE,\nFIELD_LEN and FIELD_DEC. Any other field is ignored. From this\ninformation the file <cFileName> is then created and opened in the\ncurrent or new work-area (according to <lNew>), if this is a new\nwork-area it becomes the current.\n\nFor prehistoric compatibility reasons, structure extended file\nCharacter fields which are longer than 255 characters should be\ntreated in a special way by writing part of the length in the\nFIELD_DEC according to the following formula:\n\n<fixed>\nFIELD->FIELD_DEC := Int( nLength / 256 )\nFIELD->FIELD_LEN :=      nLength % 256\n</fixed>\n\n`CREATE FROM` command is preprocessed into __dbCopyStruct() function\nduring compile time and use this mode.",
    "EXAMPLES": "// CREATE a new structure extended file, append some records and\n// then CREATE FROM this file a new database file\n\n__dbCreate( \"template\" )\ndbAppend()\nFIELD->FIELD_NAME := \"CHANNEL\"\nFIELD->FIELD_TYPE := \"N\"\nFIELD->FIELD_LEN  := 2\nFIELD->FIELD_DEC  := 0\ndbAppend()\nFIELD->FIELD_NAME := \"PROGRAM\"\nFIELD->FIELD_TYPE := \"C\"\nFIELD->FIELD_LEN  := 20\nFIELD->FIELD_DEC  := 0\ndbAppend()\nFIELD->FIELD_NAME := \"REVIEW\"\nFIELD->FIELD_TYPE := \"C\"      // this field is 1000 char long\nFIELD->FIELD_LEN  := 232      // 1000 % 256 = 232\nFIELD->FIELD_DEC  := 3        // 1000 / 256 = 3\ndbCloseArea()\n__dbCreate( \"TV_Guide\", \"template\" )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is rdd",
    "SEEALSO": "COPY STRUCTURE, COPY STRUCTURE EXTENDED, CREATE, CREATE FROM, dbCreate(), dbStruct(), __dbCopyStruct(), __dbCopyXStruct()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dbstrux.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Command",
    "NAME": "CREATE",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Database",
    "ONELINER": "Create empty structure extended file",
    "SYNTAX": "CREATE <xcFileName> [VIA <xcRDDName>] [ALIAS <xcAlias>]",
    "ARGUMENTS": "<xcFileName> is the target file name to create and then open. `.dbf`\nis the default extension if none is given. It can be specified as\nliteral file name or as a character expression enclosed in\nparentheses.\n\n`VIA xcRDDName` is RDD name to create target with. If omitted,\nthe default RDD is used. It can be specified as literal name or as a\ncharacter expression enclosed in parentheses.\n\n`ALIAS xcAlias` is an optional alias to USE the target file\nwith. If not specified, alias is based on the root name of\n<xcFileName>.",
    "DESCRIPTION": "CREATE a new empty structure extended file with the name <cFileName>\nand then open it in the current work-area. The new file has the\nfollowing structure:\n\n<table>\n Field name   Type   Length   Decimals\n\n FIELD_NAME   C      10       0\n FIELD_TYPE   C      1        0\n FIELD_LEN    N      3        0\n FIELD_DEC    N      3        0\n</table>\n\nCREATE command is preprocessed into __dbCopyStruct() function during\ncompile time and use this mode.",
    "EXAMPLES": "// CREATE a new structure extended file, append some records and\n// then CREATE FROM this file a new database file\n\nCREATE template\ndbAppend()\nFIELD->FIELD_NAME := \"CHANNEL\"\nFIELD->FIELD_TYPE := \"N\"\nFIELD->FIELD_LEN  := 2\nFIELD->FIELD_DEC  := 0\ndbAppend()\nFIELD->FIELD_NAME := \"PROGRAM\"\nFIELD->FIELD_TYPE := \"C\"\nFIELD->FIELD_LEN  := 20\nFIELD->FIELD_DEC  := 0\ndbAppend()\nFIELD->FIELD_NAME := \"REVIEW\"\nFIELD->FIELD_TYPE := \"C\"      // this field is 1000 char long\nFIELD->FIELD_LEN  := 232      // 1000 % 256 = 232\nFIELD->FIELD_DEC  := 3        // 1000 / 256 = 3\ndbCloseArea()\nCREATE TV_Guide FROM template",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "SEEALSO": "COPY STRUCTURE, COPY STRUCTURE EXTENDED, CREATE FROM, dbCreate(), dbStruct(), __dbCopyStruct(), __dbCopyXStruct(), __dbCreate()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dbstrux.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Command",
    "NAME": "CREATE FROM",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Database",
    "ONELINER": "Create new database file from a structure extended file",
    "SYNTAX": "CREATE <xcFileName> FROM <xcFileFrom> [VIA <xcRDDName>] [NEW] [ALIAS <xcAlias>]",
    "ARGUMENTS": "<xcFileName> is the target file name to create and then open. `.dbf`\nis the default extension if none is given. It can be specified as\nliteral file name or as a character expression enclosed in\nparentheses.\n\n`FROM xcFileFrom` is a structure extended file name from\nwhich the target file <xcFileName> is going to be built. It can be\nspecified as literal file name or as a character expression enclosed\nin parentheses.\n\n`VIA xcRDDName` is RDD name to create target with. If omitted,\nthe default RDD is used. It can be specified as literal name or as a\ncharacter expression enclosed in parentheses.\n\n`NEW` open the target file name <xcFileName> in the next\navailable unused work-area and making it the current work-area. If\nomitted open the target file in current work-area.\n\n`ALIAS xcAlias` is an optional alias to USE the target file\nwith. If not specified, alias is based on the root name of\n<xcFileName>.",
    "DESCRIPTION": "`CREATE FROM` open a structure extended file <xcFileFrom> where each\nrecord contain at least the following fields (in no particular\norder): FIELD_NAME, FIELD_TYPE, FIELD_LEN and FIELD_DEC. Any other\nfield is ignored. From this information the file <xcFileName> is\nthen created and opened in the current or new work-area (according to\nthe NEW clause), if this is a new work-area it becomes the current.\n\nFor prehistoric compatibility reasons, structure extended file\nCharacter fields which are longer than 255 characters should be\ntreated in a special way by writing part of the length in the\nFIELD_DEC according to the following formula:\n\n<fixed>\nFIELD->FIELD_DEC := Int( nLength / 256 )\nFIELD->FIELD_LEN :=      nLength % 256\n</fixed>\n\n`CREATE FROM` command is preprocessed into __dbCopyStruct() function\nduring compile time and uses this mode.",
    "EXAMPLES": "// See example in the CREATE command",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "SEEALSO": "COPY STRUCTURE, COPY STRUCTURE EXTENDED, CREATE, dbCreate(), dbStruct(), __dbCopyStruct(), __dbCopyXStruct(), __dbCreate()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dbstrux.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__FLedit()*",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Filter a database structure array",
    "SYNTAX": "__FLedit( <aStruct>, [<aFieldList>] ) --> aStructFiltered",
    "ARGUMENTS": "<aStruct> is a multidimensional array with database fields\nstructure, which is usually the output from dbStruct(), where each\narray element has the following structure:\n\n<table>\n Position   Description    dbstruct.ch\n\n 1          cFieldName     DBS_NAME\n 2          cFieldType     DBS_TYPE\n 3          nFieldLength   DBS_LEN\n 4          nDecimals      DBS_DEC\n</table>\n\n<aFieldList> is an array where each element is a field name.\nNames could be specified as uppercase or lowercase.",
    "RETURNS": "__FLedit() return a new multidimensional array where each element is\nin the same structure as the original <aStruct>, but the array is\nbuilt according to the list of fields in <aFieldList>. If\n<aFieldList> is empty, __FLedit() return reference to the original\n<aStruct> array.",
    "DESCRIPTION": "__FLedit() can be use to create a sub-set of a database structure,\nbased on a given field list.\n\nNote that field names in <aStruct> _must_ be specified in uppercase\nor else no match would be found.\n\n`SET EXACT` has no effect on the return value.\n\n__FLedit() is a compatibility function and it is synonym for\n__dbStructFilter() which does exactly the same.",
    "EXAMPLES": "// FIXME\nLOCAL aStruct, aList, aRet\naStruct := { ;\n   { \"CODE\",  \"N\",  4, 0 }, ;\n   { \"NAME\",  \"C\", 10, 0 }, ;\n   { \"PHONE\", \"C\", 13, 0 }, ;\n   { \"IQ\",    \"N\",  3, 0 } }\naList := { \"IQ\", \"NAME\" }\naRet := __FLedit( aStruct, aList )\n                   // { { \"IQ\", \"N\", 3, 0 }, { \"NAME\", \"C\", 10, 0 } }\n\naRet := __FLedit( aStruct, {} )\n? aRet == aStruct  // .T.\n\naList := { \"iq\", \"NOTEXIST\" }\naRet := __FLedit( aStruct, aList )\n                   // { { \"IQ\", \"N\", 3, 0 } }\n\naList := { \"NOTEXIST\" }\naRet := __FLedit( aStruct, aList )  // {}\n\n// Create a new file that contain part of the original structure\nLOCAL aStruct, aList, aRet\nUSE test\naStruct := dbStruct()\naList := { \"NAME\" }\ndbCreate( \"onlyname.dbf\", __FLedit( aStruct, aList ) )",
    "STATUS": "R",
    "COMPLIANCE": "CA-Cl*pper has internal undocumented function named __FLedit(),\nin Harbour we name it __dbStructFilter(). The new name gives a better\ndescription of what this function does. In Harbour __FLedit() simply\ncalls __dbStructFilter() and therefor the latter is the recommended\nfunction to use.\n\nThis function is only visible if src/rdd/dbstrux.prg was compiled\nwith the HB_CLP_UNDOC flag.",
    "PLATFORMS": "All",
    "FILES": "Header file is dbstruct.ch\nLibrary is rdd",
    "SEEALSO": "dbCreate(), dbStruct(), __dbCopyStruct(), __dbStructFilter()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dbstrux.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__dbStructFilter()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Filter a database structure array",
    "SYNTAX": "__dbStructFilter( <aStruct>, [<aFieldList>] ) --> aStructFiltered",
    "ARGUMENTS": "<aStruct> is a multidimensional array with database fields\nstructure, which is usually the output from dbStruct(), where each\narray element has the following structure:\n\n<table>\n Position   Description    dbstruct.ch\n\n 1          cFieldName     DBS_NAME\n 2          cFieldType     DBS_TYPE\n 3          nFieldLength   DBS_LEN\n 4          nDecimals      DBS_DEC\n</table>\n\n<aFieldList> is an array where each element is a field name.\nNames could be specified as uppercase or lowercase.",
    "RETURNS": "__dbStructFilter() return a new multidimensional array where each\nelement is in the same structure as the original <aStruct>, but the\narray is built according to the list of fields in <aFieldList>. If\n<aFieldList> is empty, __dbStructFilter() return reference to the\noriginal <aStruct> array.",
    "DESCRIPTION": "__dbStructFilter() can be use to create a sub-set of a database\nstructure, based on a given field list.\n\nNote that field names in <aStruct> _must_ be specified in uppercase\nor else no match would be found.\n\n`SET EXACT` has no effect on the return value.",
    "EXAMPLES": "// FIXME\nLOCAL aStruct, aList, aRet\naStruct := { ;\n   { \"CODE\",  \"N\",  4, 0 }, ;\n   { \"NAME\",  \"C\", 10, 0 }, ;\n   { \"PHONE\", \"C\", 13, 0 }, ;\n   { \"IQ\",    \"N\",  3, 0 } }\naList := { \"IQ\", \"NAME\" }\naRet := __dbStructFilter( aStruct, aList )\n                   // { { \"IQ\", \"N\", 3, 0 }, { \"NAME\", \"C\", 10, 0 } }\n\naRet := __dbStructFilter( aStruct, {} )\n? aRet == aStruct  // .T.\n\naList := { \"iq\", \"NOTEXIST\" }\naRet := __dbStructFilter( aStruct, aList )\n                   // { { \"IQ\", \"N\", 3, 0 } }\n\naList := { \"NOTEXIST\" }\naRet := __dbStructFilter( aStruct, aList )  // --> {}\n\n// Create a new file that contain part of the original structure\nLOCAL aStruct, aList, aRet\nUSE test\naStruct := dbStruct()\naList := { \"NAME\" }\ndbCreate( \"onlyname.dbf\", __dbStructFilter( aStruct, aList ) )",
    "STATUS": "R",
    "COMPLIANCE": "__dbStructFilter() is a Harbour extension. CA-Cl*pper has an internal\nundocumented function named __FLedit() that does exactly the same\nthing. The new name gives a better description of what this function does.",
    "PLATFORMS": "All",
    "FILES": "Header file is dbstruct.ch\nLibrary is rdd",
    "SEEALSO": "dbCreate(), dbStruct(), __dbCopyStruct(), __FLedit()*"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dir.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__Dir()*",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Display listings of files",
    "SYNTAX": "__Dir( [<cFileMask>] ) --> NIL",
    "ARGUMENTS": "<cFileMask> File mask to include in the function return. It could\ncontain path and standard wildcard characters as supported by your\nOS (like * and ?). If <cFileMask> contains no path, then SET DEFAULT\npath is used to display files in the mask.",
    "RETURNS": "__Dir() always returns NIL.",
    "DESCRIPTION": "If no <cFileMask> is given, __Dir() displays information about all\n*.dbf in the SET DEFAULT path. This information contains: file name,\nnumber of records, last update date and the size of each file.\n\nIf <cFileMask> is given, __Dir() list all files that match the mask\nwith the following details: Name, Extension, Size, Date.\n\nDIR command is preprocessed into __Dir() function during compile\ntime.\n\n__Dir() is a compatibility function, it is superseded by Directory()\nwhich return all the information in a multidimensional array.\n\nIf long file names are available Harbour will use/display the first\n15 characters else Harbour will use/display a 8.3 file name consistent\nwith CA-Cl*pper.",
    "EXAMPLES": "__Dir()      // information for all DBF files in current directory\n\n__Dir( \"*.dbf\" )         // list all DBF file in current directory\n\n// list all PRG files in Harbour Run-Time library\n// for MS-DOS compatible operating systems\n__Dir( hb_DirSepToOS( \"src/rtl/*.prg\" ) )\n\n// list all files in the public section on a Unix like machine\n__Dir( hb_DirSepToOS( \"/pub\" ) )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "ADir(), Directory(), SET DEFAULT, DIR"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dir.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Command",
    "NAME": "DIR",
    "CATEGORY": "Command",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Display listings of files",
    "SYNTAX": "DIR [<cFileMask>]",
    "ARGUMENTS": "<cFileMask> File mask to include in the function return. It could\ncontain path and standard wildcard characters as supported by your\nOS (like * and ?). If <cFileMask> contains no path, then SET DEFAULT\npath is used to display files in the mask.",
    "DESCRIPTION": "If no <cFileMask> is given, __Dir() display information about all\n*.dbf in the SET DEFAULT path, this information contain: file name,\nnumber of records, last update date and the size of each file.\n\nIf <cFileMask> is given, __Dir() list all files that match the mask\nwith the following details: Name, Extension, Size, Date.\n\nDIR command is preprocessed into __Dir() function during compile\ntime.\n\n__Dir() is a compatibility function, it is superseded by Directory()\nwhich returns all the information in a multidimensional array.\n\nIf long file names are available Harbour will use/display the first\n15 characters else Harbour will use/display a 8.3 file name consistent\nwith CA-Cl*pper.",
    "EXAMPLES": "DIR          // information for all DBF files in current directory\n\nDIR \"*.dbf\"          // list all DBF file in current directory\n\n// list all PRG files in Harbour Run-Time library\n// for MS-DOS compatible operating systems\nDIR \"src/rtl/*.prg\"\n\n// list all files in the public section on a Unix like machine\nDIR \"/pub\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "SEEALSO": "ADir(), Directory(), SET DEFAULT, __Dir()*"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dir.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "ADir()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Fill pre-defined arrays with file/directory information",
    "SYNTAX": "ADir( [<cFileMask>], [<aName>], [<aSize>], [<aDate>],\n      [<aTime>], [<aAttr>] ) --> nDirEntries",
    "ARGUMENTS": "<cFileMask> File mask to include in the function return. It could\ncontain path and standard wildcard characters as supported by your\nOS (like * and ?). If you omit <cFileMask> or if <cFileMask> contains\nno path, then the path from SET DEFAULT is used.\n\n<aName> Array to fill with file name of files that meet <cFileMask>.\nEach element is a Character string and include the file name and\nextension without the path. The name is the long file name as\nreported by the OS and not necessarily the 8.3 uppercase name.\n\n<aSize> Array to fill with file size of files that meet <cFileMask>.\nEach element is a Numeric integer for the file size in Bytes.\nDirectories are always zero in size.\n\n<aDate> Array to fill with file last modification date of files that\nmeet <cFileMask>. Each element is of type Date.\n\n<aTime> Array to fill with file last modification time of files that\nmeet <cFileMask>. Each element is a Character string in the format\nHH:mm:ss.\n\n<aAttr> Array to fill with attribute of files that meet <cFileMask>.\nEach element is a Character string, see Directory() for information\nabout attribute values. If you pass array to <aAttr>, the function\nis going to return files with normal, hidden, system and directory\nattributes. If <aAttr> is not specified or with type other than\nArray, only files with normal attribute would return.",
    "RETURNS": "ADir() return the number of file entries that meet <cFileMask>",
    "DESCRIPTION": "ADir() return the number of files and/or directories that match\na specified skeleton, it also fill a series of given arrays with\nthe name, size, date, time and attribute of those files. The passed\narrays should pre-initialized to the proper size, see example below.\nIn order to include hidden, system or directories <aAttr> must be\nspecified.\n\nADir() is a compatibility function, it is superseded by Directory()\nwhich returns all the information in a multidimensional array.",
    "EXAMPLES": "LOCAL aName, aSize, aDate, aTime, aAttr, tmp\nLOCAL nLen := ADir( \"*.dbf\" )  // Number of JPG files in this directory\nIF nLen > 0\n   aName := Array( nLen )  // make room to store the information\n   aSize := Array( nLen )\n   aDate := Array( nLen )\n   aTime := Array( nLen )\n   aAttr := Array( nLen )\n   ADir( \"*.prg\", aName, aSize, aDate, aTime, aAttr )\n   FOR tmp := 1 TO nLen\n      ? ;\n         aName[ tmp ], ;\n         aSize[ tmp ], ;\n         aDate[ tmp ], ;\n         aTime[ tmp ], ;\n         aAttr[ tmp ]\n   NEXT\nELSE\n   ? \"This directory is clean from smut\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "<aName> is going to be filled with long file name and not necessarily\nthe 8.3 uppercase name.",
    "FILES": "Library is core",
    "SEEALSO": "Array(), Directory(), SET DEFAULT"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dirdrive.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "DirRemove()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Attempt to remove an directory",
    "SYNTAX": "DirRemove( <cDirectory> ) --> nError",
    "ARGUMENTS": "<cDirectory>  The name of the directory you want to remove.",
    "RETURNS": "<nError> 0 if directory was successfully removed, otherwise\nthe number of the last error.",
    "DESCRIPTION": "This function attempt to remove the specified directory in <cDirectory>\nIf this function fails, it will return the last OS error code number.\nSee FError() function for the description of the error.",
    "EXAMPLES": "LOCAL cDir\nIF DirRemove( cDir := hb_DirSepToOS( \"./mydir\" ) ) == 0\n   ? \"Removing directory\", cDir, \"was successful\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C53",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "MakeDir(), DirChange(), IsDisk(), DiskChange(), DiskName(), FError()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dirdrive.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "DirChange()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Changes the directory",
    "SYNTAX": "DirChange( <cDirectory> ) --> nError",
    "ARGUMENTS": "<cDirectory>  The name of the directory you want do change into.",
    "RETURNS": "<nError> 0 if directory was successfully changed, otherwise\nthe number of the last error.",
    "DESCRIPTION": "This function attempt to change the current directory to the one\nspecified in <cDirectory>. If this function fails, it will return\nthe last OS error code number. See FError() function for the\ndescription of the error.",
    "EXAMPLES": "IF DirChange( hb_DirSepToOS( \"./mydir\" ) ) == 0\n   ? \"Change to directory was successful\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C53",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "MakeDir(), DirRemove(), IsDisk(), DiskChange(), DiskName(), FError()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dirdrive.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "MakeDir()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Create a new directory",
    "SYNTAX": "MakeDir( <cDirectory> ) --> nError",
    "ARGUMENTS": "<cDirectory>  The name of the directory you want to create.",
    "RETURNS": "<nError> 0 if directory was successfully created, otherwise\nthe number of the last error.",
    "DESCRIPTION": "This function attempt to create a new directory with the name contained\nin <cDirectory>. If this function fails, it will return the last OS\nerror code number. See FError() function for the description of the\nerror",
    "EXAMPLES": "LOCAL cDir\nIF MakeDir( cDir := hb_DirSepToOS( \"./mydir\" ) ) == 0\n   ? \"Directory\", cDir, \"successfully created\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C53",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "DirChange(), DirRemove(), IsDisk(), DiskChange(), DiskName(), FError()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/dirdrive.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "IsDisk()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Verify if a drive is ready",
    "SYNTAX": "IsDisk( <cDrive> ) --> lSuccess",
    "ARGUMENTS": "<cDrive>  An valid drive letter",
    "RETURNS": "<lSuccess>  .T. is the drive is ready, otherwise .F.",
    "DESCRIPTION": "This function attempts to access a drive. If the access to the drive\nwas successful, it will return true (.T.), otherwise false (.F.). This\nfunction is useful for backup function, so you can determine if the\ndrive that will receive the backup data is ready or not.",
    "EXAMPLES": "IF IsDisk( \"A\" )\n   ? \"Drive is ready\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C53",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "DirChange(), MakeDir(), DirRemove(), DiskChange(), DiskName()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/diskspac.txt",
    "AUTHOR": "Copyright 2000 Paul Tucker <ptucker@sympatico.ca>",
    "TEMPLATE": "Function",
    "NAME": "DiskSpace()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Get the amount of space available on a disk",
    "SYNTAX": "DiskSpace( [<nDrive>] ) --> nDiskBytes",
    "ARGUMENTS": "<nDrive> The number of the drive you are requesting info on where 1 = A,\n2 = B, etc. For 0 or no parameter, DiskSpace will operate on the current\ndrive.  The default is 0",
    "RETURNS": "<nDiskBytes> The number of bytes on the requested disk that match the\nrequested type.",
    "DESCRIPTION": "By default, this function will return the number of bytes of\nfree space on the current drive that is available to the user\nrequesting the information.\n\nIf information is requested on a disk that is not available, a runtime\nerror 2018 will be raised.",
    "EXAMPLES": "? \"You can use:\", hb_ntos( DiskSpace() ), \"bytes\"\n\n// See tests/diskspac.prg for another example",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core\nHeader is fileio.ch"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/diskspac.txt",
    "AUTHOR": "Copyright 2000 Paul Tucker <ptucker@sympatico.ca>",
    "TEMPLATE": "Function",
    "NAME": "hb_DiskSpace()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Get the amount of space available on a disk",
    "SYNTAX": "hb_DiskSpace( [<cDrive>] [, <nType>] ) --> nDiskBytes",
    "ARGUMENTS": "<cDrive> The drive letter you are requesting info on. The default\nis A:\n\n<nType> The type of space being requested. The default is HB_DISK_AVAIL.",
    "RETURNS": "<nDiskBytes> The number of bytes on the requested disk that match the\nrequested type.",
    "DESCRIPTION": "By default, this function will return the number of bytes of\nfree space on the current drive that is available to the user\nrequesting the information.\n\nThere are 4 types of information available:\n\n HB_DISK_AVAIL  The amount of space available to the user making the\n                request. This value could be less than HB_FS_FREE if\n                disk quotas are supported by the O/S in use at runtime,\n                and disk quotas are in effect. Otherwise, the value\n                will be equal to that returned for HB_FS_FREE.\n\n HB_DISK_FREE   The actual amount of free disk space on the drive.\n\n HB_DISK_USED   The number of bytes in use on the disk.\n\n HB_DISK_TOTAL  The total amount of space allocated for the user if\n                disk quotas are in effect, otherwise, the actual size\n                of the drive.\n\nIf information is requested on a disk that is not available, a runtime\nerror 2018 will be raised.",
    "EXAMPLES": "#include \"fileio.ch\"\n\n? \"You can use:\", hb_ntos( hb_DiskSpace() ), \"bytes\"\n? \"Out of a total of:\", hb_ntos( hb_DiskSpace( , HB_DISK_TOTAL ) )\n\n// See tests/diskspac.prg for another example",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is core\nHeader is fileio.ch"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/errsys.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "ErrorSys()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Error",
    "ONELINER": "Install default error handler",
    "SYNTAX": "ErrorSys() --> NIL",
    "ARGUMENTS": "None.",
    "RETURNS": "ErrorSys() always return NIL.",
    "DESCRIPTION": "ErrorSys() is called upon startup by Harbour and installs the default\nerror handler. Normally you should not call this function directly,\ninstead use ErrorBlock() to install your own error handler.",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "ErrorBlock(), Error class"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/evalhb.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Eval()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Execute and Execution",
    "ONELINER": "Evaluate a code block",
    "SYNTAX": "Eval( <bBlock> [, <xVal> [,...] ] ) --> xExpression",
    "ARGUMENTS": "<bBlock>   Code block expression to be evaluated\n\n<xVal>     Argument to be passed to the code block expression\n\n<xVal...>  Argument list to be passed to the code block expression",
    "RETURNS": "<xExpression>  The result of the evaluated code block",
    "DESCRIPTION": "This function evaluates the code bloc expressed as <bBlock> and\nreturns its evaluated value. If their are multiple expressions within\nthe code block, the last expression will be value of this function.\n\nIf the code block requires parameters to be passed to it, they are\nspecified in the parameter list <xVal> and following. Each parameter\nis separated by a comma within the expression list.",
    "EXAMPLES": "LOCAL bBlock := {|| NIL }\n? Eval( 1 )\n? Eval( @bBlock )\n\n? Eval( {| p1 | p1 }, \"A\", \"B\" )\n? Eval( {| p1, p2 | p1 + p2 }, \"A\", \"B\" )\n? Eval( {| p1, p2, p3 | p1 }, \"A\", \"B\" )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "AEval(), dbEval()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "FOpen()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Open a file.",
    "SYNTAX": "FOpen( <cFile>, [<nMode>] ) --> nHandle",
    "ARGUMENTS": "<cFile> Name of file to open.\n\n<nMode> File open mode.",
    "RETURNS": "<nHandle> A file handle.",
    "DESCRIPTION": "This function opens a file expressed as <cFile> and returns a\nfile handle to be used with other low-level file functions. The\nvalue of <nMode> represents the status of the file to be opened;\nthe default value is 0. The file open modes are as follows:\n\n<table>\n nMode          Meaning\n\n FO_READ        Read only\n FO_WRITE       Write only\n FO_READWRITE   Read/write\n FO_EXCLUSIVE   Exclusive read only\n FO_DENYWRITE   Prevent others from writing\n FO_DENYREAD    Deny read only\n FO_DENYNONE    Not deny, Let to others Read / Write\n FO_SHARED      same as FO_DENYNONE\n</table>\n\nIf there is an error in opening a file, a F_ERROR will be returned by\nthe function. Files handles may be in the range of 0 to 65535. The\nstatus of the `SET DEFAULT TO` and `SET PATH TO` commands has no effect\non this function. Directory names and paths must be specified along\nwith the file that is to be opened.\n\nIf an error has occurred, see the returns values from FError() for\npossible reasons for the error.",
    "EXAMPLES": "#include \"fileio.ch\"\nIF ( nH := FOpen( \"test.txt\", FO_READWRITE + FO_DENYNONE ) ) == F_ERROR\n   ? \"File cannot be opened\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core\nHeader is fileio.ch",
    "SEEALSO": "FCreate(), FError(), FClose()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "TEMPLATE": "Function",
    "NAME": "FCreate()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Creates a file.",
    "SYNTAX": "FCreate( <cFile>, [<nAttribute>] ) --> nHandle",
    "ARGUMENTS": "<cFile> is the name of the file to create.\n\n<nAttribute> Numeric code for the file attributes.",
    "RETURNS": "<nHandle>  Numeric file handle to be used in other operations.",
    "DESCRIPTION": "This function creates a new file with a file name of <cFile>. The\ndefault value of <nAttribute> is 0 and is used to set the\nattribute byte for the file being created by this function.\nThe return value will be a file handle that is associated\nwith the new file. This number will be between zero to 65535,\ninclusive. If an error occurs, the return value of this function\nwill be F_ERROR.\n\nIf the file <cFile> already exists, the existing file will be\ntruncated to a file length of 0 bytes.\n\nIf specified, the following table shows the value for <nAttribute>\nand their related meaning to the file <cFile> being created by\nthis function.\n\n<table>\n <nAttribute>  Meaning\n\n FC_NORMAL     Normal/Default, Read/Write\n FC_READONLY   Read-only file attribute is set\n FC_HIDDEN     Hidden, Excluded from normal DIR search\n FC_SYSTEM     Create, Excluded from normal DIR search\n</table>",
    "EXAMPLES": "#include \"fileio.ch\"\nIF ( nh := FCreate( \"test.txt\" ) ) == F_ERROR\n    ? \"Cannot create file\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core\nHeader is fileio.ch",
    "SEEALSO": "FClose(), FOpen(), FWrite(), FRead(), FError()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "FRead()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Reads a specified number of bytes from a file.",
    "SYNTAX": "FRead( <nHandle>, @<cBuffer>, <nBytes> ) --> nBytes",
    "ARGUMENTS": "<nHandle>     File handle\n\n<cBuffer>  Character expression passed by reference.\n\n<nBytes>      Number of bytes to read.",
    "RETURNS": "<nBytes> the number of bytes successfully read from the file.\n<nHandle>",
    "DESCRIPTION": "This function reads the characters from a file whose file handle\nis <nHandle> into a character memory variable expressed as <cBuffer>.\nThe function returns the number of bytes successfully read into\n<cBuffer>.\n\nThe value of <nHandle> is obtained from either a call to the FOpen()\nor the FCreate() function.\n\nThe <cBuffer> expression is passed by reference and must be defined\nbefore this function is called. It also must be at least the same\nlength as <nBytes>.\n\n<nBytes> is the number of bytes to read, starting at the current\nfile pointer position. If this function is successful in reading\nthe characters from the file, the length of <cBuffer> or the number\nof bytes specified in <nBytes> will be the value returned. The current\nfile pointer advances the number of bytes read with each successive\nread. The return value is the number of bytes successfully read\nfrom the file. If a 0 is returned, or if the number of\nbytes read matches neither the length of <cBuffer> nor the specified\nvalue in <nBytes> an end-of-file condition has been reached.",
    "EXAMPLES": "#include \"fileio.ch\"\ncBuffer := Space( 500 )\nIF ( nH := FOpen( \"test.txt\" ) ) == F_ERROR\n   FRead( nH, @cBuffer, 500 )\n   ? cbuffer\nENDIF\nFClose( nH )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Bin2I(), Bin2L(), Bin2W(), FError(), FWrite()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "FWrite()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Writes characters to a file.",
    "SYNTAX": "FWrite( <nHandle>, <cBuffer>, [<nBytes>] ) --> nBytesWritten",
    "ARGUMENTS": "<nHandle>  File handle number.\n\n<cBuffer>  Character expression to be written.\n\n<nBytes>   The number of bytes to write.",
    "RETURNS": "<nBytesWritten> the number of bytes successfully written.",
    "DESCRIPTION": "This function writes the contents of <cBuffer> to the file designated\nby its file handle <nHandle>. If used, <nBytes> is the number of\nbytes in <cBuffer> to write.\n\nThe returned value is the number of bytes successfully written to the\nfile. If the returned value is 0, an error has occurred (unless\nthis is intended). A successful write occurs when the number returned\nby FWrite() is equal to either `Len( cBuffer )` or <nBytes>.\n\nThe value of <cBuffer> is the string or variable to be written to the\nopen file <nHandle>.\n\nThe value of <nBytes> is the number of bytes to write out to the file.\nThe disk write begins with the current file position in <nHandle>. If\nthis variable is not used, the entire contents of <cBuffer> is written\nto the file.\nTo truncate a file, a call of `FWrite( nHandle, \"\", 0 )` is needed.",
    "EXAMPLES": "nHandle := FCreate( \"test.txt\" )\nFOR x := 1 TO 10\n   FWrite( nHandle, hb_ntos( x ) )\nNEXT\nFClose( nHandle )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "FClose(), FCreate(), FError(), FOpen(), I2Bin(), L2Bin()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "FError()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Reports the error status of low-level file functions",
    "SYNTAX": "FError() --> nErrorCode",
    "RETURNS": "<nErrorCode> Value of the OS error last encountered by a\nlow-level file function.\n\nFError() Return Values\n\n<table>\n Error          Meaning\n\n 0              Successful\n 2              File not found\n 3              Path not found\n 4              Too many files open\n 5              Access denied\n 6              Invalid handle\n 8              Insufficient memory\n 15             Invalid drive specified\n 19             Attempted to write to a write-protected disk\n 21             Drive not ready\n 23             Data CRC error\n 29             Write fault\n 30             Read fault\n 32             Sharing violation\n 33             Lock Violation\n</table>",
    "DESCRIPTION": "After every low-level file function, this function will return\na value that provides additional information on the status of\nthe last low-level file function's performance. If the FError()\nfunction returns a 0, no error was detected. Below is a table\nof possibles values returned by the FError() function.",
    "EXAMPLES": "IF ( nHandle := FCreate( \"test.txt\" ) ) == F_ERROR\n   ? \"Cannot create file, OS error\", FError()\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "FClose(), FErase(), FOpen(), FWrite()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "FClose()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Closes an open file",
    "SYNTAX": "FClose( <nHandle> ) --> lSuccess",
    "ARGUMENTS": "<nHandle> File handle",
    "RETURNS": "<lSuccess>  Logical TRUE (.T.) or FALSE (.F.)",
    "DESCRIPTION": "This function closes an open file with a file handle\nof <nHandle> and writes the associated buffers to the\ndisk. The <nHandle> value is derived from the FCreate()\nor FOpen() function.",
    "EXAMPLES": "#include \"fileio.ch\"\nnHandle := FOpen( \"test.txt\" )\n? FSeek( nHandle, 0, FS_END )\nFClose( nHandle )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "FOpen(), FCreate(), FRead(), FWrite(), FError()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "TEMPLATE": "Function",
    "NAME": "FErase()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Erase a file from disk",
    "SYNTAX": "FErase( <cFile> ) --> nSuccess",
    "ARGUMENTS": "<cFile> Name of file to erase.",
    "RETURNS": "<nSuccess> 0 if successful, -1 if not",
    "DESCRIPTION": "This function deletes the file specified in <cFile> from the disk.\nNo extensions are assumed. The drive and path my be included in\n<cFile>; neither the `SET DEFAULT` not the `SET PATH` command controls\nthe performance of this function. If the drive or path is not used,\nthe function will look for the file only on the currently selected\ndirectory on the logged drive.\n\nIf the function is able to successfully delete the file from the\ndisk, the value of the function will be 0; otherwise a -1 will\nbe returned. If not successful, additional information may be\nobtained by calling the FError() function.\n\nNote: Any file to be removed by FErase() must still be closed.\n",
    "EXAMPLES": "#include \"fileio.ch\"\nIF FErase( \"test.txt\" ) != F_ERROR\n   ? \"File successfully erased\"\nELSE\n   ? \"File cannot be deleted\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "FError(), FRename()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "FRename()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Renames a file",
    "SYNTAX": "FRename( <cOldFile>, <cNewFile> ) --> nSuccess",
    "ARGUMENTS": "<cOldFile> Old file name to be changed\n\n<cNewFile> New file name",
    "RETURNS": "<nSuccess> If successful, a 0 will be returned otherwise,\na -1 will be returned.",
    "DESCRIPTION": "This function renames the specified file <cOldFile> to <cNewFile>.\nA file name and/or directory name may be specified for either para-\nmeter. However, if a path is supplied as part of <cNewFile> and\nthis path is different from either the path specified in <cOldFile>\nor (if none is used) the current drive and directory, the function\nwill not execute successfully.\n\nNeither parameter is subject to the control of the `SET PATH TO` or\n`SET DEFAULT TO` commands. In attempting to locate the file to be\nrenamed, this function will search the default drive and directory\nor the drive and path specified in <cOldFile>. It will not search\ndirectories named by the `SET PATH TO` and `SET DEFAULT TO` commands\nor by the PATH environment variable.\n\nIf the file specified in <cNewFile> exists or the file is open,\nthe function will be unable to rename the file. If the function\nis unable to complete its operation, it will return a value of -1.\nIf it is able to rename the file, the return value for the function\nwill be 0. A call to FError() function will give additional\ninformation about any error found.",
    "EXAMPLES": "#include \"fileio.ch\"\nnResult := FRename( \"test.txt\", \"test1.txt\" )\nIF nResult != 0\n   ? \"File could not be renamed\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "ERASE, FErase(), FError(), File(), RENAME"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "FSeek()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Positions the file pointer in a file.",
    "SYNTAX": "FSeek( <nHandle>, <nOffset>, [<nOrigin>] ) --> nPosition",
    "ARGUMENTS": "<nHandle> File handle.\n\n<nOffset> The number of bytes to move.\n\n<nOrigin> The relative position in the file.",
    "RETURNS": "<nPosition> the current position relative to begin-of-file",
    "DESCRIPTION": "This function sets the file pointer in the file whose file\nhandle is <nHandle> and moves the file pointer by <expN2> bytes\nfrom the file position designated by <nOrigin>. The returned value\nis the relative position of the file pointer to the beginning-of-file\nmarker once the operation has been completed.\n\n<nHandle> is the file handle number. It is obtained from the FOpen()\nor FCreate() function.\n\nThe value of <nOffSet> is the number of bytes to move the file pointer\nfrom the position determined by <nOrigin>. The value of <nOffset> may\nbe a negative number, suggesting backward movement.\n\nThe value of <nOrigin> designates the starting point from which the\nfile pointer should he moved, as shown in the following table:\n\n<table>\n <nOrigin>     File position\n\n FS_SET        Beginning of file\n FS_RELATIVE   Current file pointer position\n FS_END        End of file\n</table>\n\nIf a value is not provided for <nOrigin>, it defaults to 0 and\nmoves the file pointer from the beginning of the file.",
    "EXAMPLES": "// here is a function that read one text line from an open file\n\n// nH = file handle obtained from FOpen()\n// cB = a string buffer passed-by-reference to hold the result\n// nMaxLine = maximum number of bytes to read\n\nSTATIC FUNCTION FReadLn( nH, cB, nMaxLine )\n   LOCAL cLine, nSavePos, nEol, nNumRead\n   cLine := Space( nMaxLine )\n   cB := \"\"\n   nSavePos := FSeek( nH, 0, FS_RELATIVE )\n   nNumRead := FRead( nH, @cLine, nMaxLine )\n   IF ( nEol := hb_BAt( hb_eol(), hb_BLeft( cLine, nNumRead ) ) ) == 0\n      cB := cLine\n   ELSE\n      cB := hb_BLeft( cLine, nEol - 1 )\n      FSeek( nH, nSavePos + nEol + 1, FS_SET )\n   ENDIF\n   RETURN nNumRead != 0",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core\nHeader is fileio.ch",
    "SEEALSO": "FCreate(), FError(), FOpen(), FRead(), FReadStr(), FWrite()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "File()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Tests for the existence of file(s)",
    "SYNTAX": "File( <cFileSpec> ) --> lExists",
    "ARGUMENTS": "<cFileSpec> File name skeleton or file name to find.",
    "RETURNS": "<lExists> a logical true (.T.) if the file exists or logical\nfalse (.F.).",
    "DESCRIPTION": "This function return a logical true (.T.) if the given file name\n<cFileSpec> exist.\n\nFile name skeletons symbols may be used in the file name in <cFileSpec>,\nas may the drive and/or path name. If a path is not explicitly\nspecified, File() will look for the file in the `SET DEFAULT` path,\nthen in each `SET PATH path`, until the file is found or there are\nno more paths to search. The PATH environment variable is never\nsearched and the current drive/directory is only searched if\n`SET DEFAULT` is blank.",
    "EXAMPLES": "? File( hb_DirSepToOS( \"/hb/doc/pp.txt\" ) )\n? File( \"*.txt\" )",
    "STATUS": "S (wild card support is missing)",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "SET DEFAULT, SET PATH, Set()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "FReadStr()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Reads a string from a file.",
    "SYNTAX": "FReadStr( <nHandle>, <nBytes> ) --> cString",
    "ARGUMENTS": "<nHandle> File handle number.\n\n<nBytes>  Number of bytes to read.",
    "RETURNS": "<cString> an character expression",
    "DESCRIPTION": "This function returns a character string of <nBytes> bytes from a\nfile whose file handle is <nHandle>.\n\nThe value of the file handle <nHandle> is obtained from either the\nFOpen() or FCreate() functions.\n\nThe value of <nBytes> is the number of bytes to read from the file.\nThe returned string will be the number of characters specified in\n<nBytes> or the number of bytes read before a zero byte is found.",
    "EXAMPLES": "#include \"fileio.ch\"\nLOCAL cStr\nIF ( nH := FOpen( \"test.txt\" ) ) != F_ERROR\n   cStr := FReadStr( nH, 100 )\n   ? cStr\n   FClose( nH )\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Bin2I(), Bin2L(), Bin2W(), FError(), FRead(), FSeek()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "RENAME",
    "CATEGORY": "Command",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Changes the name of a specified file",
    "SYNTAX": "RENAME <cOldFile> TO <cNewFile>",
    "ARGUMENTS": "<cOldFile> Old file name\n\n<cNewFile> New File name",
    "DESCRIPTION": "This command changes the name of <cOldFile> to <cNewFile>. Both\n<cOldFile> and <cNewFile> must include a file extension. This command\nif not affected by the `SET PATH TO` or `SET DEFAULT TO` commands; drive\nand directory designates must be specified if either file is in a\ndirectory other then the default drive and directory.\n\nIf <cNewFile> id currently open or if it previously exists, this\ncommand will not perform the desired operation.",
    "EXAMPLES": "RENAME test.txt TO test.old",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "CurDir(), ERASE, File(), FErase(), FRename()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "ERASE",
    "CATEGORY": "Command",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Remove a file from disk",
    "SYNTAX": "ERASE <xcFile>",
    "ARGUMENTS": "<xcFile> Name of file to remove",
    "DESCRIPTION": "This command removes a file from the disk. The use of a drive, directory,\nand wild-card skeleton operator is allowed for the root of the\nfile name. The file extension is required. The `SET DEFAULT` and `SET PATH`\ncommands do not affect this command.\n\nThe file must be considered closed by the operating system before it\nmay be deleted.",
    "EXAMPLES": "ERASE test.txt",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "CurDir(), File(), FErase(), DELETE FILE"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "TEMPLATE": "Command",
    "NAME": "DELETE FILE",
    "CATEGORY": "Command",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Remove a file from disk",
    "SYNTAX": "DELETE FILE <xcFile>",
    "ARGUMENTS": "<xcFile> Name of file to remove",
    "DESCRIPTION": "This command removes a file from the disk. The use of a drive, directory,\nand wild-card skeleton operator is allowed for the root of the\nfile name. The file extension is required. The `SET DEFAULT` and `SET PATH`\ncommands do not affect this command.\n\nThe file must be considered closed by the operating system before it\nmay be deleted.",
    "EXAMPLES": "DELETE FILE test.txt",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "CurDir(), File(), FErase(), ERASE"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "CurDir()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Returns the current OS directory name.",
    "SYNTAX": "CurDir( [<cDrive>] ) --> cPath",
    "ARGUMENTS": "<cDrive> OS drive letter",
    "RETURNS": "<cPath> Name of directory",
    "DESCRIPTION": "This function yields the name of the current OS directory on a\nspecified drive. If <cDrive> is not specified, the currently logged\ndrive will be used.\n\nThis function should not return the leading and trailing\n(back)slashes.\n\nIf an error has been detected by the function, or the current OS\ndirectory is the root, the value of the function will be a NULL\nbyte.",
    "EXAMPLES": "? CurDir()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "File()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "TEMPLATE": "Command",
    "NAME": "COPY FILE",
    "CATEGORY": "Command",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Copies a file.",
    "SYNTAX": "COPY FILE <cFile> TO <cFile1>",
    "ARGUMENTS": "<cFile>   File name of source file\n<cFile1>  File name of target file",
    "DESCRIPTION": "This command makes an exact copy of <cFile> and names it <cFile1>.\nBoth files must have the file extension included; the drive and the\ndirectory names must also be specified if they are different from\nthe default drive and/or director. <cFile1> also can refer to a OS\ndevice (e.g. `LPT1`). This command does not observe the `SET PATH TO` or\n`SET DEFAULT TO` settings.",
    "EXAMPLES": "COPY FILE test.dbf TO adir.prg\nCOPY FILE test.txt TO LPT1",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "ERASE, RENAME, FRename(), FErase()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/file.txt",
    "AUTHOR": "Copyright 2000 David G. Holm <Harbour@SpaceMoose.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_FEof()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Check for end-of-file.",
    "SYNTAX": "hb_FEof( <nHandle> ) --> lIsEof",
    "ARGUMENTS": "<nHandle> The handle of an open file.",
    "RETURNS": "<lIsEof> .T. if the file handle is at end-of-file, otherwise .F.",
    "DESCRIPTION": "This function checks an open file handle to see if it is at EOF.\n\nIf the file handle is missing, not numeric, or not open, then this\nfunction returns .T. and sets the value returned by FError() to -1\n(F_ERROR) or a C-compiler dependent errno value (EBADF or EINVAL).",
    "EXAMPLES": "LOCAL nH := FOpen( \"test.txt\" )\n? FReadStr( nH, 80 )\nIF hb_FEof( nH )\n   ? \"End-of-file reached\"\nELSE\n   ? FReadStr( nH, 80 )\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "FError()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/garbage.txt",
    "TEMPLATE": "Document",
    "NAME": "The Garbage Collector",
    "CATEGORY": "Document",
    "ONELINER": "Readme for Harbour Garbage Collect Feature",
    "DESCRIPTION": "The garbage collector uses the following logic:\n- first collect all memory allocations that can cause garbage;\n- next scan all variables if these memory blocks are still referenced.\n\nNotice that only arrays, objects and codeblocks are collected because\nthese are the only datatypes that can cause self-references `a[ 1 ] := a`\nor circular references `a[ 1 ] := b; b[ 1 ] := c; c[ 1 ] := a` that\ncannot be properly deallocated by simple reference counting.\n\nSince all variables in Harbour are stored inside some available tables\n(the eval stack, memvars table and array of static variables) then checking\nif the reference is still alive is quite easy and doesn't require any\nspecial treatment during memory allocation. Additionally the garbage\ncollector is scanning some internal data used by Harbour objects\nimplementation that also stores some values that can contain memory\nreferences. These data are used to initialize class instance variables\nand are stored in class shared variables.\n\nIn special cases when the value of a Harbour variable is stored internally\nin some static area (at C or assembler level), the garbage collector will\nbe not able to scan such values since it doesn't know their location. This\ncould cause some memory blocks to be released prematurely. To prevent the\npremature deallocation of such memory blocks the static data have to store\na pointer to the value created with hb_itemNew() function.\nExample:\n  ```c\n  static HB_ITEM s_item; /* this item can be released by the GC */\n\n  static PHB_ITEM pItem; /* this item will be maintained correctly */\n  pItem = hb_itemNew( hb_param( 1, IT_BLOCK ) );\n  ```\n\nHowever, scanning of all variables can be a time consuming operation. It\nrequires that all allocated arrays have to be traversed through all their\nelements to find more arrays. Also all codeblocks are scanned for detached\nlocal variables they are referencing. For this reason, looking for unreferenced\nmemory blocks is performed during the idle states.\n\nThe idle state is a state when there is no real application code\nexecuted. For example, the user code is stopped for 0.1 of a second\nduring `Inkey( 0.1 )` - Harbour is checking the keyboard only\nduring this time. It leaves however quite enough time for\nmany other background tasks. One such background task can be looking\nfor unreferenced memory blocks.\n\nAllocating memory\n-----------------\n\nThe garbage collector collects memory blocks allocated with hb_gcAlloc()\nfunction calls. Memory allocated by hb_gcAlloc() should be released with\nhb_gcFree() function.\n\nThe garbage collecting\n----------------------\n\nDuring scanning of unreferenced memory the GC is using a mark & sweep\nalgorithm. This is done in three steps:\n\n1) mark all memory blocks allocated by the GC with unused flag;\n\n2) sweep (scan) all known places and clear unused flag for memory\nblocks that are referenced there;\n\n3) finalize collecting by deallocation of all memory blocks that are\nstill marked as unused and that are not locked.\n\nTo speed things up, the mark step is simplified by swapping the meaning\nof the unused flag. After deallocation of unused blocks all still alive\nmemory blocks are marked with the same 'used' flag so we can reverse\nthe meaning of this flag to 'unused' state in the next collecting.\nAll new or unlocked memory blocks are automatically marked as 'unused'\nusing the current flag, which assures that all memory blocks are marked\nwith the same flag before the sweep step will start.\nSee hb_gcCollectAll() and hb_gcItemRef()\n\nCalling the garbage collector from Harbour code\n-----------------------------------------------\n\nThe garbage collector can be called directly from the Harbour code.\nThis is useful in situations where there is no idle states available\nor the application is working in the loop with no user interaction\nand there is many memory allocations.\nSee hb_gcAll() for explanation of how to call this function from your\nHarbour code.",
    "SEEALSO": "hb_gcAlloc(), hb_gcFree(), hb_gcCollectAll(), hb_gcItemRef(), hb_gcAll(), hb_idleState()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/garbage.txt",
    "TEMPLATE": "Function",
    "NAME": "hb_gcAlloc()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Garbage Collector",
    "ONELINER": "Allocates memory that will be collected by the garbage collector.",
    "SYNTAX": "#include \"hbapi.h\"\nvoid * hb_gcAlloc( HB_SIZE nSize,\n                   PHB_GARBAGE_FUNC pCleanupFunc );",
    "ARGUMENTS": "<ulSize> Requested size of memory block\n\n<pCleanupFunc> Pointer to HB_GARBAGE_FUNC function that will be called\ndirectly before releasing the garbage memory block or NULL. This\nfunction should release all other memory allocated and stored inside\nthe memory block. For example, it releases all items stored inside\nthe array. The functions receives a single parameter: the pointer\nto memory allocated by hb_gcAlloc().",
    "RETURNS": "The pointer to allocated memory or it generates an internal\nunrecoverable error.",
    "DESCRIPTION": "hb_gcAlloc() is used to allocate the memory that will be tracked\nby the garbage collector. It allows to properly release memory\nin case of self-referencing or cross-referencing Harbour level\nvariables.\nMemory allocated with this function should be released with\nhb_gcFree() function or it will be automatically deallocated\nby the GC if it is not locked or if it is not referenced by some\nHarbour level variable.",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "SEEALSO": "hb_gcFree()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/garbage.txt",
    "TEMPLATE": "Function",
    "NAME": "hb_gcFree()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Garbage Collector",
    "ONELINER": "Releases the memory that was allocated with hb_gcAlloc().",
    "SYNTAX": "void hb_gcFree( void * pMemoryPtr );",
    "ARGUMENTS": "<pMemoryPtr> The pointer to memory for release. This memory\n  pointer have to be allocated with hb_gcAlloc() function.",
    "RETURNS": "Nothing.",
    "DESCRIPTION": "hb_gcFree() is used to deallocate the memory that was\nallocated with the hb_gcAlloc() function.",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "SEEALSO": "hb_gcAlloc()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/garbage.txt",
    "TEMPLATE": "Function",
    "NAME": "hb_gcCollectAll()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Garbage Collector",
    "ONELINER": "Scans all memory blocks and releases the garbage memory.",
    "SYNTAX": "void hb_gcCollectAll( void );",
    "ARGUMENTS": "None.",
    "RETURNS": "Nothing.",
    "DESCRIPTION": "This function scans the eval stack, the memvars table, the array\nof static variables and table of created classes for referenced\nmemory blocks. After scanning all unused memory blocks and blocks\nthat are not locked are released.",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "SEEALSO": "hb_gcAlloc(), hb_gcFree()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/garbage.txt",
    "TEMPLATE": "Function",
    "NAME": "hb_gcItemRef()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Garbage Collector",
    "ONELINER": "Marks the memory to prevent deallocation by the garbage collector.",
    "SYNTAX": "void hb_gcItemRef( PHB_ITEM pItem );",
    "ARGUMENTS": "<pItem>  The pointer to item structure that will be scanned. The\npassed item can be of any datatype although arrays, objects\nand codeblocks are scanned only. Other datatypes don't require\nlocking so they are simply ignored.",
    "RETURNS": "Nothing.",
    "DESCRIPTION": "The garbage collector uses hb_gcItemRef() function during\nscanning of referenced memory pointers. This function checks the\ntype of passed item and scans recursively all other memory blocks\nreferenced by this item if it is an array, an object or a codeblock.\n\nNOTE: This function is reserved for the garbage collector only. It\n      cannot be called from the user code - calling it can cause\n      unpredicted results (memory blocks referenced by the\n      passed item can be released prematurely during the closest\n      garbage collection).",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "SEEALSO": "hb_gcAlloc(), hb_gcFree()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/garbage.txt",
    "TEMPLATE": "Procedure",
    "NAME": "hb_gcAll()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Garbage Collector",
    "ONELINER": "Scans the memory and releases all garbage memory blocks.",
    "SYNTAX": "hb_gcAll()",
    "ARGUMENTS": "None",
    "DESCRIPTION": "This function releases all memory blocks that are considered\nas the garbage.",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "SEEALSO": "hb_gcCollectAll()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/gx.txt",
    "AUTHOR": "Copyright 2000 Alejandro de Garate <alex_degarate@hotmail.com>",
    "TEMPLATE": "Function",
    "NAME": "SetMode()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Change the video mode to a specified number of rows and columns",
    "SYNTAX": "SetMode( <nRows>, <nCols> ) --> lSuccess",
    "ARGUMENTS": "<nRows> is the number of rows for the video mode to set.\n\n<nCols> is the number of columns for the video mode to set.",
    "RETURNS": "SetMode() returns true if the video mode change was successful;\notherwise, it returns false.",
    "DESCRIPTION": "SetMode() is a function that change the video mode depend on the\nvideo card and monitor combination, to match the number of rows and\ncolumns specified.\nNote that there are only a real few combination or rows/cols pairs\nthat produce the video mode change.\nThe followings are available for GTDOS:\n\n<table-noheader>\n   12 rows x 40 columns   12 rows x 80 columns\n   25 rows x 40 columns   25 rows x 80 columns\n   28 rows x 40 columns   28 rows x 80 columns\n   50 rows x 40 columns   43 rows x 80 columns\n                          50 rows x 80 columns\n</table>\n\nThe follow modes are available to Windows\n\n<table-noheader>\n   25 rows x 40 columns   25 rows x 80 columns\n   50 rows x 40 columns   43 rows x 80 columns\n   50 rows x 80 columns\n</table>\n\nSome modes only are available for color and/or VGA monitors.\nAny change produced on the screen size is updated in the values\nreturned by MaxRow() and MaxCol().",
    "EXAMPLES": "// The first example change to a 12 lines of display mode:\nIF SetMode( 12, 40 )\n   ? \"Hey man are you blind?\"\nELSE\n   ? \"Mom, bring me my glasses!\"\nENDIF\n\n// Next example change to a 50 lines mode:\nIF SetMode( 50, 80 )\n   ? \"This wonderful mode was successfully set\"\nELSE\n   ? \"Wait. this monitor is not made of rubber!\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "Some of these modes are not available in CA-Cl*pper",
    "PLATFORMS": "All",
    "SEEALSO": "MaxCol(), MaxRow()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/harbext.txt",
    "TEMPLATE": "Document",
    "NAME": "Harbour Extensions",
    "CATEGORY": "Document",
    "DESCRIPTION": "<b>Language extensions:</b>\n--------------------\n\n* Class generation and management.\n\n        CA-Cl*pper only allowed creation of objects from a few standard\n        classes.\n\n        In Harbour, you can create your own classes--complete with\n        Methods, Instance Variables, Class Variables and Inheritance.\n        Entire applications can be designed and coded in Object Oriented\n        style.\n\n* `@<FunctionName>()`\n\n        Returns the pointer (address) to a function.\n\n        The returned value is not useful to application-level programming, but\n        is used at a low-level to implement object oriented coding.\n        (Internally, a class method is a static function and there is no\n        symbol for it, so it is accessed via its address).\n\n* Class HBGetList()\n\n        Object oriented support for GetLists management.\n\n* ProcName() support for class Method names.\n\n        Class Methods can be retrieved from the call stack.\n\n* Memory() has new return values.\n\n        See hbmemory.ch\n\n* Transform() --> new function in format string\n\n        @0      Make a zero padded string out of the number.\n\n* SToD() --> dDate\n\n        New function that converts a `yyyymmdd` string to a Date value.\n\n* Optional Compile Time *strong type* declaration (and compile time\n  *type mismatch* warnings)\n\n  Example: LOCAL/STATIC Var `AS` ...\n\n* The Harbour debugger provides new interesting classes:\n\n  - Class HBDbWindow() could be the foundation for a generic multi-platform\n\n  - Class HBDbInput()\n\n  - Class HBDbMenu() implement both pull-down and popup menus.\n\n<b>RTL enhanced functionality:</b>\n---------------------------\n\n- `hb_vfDirSpace( <nDir>, <nType> )`\n\n  The second parameter is a Harbour (optional) parameter and indicates the\n  type of disk info being requested. See doc/en/diskspac.txt for info.\n"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_Hash()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Returns a hash table",
    "SYNTAX": "hb_Hash( [ <Key1>, <Value1> ], [ <KeyN>, <ValueN> ], ... ) -> hTable",
    "ARGUMENTS": "<Key1> entry key;\ncan be of type: number, date, datetime, string, pointer\n\n<Value1> entry value; can be of type: block, string, numeric, date/datetime, logical, nil, pointer, array, hash table\n\nEquivalent to:\n```\nhTable := { => }\nhTable := { <Key1> => <Value1>, <Key2> => <Value2>, <KeyN> => <ValueN> }\n```",
    "RETURNS": "A hash table built from the initial key/value pairs",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HHasKey()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Determines whether a hash table has an entry with a give key",
    "SYNTAX": "hb_HHasKey( <hTable>, <Key> ) -> lExists",
    "ARGUMENTS": "<hTable> a hash table\n\n<Key> a key value to be queried for;\ncan be of type: number, date, datetime, string, pointer",
    "RETURNS": "A logical value indicating whether the key exists within the hash table",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HPos()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Locates the index of a key within a hash table",
    "SYNTAX": "hb_HPos( <hTable>, <Key> ) -> nPosition",
    "ARGUMENTS": "<hTable> a hash table\n\n<Key> key for which its position is to be determined;\ncan be of type: number, date, datetime, string, pointer",
    "RETURNS": "A integer number being the index position of the key within the hash table.\n\nTODO: what is the return value if the key does not exist?  zero (0)?  RTE?",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HGet()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Returns a hash value",
    "SYNTAX": "hb_HGet( <hTable>, <Key> ) -> <Value>",
    "ARGUMENTS": "<hTable> a hash table\n\n<Key> key to be retrieve from the hash table;\ncan be of type: number, date, datetime, string, pointer",
    "RETURNS": "Either the value within the hash table for the given key.\n\nAn array access error occurs of the key is not found",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HGetDef()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Returns a hash value, or a default value if the key is not present",
    "SYNTAX": "hb_HGetDef( <hTable>, <Key>, [<DefaultValue>] ) -> <Value>",
    "ARGUMENTS": "<hTable> a hash table\n\n<Key> key to be retrieve from the hash table;\ncan be of type: number, date, datetime, string, pointer\n\n<DefaultValue> a default value to be returned if the\nhash table does not contain the key",
    "RETURNS": "Either the value within the hash table for the given key,\nor the default value.",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HSet()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Sets a hash value",
    "SYNTAX": "hb_HSet( <hTable>, <Key>, <Value> ) -> <hTable>",
    "ARGUMENTS": "<hTable> a hash table\n\n<Key> the key of the entry to be set;\ncan be of type: number, date, datetime, string, pointer\n\n<Value> the entry value",
    "RETURNS": "The hash table",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HDel()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Removes a key/value pair from a hash table",
    "SYNTAX": "hb_HDel( <hTable>, <Key> ) -> <hTable>",
    "ARGUMENTS": "<hTable> a hash table\n\n<Key> key to be removed from the hash table;\ncan be of type: number, date, datetime, string, pointer",
    "RETURNS": "The hash table",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HKeyAt()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Gets a hash table key at a given position",
    "SYNTAX": "hb_HKeyAt( <hTable>, <nPosition> ) -> <Key>",
    "ARGUMENTS": "<hTable> a hash table\n\n<nPosition> the position of an entry within the hash table that will\nbe returned",
    "RETURNS": "The key at the given position of the hash table;\nthe type will be one: number, date, datetime, string, pointer",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HValueAt()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Gets/sets a hash value at a given position",
    "SYNTAX": "hb_HValueAt( <hTable>, <nPosition>, [<NewValue>] ) -> <Value>",
    "ARGUMENTS": "<hTable> a hash table\n\n<nPosition> the position of an entry within the hash table that will\nbe returned\n\n<NewValue> a new value to be assigned to the hash table at the given\nposition",
    "RETURNS": "The existing value, or the new value if it is given",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HPairAt()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Returns a two-dimensional array of a hash table entry key/value pair",
    "SYNTAX": "hb_HPairAt( <hTable>, <nPosition> ) -> <aKeyValue>",
    "ARGUMENTS": "<hTable> a hash table\n\n<nPosition> the position of an entry within the hash table that will\nbe returned",
    "RETURNS": "A two-dimensional array of the key/value pair entry of the hash table",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HDelAt()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Removes an entry from a hash table based on its index position",
    "SYNTAX": "hb_HDelAt( <hTable>, <nPosition> ) -> <hTable>",
    "ARGUMENTS": "<hTable> a hash table\n\n<nPosition> the position of an entry within the hash table that will\nbe deleted",
    "RETURNS": "The hash table",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HKeys()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Returns an array of the keys of a hash table",
    "SYNTAX": "hb_HKeys( <hTable> ) -> <aKeys>",
    "ARGUMENTS": "<hTable> a hash table",
    "RETURNS": "An array of all the hash table keys",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HValues()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Returns an array of the values of a hash table",
    "SYNTAX": "hb_HValues( <hTable> ) -> <aValues>",
    "ARGUMENTS": "<hTable> a hash table",
    "RETURNS": "An array of all the hash values",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HFill()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Fills a hash table with a value",
    "SYNTAX": "hb_HFill( <hTable>, <Value> ) -> <hTable>",
    "ARGUMENTS": "<hTable> a hash table\n\n<Value> fill value; can be of type: block, string, numeric, date/datetime, logical, nil, pointer, array, hash table",
    "RETURNS": "The hash table",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HClone()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Creates a copy of a hash table",
    "SYNTAX": "hb_HClone( <hTable> ) -> <hsDestination>",
    "ARGUMENTS": "<hTable> a hash table",
    "RETURNS": "A cloned copy of the hash table",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HCopy()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Adds entries from the source hash table to the destination hash table",
    "SYNTAX": "hb_HCopy( <hsDestination>, <hsSource>, [<nStart>], [<nCount>] ) -> <hsDestination>",
    "ARGUMENTS": "<hsDestination> a destination hash table\n\n<hsSource> a source hash table\n\n<nStart> starting index, defaults to 1 if omitted\n\n<nCount> counter, defaults to (length) - <nStart> is omitted",
    "RETURNS": "The destination hash table",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HMerge()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Merges a source hash table into a destination hash table",
    "SYNTAX": "hb_HMerge( <hsDestination>, <hsSource>, <bBlock>|<nPosition> ) -> <hsDestination>",
    "ARGUMENTS": "<hsDestination> a destination hash table\n\n<hsSource> a source hash table\n\n<bBlock> a code block that will be evaluated for each entry within the\nsource hash table; the code block will be passed the entry key, value and\nposition; if the code block returns a true value, the entry will be added to\nthe destination hash table\n\n<nPosition> the position of an entry within the source hash table that will\nbe appended to the destination hash table\n\nTODO: the source code passes either a number or HB_HASH_UNION; research this",
    "RETURNS": "The destination hash table with the contents of the source hash table merged",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HEval()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Evaluate a code block across the contents of a hash table",
    "SYNTAX": "hb_HEval( <hTable>, <bBlock>, [<nStart>], [<nCount>] ) -> <hTable>",
    "ARGUMENTS": "<hTable> a hash table\n\n<bBlock> code block to be evaluated\n\n<nStart> starting index, defaults to 1 if omitted\n\n<nCount> counter, defaults to (length) - <nStart> is omitted",
    "RETURNS": "The hash table",
    "DESCRIPTION": "The code block is evaluated for every hash table entry starting at\n<nStart> for <nCount> items.\n\nThe code block is passed the entry key, value, and numeric position",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HScan()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Scans a hash table",
    "SYNTAX": "hb_HScan( <hTable>, <Value>, [<nStart>], [<nCount>, [<lExact>] ) -> nPosition",
    "ARGUMENTS": "<hTable> a hash table\n\n<Value> to be located within the hash table\n\n<nStart> starting index, defaults to 1 if omitted\n\n<nCount> counter, defaults to (length) - <nStart> is omitted\n\n<lExact> logical value indicating whether the comparison\nis to be be exact or not",
    "RETURNS": "The position of the located value within the hash table, or zero (0) if not found.",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HSort()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Reorganizes the internal list of the hash table to be sorted",
    "SYNTAX": "hb_HSort( <hTable> ) -> <hsSortedTable>",
    "ARGUMENTS": "<hTable> a hash table",
    "RETURNS": "The hash table sorted\n\nTODO: is the original table altered?",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HCaseMatch()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Sets the 'case match' flag for the hash table",
    "SYNTAX": "hb_HCaseMatch( <hTable>, [<lFlag>] ) -> <lPreviousFlag>",
    "ARGUMENTS": "<hTable> a hash table\n\n<lFlag> a logical value indicating to turn on or off\nthe 'case match' flag of the hash table",
    "RETURNS": "The previous value of the 'case match' flag",
    "DESCRIPTION": "This function returns the old flag value",
    "EXAMPLES": "LOCAL hsTable, lFlag\nhsTable := { \"one\" => 1, \"two\" => 2 }\n// turn 'case match' on for a new hash table, storing old flag\nlFlag := hb_HCaseMatch( hsTable, .T. )",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HBinary()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Sets the 'binary' flag for the hash table",
    "SYNTAX": "hb_HBinary( <hTable>, [<lFlag>] ) -> <lPreviousFlag>",
    "ARGUMENTS": "<hTable> a hash table\n\n<lFlag> a logical value indicating to turn on or off\nthe 'binary' flag of the hash table",
    "RETURNS": "The previous value of the 'binary' flag",
    "DESCRIPTION": "This function is equivalent to hb_HBinary() but it returns\nthe old flag value rather than the hash table",
    "EXAMPLES": "LOCAL hsTable, lFlag\nhsTable := { \"one\" => 1, \"two\" => 2 }\n// turn 'binary' on for a new hash table, storing old flag\nlFlag := hb_HBinary( hsTable, .T. )",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HAutoAdd()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Sets the 'auto add' flag for the hash table",
    "SYNTAX": "hb_HAutoAdd( <hTable>, [<lFlag>] ) -> <lPreviousFlag>",
    "ARGUMENTS": "<hTable> a hash table\n\n<lFlag> a logical value indicating to turn on or off\nthe 'auto add' flag of the hash table",
    "RETURNS": "The previous value of the 'auto add' flag",
    "DESCRIPTION": "This function is equivalent to hb_HAutoAdd() but it returns\nthe old flag value rather than the hash table",
    "EXAMPLES": "LOCAL hsTable, lFlag\nhsTable := { \"one\" => 1, \"two\" => 2 }\n// turn 'auto add' on for a new hash table, storing old flag\nlFlag := hb_HAutoAdd( hsTable, .T. )",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Procedure",
    "NAME": "hb_HAllocate()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Preallocates a hash table",
    "SYNTAX": "hb_HAllocate( <hTable>, <nItems> )",
    "ARGUMENTS": "<hTable> a hash table\n\n<nItems> number of items to preallocate in the hash table",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hashfunc.txt",
    "AUTHOR": "Copyright 2009 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_HDefault()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Hash table",
    "ONELINER": "Returns/sets a default value for a hash table.",
    "SYNTAX": "hb_HDefault( <hTable>, <DefaultValue> ) -> <OldDefaultValue>",
    "ARGUMENTS": "<hTable> a hash table\n\n<DefaultValue>",
    "RETURNS": "The previous default value assigned to the hash table",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbflock.txt",
    "TEMPLATE": "Function",
    "NAME": "hb_FLock()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Locks part or all of any file",
    "SYNTAX": "hb_FLock( <nHandle>, <nOffset>, <nBytes> [, <nType ] )\n          --> lSuccess",
    "ARGUMENTS": "<nHandle>  OS file handle\n\nset>  Offset of the first byte of the region to be locked.\n\n<nBytes>   Number of bytes to be locked.\n\ne>    The type (read or write) of lock requested.",
    "RETURNS": "<lSuccess> .T. if the lock was obtained, else .F.",
    "DESCRIPTION": "This function attempts to lock a region of the file whose file handle\nis <nHandle>. This is a low-level file function.  To lock Harbour\ndata files use either the FLock() or RLock() function.\n\nThe value of <nHandle> is obtained from either a call to the FOpen()\nor the FCreate() function.\n\n<nOffset> is the offset (from the beginning of the file) to the first\nof the region to be locked.  (Offsets from the current position\nnd of file are not currently supported.)\n\n<nBytes> is the length of the region to be locked in bytes.\n\n<nType> is the type of lock requested.  There are two types of locks:\nexclusive write locks ( <nType> = 0x0000 ) - the default, and shared\nread locks ( <nType> = 0x0100 ).  Additionally you can specify a\nblocking version of this function (that is it won't return until\neither an error has occurred or the lock has been obtained) by\nadding 0x0200 to the above values.",
    "EXAMPLES": "// refer to tests/tflock.prg",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "hb_FUnlock(), FOpen(), FCreate(), FError(), FClose()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbflock.txt",
    "TEMPLATE": "Function",
    "NAME": "hb_FUnlock()",
    "CATEGORY": "API",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Unlocks part or all of any file",
    "SYNTAX": "hb_FUnlock( <nHandle>, <nOffset>, <nBytes> ) --> lSuccess",
    "ARGUMENTS": "<nHandle>  OS file handle\n\nset>  Offset of the first byte of the region to be locked.\n\n<nBytes>   Number of bytes to be locked.",
    "RETURNS": "<lSuccess> .T. if the lock was removed, else .F.",
    "DESCRIPTION": "This function attempts to unlock a region of the file whose file\nhandle is <nHandle>. This is a low-level file function.  To\nunlock Harbour data files use the dbUnlock() function.\n\nThe value of <nHandle> is obtained from either a call to the FOpen()\nor the FCreate() function.\n\n<nOffset> is the offset (from the beginning of the file) to the first\nof the region to be unlocked.  (Offsets from the current position\nnd of file are not currently supported.)\n\n<nBytes> is the length of the region to be unlocked in bytes.",
    "EXAMPLES": "// refer to tests/tflock.prg",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "hb_FLock(), FOpen(), FCreate(), FError(), FClose()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetInit()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Activate Harbour INET support",
    "SYNTAX": "hb_inetInit() --> lResult",
    "ARGUMENTS": "(This function has no arguments)",
    "RETURNS": "Returns .T. or .F. whether the internal INET system was successfully initialized",
    "DESCRIPTION": "Activates inet support; mainly used for winsock start up at the moment, but\ncould be used in the future for many other purpose. Put it at the beginning\nof every program using INET functions.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Procedure",
    "NAME": "hb_inetCleanup()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Terminate Harbour INET support",
    "SYNTAX": "hb_inetCleanup()",
    "ARGUMENTS": "(This function has no arguments)",
    "DESCRIPTION": "Closes inet support; mainly used for Windows. Put it at the end of any program\nusing Inet functions, just before the program exits.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetCreate()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Create an INET socket",
    "SYNTAX": "hb_inetCreate( [ <nTimeout> ] ) --> <SOCKET>",
    "ARGUMENTS": "<nTimeout> Socket timeout (optional) TODO: what is the scale (seconds, milliseconds?)",
    "RETURNS": "An INET socket",
    "DESCRIPTION": "Creates the raw data of the socket, that can be passed to a asynchronous\nconnection function (hb_inetConnect() or hb_inetConnectIP()). This will prevent the\nconnection function from allocating some data that could be never used in\ncertain cases, i.e. an asynchronously detected timeout.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetClose()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Close an INET socket",
    "SYNTAX": "hb_inetClose( <socket> ) --> nResult",
    "ARGUMENTS": "<socket> a socket previously created / opened",
    "RETURNS": "Returns 0 on success or -1 on error; on error, the error code is set;\n(actually, on success the socket error code is set to 1 -- socket closed )",
    "DESCRIPTION": "Closes the socket, notifying both ends of the communication pipe that the\nconnection is over.\n\nIf you have threads waiting for data to be read from\nthis socket, this method will make them stop waiting and return an error\n(socket closed) to their callers.\n\nThe method does not destroy the socket, which can be used by subordinate\nthreads to check that the socket is closed, and so they should stop as soon\nas they can. Don't destroy the socket unless you are sure that no other\nthread is using it.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetFD()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "?",
    "SYNTAX": "hb_inetFD( <socket> [, <lNoSocket> ] ) --> nResult",
    "ARGUMENTS": "<socket> a socket previously created / opened\n\n<lNoSocket>",
    "RETURNS": "?",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetstatus()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get the status of a socket",
    "SYNTAX": "hb_inetstatus( <socket> ) --> nResult",
    "ARGUMENTS": "<socket> a socket previously created / opened",
    "RETURNS": "Returns 1 (one) if the socket exists, -1 if it does not",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetErrorCode()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get the last INET error code",
    "SYNTAX": "hb_inetErrorCode( <socket> ) --> nResult",
    "ARGUMENTS": "<socket> a socket previously created / opened",
    "RETURNS": "Last error code",
    "DESCRIPTION": "Returns the last error code that has been provoked by a network operation,\nor 0 if none.\n\nError codes are the ones used for winsock or UnixSockets (they\nare the same); 1 is reserved for \"connection closed\" message.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetErrorDesc()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get the last INET error code description",
    "SYNTAX": "hb_inetErrorDesc( <socket> ) --> cResult",
    "ARGUMENTS": "<socket> a socket previously created / opened",
    "RETURNS": "System-dependent error string",
    "DESCRIPTION": "Returns a string describing the last error that occurred in the socket;\nthe string is system dependent, and should be used only for debugging\npurposes.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Procedure",
    "NAME": "hb_inetClearError()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Clear the socket error value",
    "SYNTAX": "hb_inetClearError( <socket> )",
    "ARGUMENTS": "<socket> a socket previously created / opened",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetCount()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get the number of bytes last read or sent",
    "SYNTAX": "hb_inetCount( <socket> ) --> nResult",
    "ARGUMENTS": "<socket> a socket previously created / opened",
    "RETURNS": "Last socket operation character count",
    "DESCRIPTION": "Returns the amount of characters read or written in the latest socket\noperation.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetAddress()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get a remote server address",
    "SYNTAX": "hb_inetAddress( <socket> ) --> cResult",
    "ARGUMENTS": "<socket> a socket previously created / opened",
    "RETURNS": "Server address",
    "DESCRIPTION": "Returns a string representing the remote server address in quad dot notation,\ne.g. \"127.0.0.1\", or the local server address if the socket is server\nside.\n\nTODO: have a version that returns a vector of 4 numbers.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetPort()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get the port a socket is bound to.",
    "SYNTAX": "hb_inetPort( <socket> ) --> cResult",
    "ARGUMENTS": "<socket> a socket previously created / opened",
    "RETURNS": "Port name the socket is bound to.",
    "DESCRIPTION": "Returns the port to which this socket is bound, or the remote port if this\nsocket is connected with a remote host or client",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetTimeout()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get or change the timeout value of a socket",
    "SYNTAX": "hb_inetTimeout( <socket> [, <nTimeout> ] ) --> nPreviousTimeout",
    "ARGUMENTS": "<socket> a socket previously created / opened\n\n<nTimeout> is the new socket timeout value",
    "RETURNS": "Returns the previous timeout value of the socket",
    "DESCRIPTION": "Sets or changes the timeout value of the socket.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Procedure",
    "NAME": "hb_inetClearTimeout()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Clear the timeout value of a socket",
    "SYNTAX": "hb_inetClearTimeout( <socket> )",
    "ARGUMENTS": "<socket> a socket previously created / opened",
    "DESCRIPTION": "Clears the default timeout of the given socket. Default timeout is used in all\nblocking operations.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetTimeLimit()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get or change the time limit value of a socket",
    "SYNTAX": "hb_inetTimeLimit( <socket> [, <nTimeLimit> ) --> NIL",
    "ARGUMENTS": "<socket> a socket previously created / opened\n\n<nTimeLimit>",
    "RETURNS": "Returns the previous time limit value of the socket",
    "DESCRIPTION": "Sets or changes the time limit value of the socket.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Procedure",
    "NAME": "hb_inetClearTimeLimit()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Clear the time limit value of a socket",
    "SYNTAX": "hb_inetClearTimeLimit( <socket> )",
    "ARGUMENTS": "<socket> a socket previously created / opened",
    "DESCRIPTION": "Clears the default time limit of the given socket.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetPeriodCallback()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get or change the periodic callback value of a socket",
    "SYNTAX": "hb_inetPeriodCallback( <socket> [, <xCallback> ] ) --> xPreviousCallback",
    "ARGUMENTS": "<socket> a socket previously created / opened\n\n<xCallback> a new periodic callback",
    "RETURNS": "The previous periodic callback value",
    "DESCRIPTION": "Sets or returns the socket periodic callback value\n\n<xCallback> can be one of: a codeblock, an array of (...), or a (symbol)\nTODO: describe these better",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Procedure",
    "NAME": "hb_inetClearPeriodCallback()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Clear the periodic callback value of a socket",
    "SYNTAX": "hb_inetClearPeriodCallback( <socket> )",
    "ARGUMENTS": "<socket> a socket previously created / opened",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetGetSndBufSize()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get the socket send buffer size",
    "SYNTAX": "hb_inetGetSndBufSize( <socket> ) --> nResult",
    "ARGUMENTS": "<socket> a socket previously created / opened",
    "RETURNS": "Returns the socket send buffer size or -1 if the socket is closed or an error occurs",
    "DESCRIPTION": "Returns the socket send buffer size or -1 if the socket is closed or an error occurs",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetGetRcvBufSize()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get the socket receive buffer size",
    "SYNTAX": "hb_inetGetRcvBufSize( <socket> ) --> nResult",
    "ARGUMENTS": "<socket> a socket previously created / opened",
    "RETURNS": "Returns the socket receive buffer size or -1 if the socket is closed or an error occurs",
    "DESCRIPTION": "Returns the socket receive buffer size or -1 if the socket is closed or an error occurs",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetSetSndBufSize()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Set the send buffer size of a socket",
    "SYNTAX": "hb_inetSetSndBufSize( <socket>, <nSize> ) --> nSize",
    "ARGUMENTS": "<socket> a socket previously created / opened\n\n<nSize>",
    "RETURNS": "Returns the passed <nSize> or -1 on error",
    "DESCRIPTION": "Sets the send buffer size of a socket",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetSetRcvBufSize()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Set the receive buffer size of a socket",
    "SYNTAX": "hb_inetSetRcvBufSize( <socket>, <nSize> ) --> nSize",
    "ARGUMENTS": "<socket> a socket previously created / opened\n\n<nSize>",
    "RETURNS": "Returns the passed <nSize> or -1 on error",
    "DESCRIPTION": "Sets the receive buffer size of a socket",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetRecv()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Read from a socket",
    "SYNTAX": "hb_inetRecv( <socket>, @<cResult>, [ <nAmount> ] ) --> nResult",
    "ARGUMENTS": "<socket> a socket previously created / opened\n\n<cResult> is the target buffer and must be passed by reference\n\n<nAmount> is the upper limit of characters to be read from the socket.\nIf not passed this defaults to the length of <cResult>",
    "RETURNS": "The number of the characters read from the socket.",
    "DESCRIPTION": "Reads from the socket into a buffer.\n\nThe parameter <cString> must be preallocated so that it has enough\nspace to receive the data. The routine will block the thread until some\nbytes are read from the socket, the socket is closed (either from the\nreceiver or the sender side) or a network error occurs, whichever comes\nfirst. In the latter cases, an error is set, and only the characters\nreceived until premature end of communications are returned.\n\nNotice that there is no guarantee that all the available bytes will be\nread before the function returns, in fact, hb_inetRecv() returns as soon it\nis able to fill <cString> with one or more bytes. To block the current\nprocess until the whole <cString> is filled (or <nAmount> bytes are read),\nuse the hb_inetRecvAll().",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetRecvAll()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Read from a socket without blocking",
    "SYNTAX": "hb_inetRecvAll( <socket>, @<cResult>, [ <nAmount> ] ) --> nResult",
    "ARGUMENTS": "<socket> a socket previously created / opened\n\n<cResult> is the target buffer and must be passed by reference\n\n<nAmount> is the upper limit of characters to be read from the socket.\nIf not passed this defaults to the length of <cResult>",
    "RETURNS": "The number of the characters read from the socket. Might be\nless than <nAmount> on premature socket closing or on network error.",
    "DESCRIPTION": "This function works exactly as hb_inetRecv() except that it\nblocks until <nAmount> bytes are read, if <nAmount> is given, or\n<cString> is filled for its whole length.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetRecvLine()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Read a line from a socket",
    "SYNTAX": "hb_inetRecvLine( <socket> [, @<nBytesRead>, [, <nMaxLength> [, <nBufSize> ]]] ) --> cResult",
    "ARGUMENTS": "<socket> a socket previously created / opened\n\n<nBytesRead> must be passed by reference\n\n<nMaxLength>\n\n<nBufSize>",
    "RETURNS": "Line read",
    "DESCRIPTION": "Blocks the calling thread until a sequence CRLF is read from the socket.\nIncremental allocation and end-of-line checking are done in an efficient\nway.\n\nIf an error occurs, or if the stream is closed before a CRLF is read,\nthe function returns nothing and sets the socket error.\n\nThe returned string does not contain the trailing CRLF sequence, so an\nempty line is effectively returned as an empty string.\n\nIf the <nBytesRead> parameter is given, it will contain the number of bytes\nread from the socket, including the CRLF sequence, so that in normal\nconditions, <nResult> will report a count equal to the length of the\nreturned string plus 2. <nBytesRead> will be 0 if stream is closed before\na CRLF sequence is read, and will be -1 on error.\n\nAn optional <nMaxLength> parameter can be given to allow a maximum character\ncount before the data is returned anyway. If this number is reached before\na CRLF sequence is encountered, <nBytesRead> will contain the value one.\n\nFinally, a <nBufSize> parameter can be given. If not, memory allocation\nwill be increased by discrete amounts of 80 bytes. The programmer\ncan provide here a different allocation strategy (e.g. setting <nBufSize>\nequal to <nMaxLength>, memory for reading the line will be allocated only\nonce, at the beginning of the function).",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetRecvEndblock()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Read a block from a socket",
    "SYNTAX": "hb_inetRecvEndblock( <socket> [, <cBlock >[, @<nBytesRead> [, <nMaxLength> [, <nBufSize> ]]]] ) --> cResult",
    "ARGUMENTS": "<socket> a socket previously created / opened\n\n<cBlock>\n\n<nBytesRead>\n\n<nMaxLength>\n\n<nBufSize>",
    "RETURNS": "Block read",
    "DESCRIPTION": "This function operates exactly the same way as hb_inetRecvLine(), but\nthe \"record termination\" is customizable through the <cBlock> parameter.\nIf not given, this parameter defaults to the CRLF sequence.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetDataReady()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get whether there is data ready in a socket",
    "SYNTAX": "hb_inetDataReady( <socket>, [ <nMillisec> ] ) --> nResult",
    "ARGUMENTS": "<socket> a socket previously created / opened\n\n<nMillisec>",
    "RETURNS": "If there is data available 1 (one) is returned, 0 (zero) if there is no data\nand -1 if there is an  error.",
    "DESCRIPTION": "Verifies if some data is available to be read in the socket without blocking\nexecution of the caller.\n\nIf <nMillisecs> is not given, the function returns\nimmediately 1 if there is some data to be read, 0 if there isn't any data and\n-1 in case of error.\n\nIf <nMillisecs> is given, the function will wait up to that\namount of milliseconds for data to be available; if some data arrives in the\nmeanwhile, the wait is immediately interrupted.\n\nThe next hb_inetRecv() function will read all the available data (up to the\nrequired length) without blocking.\n\nOn error, hb_inetErrorCode() and hb_inetErrorDesc() can be use to determine what kind\nof error happened.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetSend()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Sent data through a socket",
    "SYNTAX": "hb_inetSend( <socket>, <cBuffer> [, <nLength> ] ) --> nResult",
    "ARGUMENTS": "<socket> a socket previously created / opened\n\n<cBuffer>\n\n<nLength>",
    "RETURNS": "The amount of data written, 0 (zero) if the socket is closed, or -1 on an error",
    "DESCRIPTION": "Send data being stored in a string over the socket.\n\nThe <nLength> parameter can be given to allow writing only a part of\nthe string.\n\nThere is no guarantee that all of <cBuffer> will be\nsent, as this is a decision that is up to the OS; this function does not\ntake care to ensure that the data is really sent; check\nthe returned number and send the part that has not been sent.\n\nTo ensure that all the data is sent before the function returns, use the\nhb_inetSendAll() function.\n\nOn error, the error in the socket is set.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetSendAll()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Send data through a socket with blocking",
    "SYNTAX": "hb_inetSendAll( <socket>, <cBuffer> [, <nLength> ] ) --> nResult",
    "ARGUMENTS": "<socket> a socket previously created / opened\n\n<cBuffer>\n\n<nLength>",
    "RETURNS": "The amount of data written, 0 (zero) if the socket is closed, or -1 on an error",
    "DESCRIPTION": "This function works exactly as hb_inetSend() but it ensures that all the\ndata to be sent is written before returning.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetGetHosts()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get an array of IP addresses of a host",
    "SYNTAX": "hb_inetGetHosts( <cName> ) --> aHosts",
    "ARGUMENTS": "<cName>",
    "RETURNS": "An array of IP addresses",
    "DESCRIPTION": "Returns an array containing all the IP addresses associated with a given\nhost name. The IP addresses returned by this function are strings in\nquad dot notations, e.g. \"127.0.0.1\", and can be directly used into\nhb_inetConnectIP().\n\n<cName> can be any string: valid DNS names (e.g.\n\"example.org\"), locally available names (e.g. \"localhost\" or\nwindows Network Neighborhood names), or even IP addresses in quad\ndot notation.\n\nNOTE: This function is not thread safe (by design), and programmers\nmust be sure not to use it at the same time in two different threads,\nor not to use it together with a hb_inetConnect(). If this kind of situation\nshould ever arise, you are advised to use a thread MUTEX.\n\nOn error, and if the server cannot be found, the function returns NIL.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetGetAlias()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get an array of aliases of a server",
    "SYNTAX": "hb_inetGetAlias( <cName> ) --> aHosts",
    "ARGUMENTS": "<cName>",
    "RETURNS": "Array of server aliases",
    "DESCRIPTION": "Returns an array containing the aliases ( CNAME DNS records ) by\nwhich the server is currently known.\n\nWhether this function is able\nto have the complete list of aliases or not depends on the verbosity\nof the DNS server.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetServer()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Create a socket bound to a port",
    "SYNTAX": "hb_inetServer( <port> [, <cBindAddr> [, <nListenLimit> ]]  ) --> <SOCKET>",
    "ARGUMENTS": "<port>\n\n<cBindAddr>\n\n<nListenLimit> is an internal parameter and rarely needs to be passed, defaults to 10",
    "RETURNS": "An INET socket",
    "DESCRIPTION": "Creates a server that can accept connections from client on a certain port.\n\nIf the computer on which hb_inetServer() is called has more than one logical\ninterface (e.g. one network card, one loopback and one PPP address),\n<cBindAddr> can be specified to select only one of these interfaces to accept\nconnections for this process. This is useful when a server is present on\ntwo networks, and the service is to be available only in one of them. Also,\nthe same port on other addresses is left free to be used, so you can have\ndifferent server programs running for different networks but managing\nthe same service. For example, an FTP server available to the internal\nnetwork could be radically different from an FTP server available for\nthe internet.\n\n<nListenLimit> is the number of incoming connections accepted by kernel before the\nkernel has the chance to report them to the application program. If\nthe sockets receive <nListenLimit> connections before accepting them\nall, the `nListenLimit + 1` connection will be notified to be \"busy\" by\nthe kernel. The default value of 10 is enough for even\na heavy duty server.\n\nOn error, sets error description in the newly returned socket.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetAccept()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Wait until a socket is ready",
    "SYNTAX": "hb_inetAccept( <socket> ) --> <SOCKET>",
    "ARGUMENTS": "An INET socket",
    "RETURNS": "<socket> a socket previously created / opened",
    "DESCRIPTION": "Waits until a connection is available on a socket created with hb_inetServer(),\nreturns a socket that can be used to communicate with the incoming client.\n\nOn error, NIL is returned and error code sets in the passed <SOCKET>.\n\nThis error can be accessed using hb_inetErrorCode() function.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetConnect()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Connect a socket to a remote server by IP address or name",
    "SYNTAX": "hb_inetConnect( <cAddress>, <nPort> ) --> <SOCKET>\n\nhb_inetConnect( <cAddress>, <nPort>, <socket> ) --> NIL",
    "ARGUMENTS": "<cAddress>\n\n<nPort>\n\n<socket>",
    "RETURNS": "(First form) INET socket\n\n(Second form has no return value)",
    "DESCRIPTION": "Connects to a remote server described by <cAddress>, that can be in\nquad dot notation (e.g. \"127.0.0.1\") or in DNS name (e.g.\n\"example.org\"), using the desired port.\n\nhb_inetConnect() uses \"gethostbyname\" C system call to\nfind the network address of the specified server; this means that\nthis call is an hybrid function doing both a DNS scan and a TCP/IP\nconnection. hb_inetConnect() is not thread safe, and the\nprogram must take care that two hb_inetConnect() functions are never\ncalled at the same moment from two different threads (or that\nhb_inetGetHosts() is not called in the same moment as an hb_inetConnect()).\n\nThe second version of this function accepts a pre-built socket\nas a parameter. This allows to kill asynchronously a thread waiting\nfor hb_inetConnect() to connect, and then cleaning up the leftover\nsocket data. Also, it is possible to give timeout to the given <SOCKET>,\nbut this timeout will be used only in the connection phase, after that\nthe network address resolution is completed. Use hb_inetGetHosts() and\nhb_inetConnectIP() for a finer timeout control.\nOn error, the error of the returned socket is set. The error could\nbe due to unavailable name resolving service, host name not valid,\nhost address not reachable and host reachable but port not open.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetConnectIP()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Connect to a remote server by IP address",
    "SYNTAX": "hb_inetConnectIP( <cAddress>, <nPort> ) --> <SOCKET>\n\nhb_inetConnectIP( <cAddress>, <nPort>, <socket> ) --> NIL",
    "ARGUMENTS": "<cAddress>\n\n<nPort>\n\n<socket>",
    "RETURNS": "(First form) INET socket\n\n(Second form has no return value)",
    "DESCRIPTION": "Connects to a remote server described by <cAddress>, that can be specified\nonly in quad dot IPv4 notation (e.g. \"127.0.0.1\"), using the desired port.\nThis version of hb_inetConnect() does not use gethostbyname(), and thus is thread\nsafe and can be used in combination with hb_inetGetHosts() to have a finer\ntimeout control while connecting to a server, and a finer error control.\n\nThe second version of this function accepts a pre-built socket\nas a parameter. This allows to kill asynchronously a thread waiting\nfor hb_inetConnectIP() to connect, and then cleaning up the leftover\nsocket data. Also, it is possible to give timeout at the given <SOCKET>.\n\nOn error, the error of the returned socket is set.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetDGram()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Create a datagram socket",
    "SYNTAX": "hb_inetDGram( [<lBroadcast>] ) --> <SOCKET>",
    "ARGUMENTS": "<lBroadcast>",
    "RETURNS": "An INET socket",
    "DESCRIPTION": "Creates a datagram-oriented socket that will be able to send data and\neventually receive data. Since the socket is not bound, the program cannot\nretrieve the address at which this socket appears to be, but a second\nsocket receiving a message sent from this one would be able to reply\ncorrectly with a datagram that can be read from a non-bound socket.\n\nIf <lBroadcast> is set to .T., the routine creates a broadcast capable socket:\nit will be able to receive and send broadcast messages. On most systems this\nrequires special user privileges.\n\nReturns the socket, and if an error occurs, the socket error message\nand code are set.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetDGramBind()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Create a bound datagram socket",
    "SYNTAX": "hb_inetDGramBind( <nPort>, [<cAddress> [, <lBroadcast>] ] ) --> <SOCKET>",
    "ARGUMENTS": "<nPort>\n\n<cAddress>\n\n<bBroadcast>",
    "RETURNS": "An INET socket",
    "DESCRIPTION": "Creates a datagram-oriented socket and binds it to a particular port, and\neventually to a certain interface if <cAddress> is given and not NIL.\n\nIf <lBroadcast> is set to .T., the routine creates a broadcast capable socket:\nit will be able to receive and send broadcast messages. On most systems this\nrequires special user privileges.\n\nReturns the socket\n\nIf an error occurs, the socket error message\nand code are set.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetDGramSend()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Send data to a datagram socket",
    "SYNTAX": "hb_inetDGramSend( <socket>, <cAddress>, <nPort>, <cBuffer> [, <nSize> ] ) --> nBytesSent",
    "ARGUMENTS": "<socket> a socket previously created / opened\n\n<cAddress>\n\n<nPort>\n\n<cBuffer>\n\n<nSize>",
    "RETURNS": "Returns number of bytes sent, or -1 on error",
    "DESCRIPTION": "Sends a datagram (a fixed length data) to a determined IP address (<cAddress>,\nto be specified in quad-dot notation) and port.\n\nIf <nSize> is not specified,\nall the data in <cBuffer> will be sent; if <nSize> is specified, only\nthe first <nSize> bytes of <cBuffer> will be sent.\n\nThere isn't any guarantee that all the data required to be written is\nreally sent to the socket: the calling program should check for the\nnumeric return and send iteratively the unsent data to complete\nthe message.\n\nAnyway, the raw datagram is sent and received as once, and any data\nless than the system datagram size will be sent and received\nas a single item.\n\nIf the socket is created in broadcast mode, the <cAddress> element\ncan be a broadcast address.\n\nReturns -1 on error, or the number of bytes actually sent on success.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetDGramRecv()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get data from a datagram socket",
    "SYNTAX": "hb_inetDGramRecv( <socket>, @<cBuffer> [, <nSize> ] ) --> nBytesRead",
    "ARGUMENTS": "<socket> a socket previously created / opened\n\n<cBuffer> is the target buffer and must be passed by reference\n\n<nSize>",
    "RETURNS": "Returns number of bytes read, or -1 on error",
    "DESCRIPTION": "Reads at maximum <nSize> bytes incoming from a UDP socket, if <nSize> is\ngiven, or reads at maximum <cBuffer> length if <nSize> is not given.\n\nThere isn't any guarantee that all the data required to be read is\nreally sent from the kernel to the application: the kernel should\njust return the last complete datagram that has been received, up\nto <nSize> bytes.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetCRLF()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get a CRLF sequence for internet protocols",
    "SYNTAX": "hb_inetCRLF() --> cResult",
    "ARGUMENTS": "(This function has no arguments)",
    "RETURNS": "Internet CRLF sequence",
    "DESCRIPTION": "Returns a CRLF sequence used in many internet protocols.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbinet.txt",
    "AUTHOR": "Copyright Giancarlo Niccolai <gian@niccolai.ws>",
    "TEMPLATE": "Function",
    "NAME": "hb_inetIsSocket()",
    "CATEGORY": "API",
    "SUBCATEGORY": "INET",
    "ONELINER": "Get whether a variable is a socket",
    "SYNTAX": "hb_inetIsSocket( <socket> ) --> lResult",
    "ARGUMENTS": "<socket> a socket previously created / opened",
    "RETURNS": "Returns whether the passed parameter is a socket",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "",
    "FILES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hbtoken.txt",
    "AUTHOR": "2016 Pete D. <pete_westg@yahoo.gr>",
    "TEMPLATE": "Function",
    "NAME": "hb_ATokens()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Parses a complex string (e.g. a sentence or multi-line text) into individual\ntokens (words or other string chunks depending on delimiter used).",
    "SYNTAX": "hb_ATokens( <cString>, [<cDelim>|<lEOL>], [<lSkipStrings>], ;\n            [<lDoubleQuoteOnly>] ) --> aTokens",
    "ARGUMENTS": "<cString> Complex string to be parsed.\n\n<cDelim>|<lEOL Character(s) used as delimiter of separate tokens.\n               If <lEOL> flag defined instead of <cDelim>,\n               then end of line marker(s) will be used as delimiter.\n\n<lSkipStrings> Boolean flag indicating if quoted substrings\n               will be tokenized or not.\n\n<lDoubleQuoteOnly> Boolean flag indicating that only double-quoted\n                   substrings will be tokenized.",
    "RETURNS": "<aTokens> A character array, filled with the individual tokens found.",
    "DESCRIPTION": "This function analyses the complex string <cString> and splits it\ninto separate sub-strings (tokens) that are delimited by <cDelim>\nor by space character, if no <cDelim> delimiter is passed, or by EOL marker\nif <lEOL> instead of <cDelim> is specified.\n\nThe located tokens, are stored in an array which is returned by the function.\n\nIf <lSkipStrings> is .T. (default: .F.), the quoted sub-strings (if any)\nwithin <cString> are not tokenized. If <lDoubleQuoteOnly> is .T.\nonly the double quote `\"` is recognized as a quote sign.\nThis argument is meaningful only when <lSkipStrings> is .T.\n",
    "NOTES": "1) the tokenization process is case sensitive, in the (rare) case\n   where <cDelim> is an alphabetic character.\n\n2) The delimiters are removed (trimmed) from tokens.",
    "EXAMPLES": "LOCAL cString := \"Harbour is proven to be stable, robust and efficient.\"\nLOCAL aTokens := hb_ATokens( cString )\nAEval( aTokens, {| token, n | QOut( hb_ntos(n), token ) } )\n?\naTokens := hb_ATokens( cString, \",\" )\nAEval( aTokens, {| token, n | QOut( hb_ntos(n), token ) } )",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "SubStr()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hvm.txt",
    "TEMPLATE": "Function",
    "NAME": "hb_PValue()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Application",
    "ONELINER": "Retrieves the value of an argument.",
    "SYNTAX": "hb_PValue( <nArg> ) --> xExp",
    "ARGUMENTS": "A number that indicates the argument to check.",
    "RETURNS": "<xExp> Returns the value stored by an argument.",
    "DESCRIPTION": "This function is useful to check the value stored in an argument.",
    "EXAMPLES": "Test( 123, \"abc\" )\nSTATIC PROCEDURE Test( nValue, cString )\n   IF PCount() == 2\n      ? hb_PValue( 1 ), nValue\n      ? hb_PValue( 2 ), cString\n   ENDIF\n   RETURN",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "PCount()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hvm.txt",
    "TEMPLATE": "Function",
    "NAME": "PCount()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Application",
    "ONELINER": "Retrieves the number of arguments passed to a function.",
    "SYNTAX": "PCount() --> nArgs",
    "ARGUMENTS": "None",
    "RETURNS": "<nArgs> A number that indicates the number of arguments\npassed to a function or procedure.",
    "DESCRIPTION": "This function is useful to check if a function or procedure\nhas received the required number of arguments.",
    "EXAMPLES": "Test()\nTest( \"abc\" )\nSTATIC PROCEDURE Test( xExp )\n   IF PCount() == 0\n      ? \"This function needs a parameter\"\n   ELSE\n      ? xExp\n   ENDIF\n   RETURN",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "hb_PValue()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hvm.txt",
    "TEMPLATE": "Procedure",
    "NAME": "__Quit()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Events",
    "ONELINER": "Terminates an application.",
    "SYNTAX": "__Quit()",
    "ARGUMENTS": "None",
    "DESCRIPTION": "This function terminates the current application and returns\nto the system.",
    "EXAMPLES": "EndApp( .F. )\nEndApp( .T. )\nSTATIC PROCEDURE EndApp( lYesNo )\n   IF lYesNo\n      __Quit()\n   ENDIF\n   RETURN",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "QUIT"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hvm.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "CLIPINIT()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Internal",
    "ONELINER": "Initialize various Harbour sub-systems",
    "SYNTAX": "CLIPINIT() --> NIL",
    "ARGUMENTS": "none.",
    "RETURNS": "CLIPINIT() always return NIL.",
    "DESCRIPTION": "CLIPINIT() is one of the pre-defined INIT PROCEDURE and is executed\nat program startup. It declare an empty MEMVAR PUBLIC array called\nGetList that is going to be used by the Get system. It activates the\ndefault error handler, and (at least for the moment) calls the\nfunction that sets the default help key.",
    "STATUS": "R",
    "COMPLIANCE": "It is said that CLIPINIT() should not call the function that sets\nthe default help key since CA-Cl*pper does it in some other place.",
    "PLATFORMS": "All",
    "SEEALSO": "INIT PROCEDURE"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hvm.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Procedure",
    "NAME": "__SetHelpK()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Internal",
    "ONELINER": "Set <F1> as the default help key",
    "SYNTAX": "__SetHelpK()",
    "ARGUMENTS": "None.",
    "DESCRIPTION": "Set <F1> to execute a function called HELP if such a function is\nlinked into the program.",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "__XHelp(), SET KEY, SetKey()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hvm.txt",
    "TEMPLATE": "Procedure",
    "NAME": "Break()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Error",
    "ONELINER": "Exits from a `BEGIN SEQUENCE` block",
    "SYNTAX": "Break( <xExp> )",
    "ARGUMENTS": "<xExp> is any valid expression. It is always required.\nIf do not want to pass any argument, just use NIL.",
    "DESCRIPTION": "This function passes control to the RECOVER statement in a\n`BEGIN SEQUENCE` block.",
    "EXAMPLES": "Break( NIL )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "BEGIN SEQUENCE"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/hvm.txt",
    "AUTHOR": "Copyright 1999 Ryszard Glab <rglab@imid.med.pl>",
    "TEMPLATE": "Function",
    "NAME": "Do()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Application",
    "ONELINER": "Calls a procedure or a function",
    "SYNTAX": "Do( <xFuncProc> [, <xArguments...>] ) --> xRetVal",
    "ARGUMENTS": "<xFuncProc> = Either a string with a function/procedure name to be called\nor a codeblock to evaluate.\n\n<xArguments> = arguments passed to a called function/procedure or to\na codeblock.",
    "RETURNS": "<xRetVal> A value that was returned from called function.",
    "DESCRIPTION": "This function can be called either by the Harbour compiler or by user.\nThe compiler always passes the item of HB_IT_SYMBOL type that stores the\nname of procedure specified in `DO <proc> WITH ...` statement.\n\nIf called procedure/function doesn't exist then a runtime error\nis generated.\n\nThis function can be used as replacement of macro operator.\nIt is also used internally to implement `DO <proc> WITH <args...>`\nIn this case <xFuncProc> is of type HB_SYMB.",
    "EXAMPLES": "LOCAL cFunction := \"MyFunc\"\n\n? Do( cFunction, 1 )  // Old style\nDO &cFunction WITH 2  // Old style with macro\n\n? Do( {| n | MyFunc( n ) }, 3 )\n? Do( @MyFunc(), 4 )\n\nFUNCTION MyFunc( n )  /* must be a public function for old style calls */\n   ? n\n   RETURN n + 1",
    "COMPLIANCE": "C",
    "FILES": "Library is core"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/idle.txt",
    "TEMPLATE": "Document",
    "NAME": "The idle states",
    "CATEGORY": "Document",
    "ONELINER": "Readme file for Idle States",
    "DESCRIPTION": "The idle state is the state of the Harbour virtual machine when it\nwaits for the user input from the keyboard or the mouse. The idle\nstate is entered during Inkey() calls currently. All applications\nthat don't use Inkey() function call can signal the idle states with\nthe call of hb_idleState() function (or hb_idleState() on C level).\n\nDuring idle states the virtual machine calls the garbage collector and\nit can call user defined actions (background tasks). It also releases\nthe CPU time slices for some poor platforms that are not smart enough\nto detect it automatically.\n\nFor defining the background tasks see the hb_idleAdd() and hb_idleDel()\nfunctions.\n\nFor direct call for background actions see hb_idleState() function.\n\nFor signaling the idle state from C code see the hb_idleState()\nAPI function.",
    "SEEALSO": "hb_idleAdd(), hb_idleDel()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/idle.txt",
    "TEMPLATE": "Function",
    "NAME": "hb_idleAdd()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Idle states",
    "ONELINER": "Adds the background task.",
    "SYNTAX": "hb_idleAdd( <bAction> ) --> nHandle",
    "ARGUMENTS": "<bAction> is a codeblock that will be executed during idle states.\nThere are no arguments passed to this codeblock during evaluation.",
    "RETURNS": "<nHandle> The handle (an integer value) that identifies the task. This\nhandle can be used for deleting the task.",
    "DESCRIPTION": "hb_idleAdd() adds a passed codeblock to the list of background\ntasks that will be evaluated during the idle states. There is no\nlimit for the number of tasks.",
    "EXAMPLES": "nTask := hb_idleAdd( {|| SayTime() } )",
    "STATUS": "R",
    "COMPLIANCE": "Harbour extension similar to ft_OnTick() function available\nin NanForum library.",
    "PLATFORMS": "All",
    "SEEALSO": "hb_idleDel(), hb_idleState()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/idle.txt",
    "TEMPLATE": "Function",
    "NAME": "hb_idleDel()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Idle states",
    "ONELINER": "Removes the background task from the list of tasks.",
    "SYNTAX": "hb_idleDel( <nHandle> ) --> bAction",
    "ARGUMENTS": "<nHandle> is the identifier of the task returned by the\nhb_idleAdd() function.",
    "RETURNS": "<bAction> NIL if invalid handle is passed or a codeblock that was\npassed to hb_idleAdd() function",
    "DESCRIPTION": "hb_idleDel() removes the action associated with passed identifier\nfrom the list of background tasks. The identifier should be the\nvalue returned by the previous call of hb_idleAdd() function.\n\nIf specified task is defined then the codeblock is returned\notherwise the NIL value is returned.",
    "EXAMPLES": "nTask := hb_idleAdd( {|| SayTime() } )\nInkey( 10 )\nbAction := hb_idleDel( nTask )",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "SEEALSO": "hb_idleAdd(), hb_idleState()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/idle.txt",
    "TEMPLATE": "Procedure",
    "NAME": "hb_idleState()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Idle states",
    "ONELINER": "Evaluates a single background task and calls the garbage collector.",
    "SYNTAX": "hb_idleState()",
    "ARGUMENTS": "None",
    "DESCRIPTION": "hb_idleState() requests the garbage collection and executes a\nsingle background task defined by the codeblock passed with\nhb_idleAdd() function. Every call to this function evaluates a\ndifferent task in the order of task creation. There are no\narguments passed during a codeblock evaluation.\n\nThis function can be safely called even if there are no background\ntasks defined.",
    "EXAMPLES": "nTask1 := hb_idleAdd( {|| SayTime() } )\nnTask2 := hb_idleAdd( {|| SaveScreen() } )\nDO WHILE ! bFinished\n   bFinished := DoSomethingVeryImportant()\n   hb_idleState()\nENDDO\ncbAction := hb_idleDel( nTask1 )\nhb_idleDel( nTask2 )",
    "STATUS": "R",
    "COMPLIANCE": "Harbour extension similar to ft_IAmIdle() function available\nin NanForum library.",
    "PLATFORMS": "All",
    "SEEALSO": "hb_idleAdd(), hb_idleDel()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/idle.txt",
    "TEMPLATE": "C Function",
    "NAME": "hb_idleState()",
    "CATEGORY": "C level API",
    "SUBCATEGORY": "Idle states",
    "ONELINER": "Evaluates a single background task and calls the garbage collector.",
    "SYNTAX": "void hb_idleState( void );",
    "ARGUMENTS": "None",
    "DESCRIPTION": "hb_idleState() is a C function that requests garbage collection and\nexecutes a single background task defined by the codeblock passed\nwith hb_idleAdd() function. It also releases the CPU time slices for\nplatforms that require it.\n\nEvery call for this function evaluates different task in the\norder of task creation. There are no arguments passed during\ncodeblock evaluation.\n\nThis function can be safely called even if there are no background\ntasks defined.\n\nThis function is automatically called from the Inkey() function.",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "SEEALSO": "hb_idleAdd(), hb_idleDel(), hb_idleState()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/inputall.txt",
    "TEMPLATE": "Function",
    "NAME": "Inkey()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Extracts the next key code from the Harbour keyboard buffer.",
    "SYNTAX": "Inkey( [<nTimeout>] [, <nEvents>] ) --> nKey",
    "ARGUMENTS": "<nTimeout> is an optional timeout value in seconds, with a granularity\nof 1/10th of a second. If omitted, Inkey() returns immediately. If set\nto 0, Inkey() waits until an input event occurs. If set to any other\nvalue, Inkey() will return either when an input event occurs or when\nthe timeout period has elapsed. If only this parameter is specified\nand it is not numeric, it will be treated as if it were 0. But if both\nparameters are specified and this parameter is not numeric, it will be\ntreated as if it were not present.\n\n<nEvents> is an optional mask of input events that are to be enabled.\nIf omitted, defaults to `hb_set.HB_SET_EVENTMASK`. Valid input masks are\nin inkey.ch and are explained below. It is recommended that the mask\nnames be used rather than their numeric values, in case the numeric\nvalues change in future releases of Harbour. To allow more than one\ntype of input event, simply add the various mask names together.\n\n<table>\n inkey.ch            Meaning\n\n INKEY_MOVE          Mouse motion events are allowed\n INKEY_LDOWN         The mouse left click down event is allowed\n INKEY_LUP           The mouse left click up event is allowed\n INKEY_RDOWN         The mouse right click down event is allowed\n INKEY_RUP           The mouse right click up event is allowed\n INKEY_KEYBOARD      All keyboard events are allowed\n INKEY_ALL           All mouse and keyboard events are allowed\n HB_INKEY_EXTENDED   Extended keyboard codes are used.\n</table>\n\nIf the parameter is not numeric, it will be treated as if it were set\nto `hb_set.HB_SET_EVENTMASK`.",
    "RETURNS": "0 in case of timeout with no input event, otherwise returns a value\nin the range -47 to 386 for keyboard events or the range 1001 to 1007\nfor mouse events. Mouse events and non-printable keyboard events are\nrepresented by the `K_<event>` values listed in inkey.ch. Keyboard\nevent return codes in the range 32 through 127 are equivalent to the\nprintable ASCII character set. Keyboard event return codes in the\nrange 128 through 255 are assumed to be printable, but results may\nvary based on hardware and nationality. If HB_INKEY_EXTENDED mode is\nused, then the return value for keyboard events ranges from 1 through\n767 and 1077 through 1491, although not all codes are used.\n\nExtended key codes consist of the PC keyboard scan code and one\nor more offset values. If no keyboard modifier was used, then\nHB_INKEY_NONE is added. The <Alt> key adds HB_INKEY_ALT, the <Ctrl>\nkey adds HB_INKEY_CTRL, the <Shift> key adds HB_INKEY_SHIFT, and\nenhanced keys (<KeyPad+/> and <CursorPad> keys) add HB_INKEY_ENHANCED.\nFor example, <F1> is scan code 59, so if you just press <F1>, you get\nkey code 315, but <Alt+F1> gives 443, <Ctrl+F1> gives 571, and <Shift+F1>\ngives 699. And <NumPad+/> gives 1077, 1205, 1333, and 1461. At\nthis time, the only value that can combine with other values is\nHB_INKEY_ENHANCED (i.e., there are no <Alt+Ctrl> combinations, etc.)\n\nNote: The extended key code set is larger than the normal key code\nset. As a result, if you switch between the normal and extended\nmodes, you need to be aware that some codes get translated into a\nzero in normal mode (because there is no corresponding code in\nnormal mode) and that these codes get removed from the keyboard\ninput buffer in normal mode and you won't be able to go back and\nfetch them later in extended mode.",
    "DESCRIPTION": "Inkey() can be used to detect input events, such as key-press, mouse\nmovement, or mouse key clicks (up and/or down).",
    "EXAMPLES": "#include \"inkey.ch\"\n// Wait for the user to press the <Esc> key\n? \"Please press the <Esc> key.\"\nDO WHILE Inkey( 0.1 ) != K_ESC\nENDDO\n\nKEYBOARD \"AB\"; ? Inkey(), Inkey()  // -->   65   66",
    "STATUS": "S",
    "COMPLIANCE": "Inkey() is compliant with the CA-Cl*pper 5.3 Inkey() function with one\nexception: The Harbour Inkey() function will raise an argument error\nif the first parameter is less than or equal to 0 and the second\nparameter (or the default mask) is not valid, because otherwise Inkey()\nwould never return, because it was, in effect, asked to wait forever\nfor no events (Note: In CA-Cl*pper, this also blocks `SET KEY` events).",
    "FILES": "Library is core\nHeader is inkey.ch",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/inputall.txt",
    "TEMPLATE": "Procedure",
    "NAME": "__Keyboard()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Use hb_keyPut() instead",
    "SYNTAX": "KEYBOARD <cString>\nCLEAR TYPEAHEAD",
    "ARGUMENTS": "<cString> is the optional string to stuff into the Harbour keyboard\nbuffer after clearing it first.\n\nNote: The character `;` is converted\nto `Chr( 13 )` (this is an undocumented CA-Cl*pper feature).",
    "DESCRIPTION": "Clears the Harbour keyboard type-ahead buffer and then inserts an\noptional string into it.",
    "EXAMPLES": "// Stuff an Enter key into the keyboard buffer\nKEYBOARD Chr( 13 )\n// Clear the keyboard buffer\nCLEAR TYPEAHEAD\n\nKEYBOARD Chr( 13 ); ? Inkey()  // --> 13\nKEYBOARD \";\"; ? Inkey()  // --> 13\nKEYBOARD \"Hello\"; CLEAR TYPEAHEAD; ? Inkey()  // --> 0",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "CLEAR TYPEAHEAD, KEYBOARD"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/inputall.txt",
    "TEMPLATE": "Function",
    "NAME": "hb_keyPut()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Put an inkey code to the keyboard buffer.",
    "SYNTAX": "hb_keyPut( <nInkeyCode> )",
    "ARGUMENTS": "<nInkeyCode> is the inkey code, which should be inserted into the\nkeyboard buffer.",
    "RETURNS": "There is no return value.",
    "DESCRIPTION": "Inserts an inkey code to the string buffer. The buffer is *not*\ncleared in this operation. This function allows to insert such\ninkey codes which are not in the range of 0 to 255. To insert more\nthan one code, call the function repeatedly. The zero code cannot\nbe inserted.",
    "EXAMPLES": "#include \"inkey.ch\"\n// Stuff an <Alt+PgDn> key into the keyboard buffer\nhb_keyPut( K_ALT_PGDN ); ? Inkey()  // --> 417\nhb_keyPut( K_F11 ); ? Inkey()  // --> -40",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "KEYBOARD, CLEAR TYPEAHEAD, Inkey()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/inputall.txt",
    "TEMPLATE": "Function",
    "NAME": "NextKey()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Get the next key code in the buffer without extracting it.",
    "SYNTAX": "NextKey( [<nInputMask>] ) --> nKey",
    "ARGUMENTS": "<nInputMask> is an optional integer value composed of one or more\nINKEY_ or HB_INKEY_ constants. The sole purpose of this argument\nis to allow switching between using HB_INKEY_EXTENDED key codes\nand using the normal CA-Cl*pper-compatible key codes",
    "RETURNS": "<nKey>  The value of the next key in the Harbour keyboard buffer.",
    "DESCRIPTION": "Returns the value of the next key in the Harbour keyboard buffer\nwithout extracting it.",
    "EXAMPLES": "#include \"inkey.ch\"\n// Use NextKey() with Inkey() to change display characters, or by\n// itself to exit the loop, so that the caller can detect the <Esc>.\nLOCAL nKey, cChar := \"+\"\nDO WHILE .T.\n   ?? cChar\n   nKey := NextKey()\n   DO CASE\n   CASE nKey == K_ESC\n      EXIT\n   CASE nKey != 0\n      cChar := hb_keyChar( nKey )\n   ENDCASE\nENDDO\n\nKEYBOARD \"AB\"; ? NextKey(), NextKey()  // -->   65   65",
    "STATUS": "R",
    "COMPLIANCE": "NextKey() is compliant with CA-Cl*pper 5.3, but has been extended\nfor Harbour.",
    "FILES": "Library is core",
    "SEEALSO": "Inkey(), LastKey()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/inputall.txt",
    "TEMPLATE": "Function",
    "NAME": "LastKey()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Get the last key extracted from the keyboard buffer.",
    "SYNTAX": "LastKey( [<nInputMask>] ) --> nKey",
    "ARGUMENTS": "<nInputMask> is an optional integer value composed of one or more\nINKEY_ or HB_INKEY_ constants. The sole purpose of this argument\nis to allow switching between using HB_INKEY_EXTENDED key codes\nand using the normal CA-Cl*pper-compatible key codes",
    "RETURNS": "<nKey>  The last key extracted from the keyboard buffer.",
    "DESCRIPTION": "Returns the value of the last key extracted from the Harbour\nkeyboard buffer",
    "EXAMPLES": "#include \"inkey.ch\"\n// Continue looping unless the <Esc> key was pressed in MainFunc()\nDO WHILE .T.\n   MainFunc()\n   IF LastKey() == K_ESC\n      EXIT\n   ENDIF\nENDDO\n\nKEYBOARD \"AB\"; ? Inkey(), LastKey()  // -->   65   65\n\nSTATIC PROCEDURE MainFunc()\n   Inkey( 0 )\n   RETURN",
    "STATUS": "R",
    "COMPLIANCE": "LastKey() is compliant with CA-Cl*pper 5.3, but has been extended\nfor Harbour.",
    "FILES": "Library is core",
    "SEEALSO": "Inkey(), LastKey()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/inputall.txt",
    "TEMPLATE": "Command",
    "NAME": "KEYBOARD",
    "CATEGORY": "Command",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Stuffs the keyboard with a string.",
    "SYNTAX": "KEYBOARD <cString>",
    "ARGUMENTS": "<cString> String to be processed, one character at a time,\nby the Harbour keyboard processor",
    "DESCRIPTION": "This command stuffs the input buffer with <cString>.\n\nThe number of characters that can be stuffed into the keyboard\nbuffer is controlled by the SET TYPEAHEAD command and may range\nfrom 0 to 32622, with each character being in the ASCII\nrange of 0 to 255.\n\nNone of the extended keys may be stuffed into the keyboard buffer.\n\nIssuing a `KEYBOARD \" \"` will clear the keyboard buffer.",
    "EXAMPLES": "// Stuff an Enter key into the keyboard buffer\nKEYBOARD Chr( 13 )\n// Clear the keyboard buffer\nCLEAR TYPEAHEAD\n\nKEYBOARD Chr( 13 ); ? Inkey()  // --> 13\nKEYBOARD \"Hello\"; CLEAR TYPEAHEAD; ? Inkey()  // --> 0",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "CLEAR TYPEAHEAD, __Keyboard()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/inputall.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "ReadKey()*",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Determine which key terminated a READ.",
    "SYNTAX": "ReadKey() --> nKeyCode",
    "ARGUMENTS": "None.",
    "RETURNS": "ReadKey() returns a numeric code representing the key that caused READ\nto terminate.",
    "DESCRIPTION": "ReadKey() is used after a READ was terminated to determine the exit\nkey pressed. If the GET buffer was updated during READ, 256 is added\nto the return code.\n\n<table-doubleheader>\n Exit               Return code     Return code\n Key                (not updated)   (updated)\n\n Up                    4            260\n Down                  5            261\n Page-Up               6            262\n Page-Down             7            263\n Ctrl Page-Up         34            290\n Ctrl Page-Down       35            291\n Esc                  12            268\n Ctrl End             14            270\n Enter                15            271\n Key >= 32            15            271\n otherwise             0            0\n</table>\n\nReadKey() is a compatibility function so try not to use it.\nReadKey() is superseded by LastKey() which returns the Inkey()\ncode for that key.  Updated() could be used to find if the\nGET buffer was changed during the READ.",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "@...GET, Inkey(), LastKey(), READ, ReadExit(), Updated()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/inputall.txt",
    "TEMPLATE": "Function",
    "NAME": "MRow()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Returns the mouse cursor row position.",
    "SYNTAX": "MRow() --> nMouseRow",
    "ARGUMENTS": "None",
    "RETURNS": "<nMouseRow> The mouse cursor row position.",
    "DESCRIPTION": "This function returns the current mouse row cursor position.\nOn graphical systems the value represents pixel rows.\nOn character-based systems the value represents character\nrows as in CA-Cl*pper.",
    "EXAMPLES": "IF MRow() < 1\n   ? \"Mouse is on top row!\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "MRow() is compliant with CA-Cl*pper 5.3, but has been extended\nto work on graphical systems as well as character-based systems.",
    "PLATFORMS": "",
    "FILES": "Library is core",
    "SEEALSO": "MCol()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/inputall.txt",
    "TEMPLATE": "Function",
    "NAME": "MCol()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Returns the mouse cursor column position.",
    "SYNTAX": "MCol() --> nMouseColumn",
    "ARGUMENTS": "None",
    "RETURNS": "<nMouseColumn> The mouse cursor column position.",
    "DESCRIPTION": "This function returns the column position of the mouse cursor.\nOn graphical systems the value represents pixels.\nOn character-based systems the value represents character\ncolumns as in CA-Cl*pper.",
    "EXAMPLES": "IF MCol() < 1\n   ? \"Mouse is on left edge!\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "MCol() is compliant with CA-Cl*pper 5.3, but has been extended\nto work on graphical systems as well as character-based systems.",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "MRow()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/langall.txt",
    "AUTHOR": "Copyright 2004 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "hb_langErrMsg()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Language and Nation",
    "ONELINER": "Description of an error code using current language",
    "SYNTAX": "hb_langErrMsg( <nErrorCode> ) --> cErrorMessage",
    "ARGUMENTS": "<nErrorCode> is one of the generic error codes (`EG_...`) defined\nin error.ch",
    "RETURNS": "hb_langErrMsg() return the error message string represented by\nthe code <nErrorCode>.",
    "DESCRIPTION": "This function return the error message associated with an error\ncode using the current language selected.",
    "EXAMPLES": "#include \"error.ch\"\nREQUEST HB_LANG_ES\n? \"English:\", hb_langErrMsg( EG_ARG )  // --> English: Argument error\nhb_langSelect( \"es\" )\n? \"Spanish:\", hb_langErrMsg( EG_ARG )  // --> Spanish: Error de argumento",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Header is error.ch",
    "SEEALSO": "hb_langSelect(), NationMsg()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/langall.txt",
    "AUTHOR": "Copyright 2004 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "hb_langMessage()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Language and Nation",
    "ONELINER": "Returns international strings messages and errors",
    "SYNTAX": "hb_langMessage( <nMsg>[, <cLangID>] ) --> cMessage",
    "ARGUMENTS": "<nMsg>    is the message number to get.\n<cLangID> is an optional language module ID. Uses the currently\n          selected language module, if not specified.",
    "RETURNS": "hb_langMessage() return the text associated with the code <nMsg>.",
    "DESCRIPTION": "hb_langMessage() is similar to NationMsg() but give access to the\nwhole list of language messages: Day and month names, generic error\nmessages, internal errors, and others...\n\nUse the header file hblang.ch for a list of base values for <nMsg>.",
    "EXAMPLES": "#include \"hblang.ch\"\nREQUEST HB_LANG_ES\n? \"English:\", hb_langMessage( HB_LANG_ITEM_BASE_DAY + 1 )  // --> English: Monday\nhb_langSelect( \"es\" )\n? \"Spanish:\", hb_langMessage( HB_LANG_ITEM_BASE_DAY + 1 )  // --> Spanish: Lunes\n? \"English:\", hb_langMessage( HB_LANG_ITEM_BASE_DAY + 1, \"en\" )",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Header is hblang.ch",
    "SEEALSO": "hb_langSelect(), NationMsg(), REQUEST"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/langall.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "hb_langName()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Language and Nation",
    "ONELINER": "Return the name of the language module",
    "SYNTAX": "hb_langName( [<cLangID>] ) --> cLangName",
    "ARGUMENTS": "<cLangID> is an optional language module ID. Uses the currently\n          selected language module, if not specified.",
    "RETURNS": "<cLangName>  Name of the language module",
    "DESCRIPTION": "This function return the name of the language module in use or\nspecified.",
    "EXAMPLES": "REQUEST HB_LANG_PT\nREQUEST HB_LANG_RO\nREQUEST HB_LANG_ES\nREQUEST HB_LANG_PL\n? hb_langName( \"pl\" )\n? hb_langName( \"<non-existent>\" )\nhb_langSelect( \"pt\" )       // Default language is now Portuguese\n? CDoW( Date() )            // --> Segunda-feira\n? \"Current language is\", hb_langName()              // --> Portuguese\n? \"Old language id selected is\", hb_langSelect()    // --> pt\nhb_langSelect( \"ro\" )       // Default language is now Romanian\n? CMonth( Date() )          // --> Mai\n? \"Old language id selected is\", hb_langSelect()    // --> ro\nhb_langSelect( \"es\" )       // Default language is now Spanish\n? \"Current language is\", hb_langName()              // --> Spanish\n? CMonth( Date() )          // --> Mayo\n? CDoW( Date() )            // --> Lunes",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "",
    "SEEALSO": "hb_langSelect(), NationMsg()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/langall.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "hb_langSelect()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Language and Nation",
    "ONELINER": "Select a specific nation message module",
    "SYNTAX": "hb_langSelect( [<cNewLang>][, <cCodepage>] ) --> cOldLang",
    "ARGUMENTS": "<cNewLang>  The optional ID of the language module.\nPossible values for <cNewLang> are below as defined in the\nLang library, sorted by language.\n<cCodepage>  Optional codepage ID into which the language\nmodule strings are automatically converted by Harbour.\n\n<table>\n Language              <cNewLang>\n\n Basque                eu\n Belorussian           be\n Bulgarian             bg\n Catalan               ca\n Chinese Traditional   zh\n Chinese Simplified    zh_sim\n Croatian              hr\n Czech                 cs\n Dutch                 nl\n Esperanto             eo\n French                fr\n Galician              gl\n German                de\n Greek                 el\n Hebrew                he\n Hungarian             hu\n Icelandic             is\n Indonesian            id\n Italian               it\n Korean                ko\n Lithuanian            lt\n Polish                pl\n Portuguese            pt\n Romanian              ro\n Russian               ru\n Serbian (cyrillic)    sr_cyr\n Serbian (latin)       sr_lat\n Slovak                sk\n Slovenian             sl\n Spanish               es\n Swedish               sv\n Turkish               tr\n Ukrainian             uk\n</table>",
    "RETURNS": "<cOldLang>   The old language identifier",
    "DESCRIPTION": "This function set a default language module for date/month names,\ninternal warnings, NatMsg messages and internal errors. When a\nLang ID is selected all messages will be output with the current\nlanguage selected until another one is selected or the program ends.\nThe default language is English (cLang == \"EN\").\n\nNOTE: You must REQUEST every language module you intend to use.\nFor example: to use the Portuguese language you must add the\nfollowing to your program: `REQUEST HB_LANG_PT`",
    "EXAMPLES": "REQUEST HB_LANG_PT\nREQUEST HB_LANG_RO\nREQUEST HB_LANG_ES\nhb_langSelect( \"pt\" )       // Default language is now Portuguese\n? CDoW( Date() )            // --> Segunda-feira\n? \"Old language id selected is\", hb_langSelect()  // --> pt\nhb_langSelect( \"ro\" )       // Default language is now Romanian\n? CMonth( Date() )          // --> Mai\n? \"Old language id selected is\", hb_langSelect()  // --> ro\nhb_langSelect( \"es\" )       // Default language is now Spanish\n? CMonth( Date() )          // --> Mayo\n? CDoW( Date() )            // --> Lunes",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "",
    "SEEALSO": "hb_langName(), hb_cdpSelect(), NationMsg(), REQUEST"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/langall.txt",
    "AUTHOR": "Copyright 2004 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "hb_cdpSelect()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Language and Nation",
    "ONELINER": "Select the active code page by language ID",
    "SYNTAX": "hb_cdpSelect( [<cNewLang>] ) --> cOldLang",
    "ARGUMENTS": "<cNewLang>  The optional ID of the language module.\nPossible values for <cNewLang> are below as defined in the\nCodepage library, sorted by language.\n\n<table>\n Language              Codepage       <cNewLang>\n\n Bulgarian             866            BG866\n Bulgarian             ISO-8859-5     BGISO\n Bulgarian             MIK            BGMIK\n Bulgarian             Windows-1251   BGWIN\n Croatian              437            HR437\n Croatian              852            HR852\n Croatian              Windows-1250   HRWIN\n Czech                 852            CS852\n Czech                 ISO-8859-2     CSISO\n Czech                 KAM            CSKAM\n Czech                 Windoes-1250   CSWIN\n English               437            EN\n French                850            FR850\n German                850            DE850\n German                ISO-8859-1     DEWIN\n Greek                 737            EL737\n Greek                 Windows-1253   ELWIN\n Hungarian (ntxhu852)  852            HU852C\n Hungarian (sixhu852)  852            HU852\n Hungarian (sixhu852)  CWI-2          HUCWI\n Hungarian             ISO-8859-2     HUISO\n Hungarian             Windows-1250   HUWIN\n Italian               437            IT437\n Italian               850            IT850\n Italian               ISO-8859-1b    ITISB\n Italian               ISO-8859-1     ITISO\n Lithuanian            Windows-1257   LTWIN\n Polish                852            PL852\n Polish                ISO-8859-2     PLISO\n Polish                Mazowia        PLMAZ\n Polish                Windows-1250   PLWIN\n Portuguese            850            PT850\n Portuguese            ISO-8859-1     PTISO\n Russian               866            RU866\n Russian               KOI-8          RUKOI8\n Russian               Windows-1251   RU1251\n Serbian               Windows-1251   SRWIN\n Slovak                852            SK852\n Slovak                ISO-8859-2     SKISO\n Slovak                Kamenicky      SKKAM\n Slovak                Windows-1250   SKWIN\n Slovenian             437            SL437\n Slovenian             852            SL852\n Slovenian             ISO-8859-2     SLISO\n Slovenian             Windows-1250   SLWIN\n Spanish               850            ES850\n Spanish               ISO-8859-1     ESWIN\n Spanish Modern        ISO-8859-1     ESMWIN\n Swedish               850            SV850\n Swedish (Clipper)     437            SV437C\n Swedish               ISO-8859-1     SVWIN\n Turkish               857            TR857\n Turkish               Windows-1254   TRWIN\n Ukrainian             866            UA866\n Ukrainian             KOI-8U         UAKOI8\n Ukrainian             Windows-1251   UA1251\n</table>",
    "RETURNS": "<cOldLang>   The old language identifier",
    "DESCRIPTION": "hb_cdpSelect() set the active code page use by Harbour for\nsorting and comparing strings. The default code page use ASCII\norder (cLang == \"EN\").\n\nNOTE: You must REQUEST every code page module you intend to use.\nFor example: to use the French 850 code page you must add the\nfollowing to your program: `REQUEST HB_CODEPAGE_FR850`",
    "EXAMPLES": "REQUEST HB_CODEPAGE_FR850\nhb_cdpSelect( \"EN\" )\n? hb_cdpSelect()\n? hb_UTF8ToStr( \"É < G is\" ), hb_BChar( 144 ) < \"G\"  // --> É < G is .F.\nhb_cdpSelect( \"FR850\" )\n? hb_cdpSelect()\n? hb_UTF8ToStr( \"É < G is\" ), hb_BChar( 144 ) < \"G\"  // --> É < G is .T.",
    "STATUS": "R",
    "COMPLIANCE": "This function is a Harbour Extension.",
    "PLATFORMS": "All",
    "FILES": "",
    "SEEALSO": "hb_langName(), hb_langSelect(), hb_Translate(), NationMsg(), REQUEST"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/langall.txt",
    "AUTHOR": "Copyright 2004 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "hb_Translate()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Language and Nation",
    "ONELINER": "Translate a string from one code page to the other",
    "SYNTAX": "hb_Translate( <cSrcText>, [<cPageFrom>], [<cPageTo>] ) --> cDstText",
    "ARGUMENTS": "<cSrcText> Is the source string to translate.\n\n<cPageFrom> Is the optional character code page ID of the source\nstring. If not specified, the default code page is used.\n\n<cPageTo> Is the optional character code page ID of the destination\nstring. If not specified, the default code page is used.",
    "RETURNS": "hb_Translate() return destination string converted from the source\nstring.",
    "DESCRIPTION": "hb_Translate() try to convert a source string from one code page\ninto the other. If a code page ID is not recognized, or not linked\nin, the default code page is used. hb_Translate() is used usually\nto convert between the MS-DOS and the Windows code pages of the\nsame language.\n\nNOTE: If the source code page and target code page does not have\nthe same number of characters, a translation cannot be done and\nthe destination string is a copy of the source string.\n\nNOTE: You must REQUEST every code page module you intend to use.\nFor example: to use the CP-850 code page you must add the\nfollowing to your program: `#include \"hbextcdp.ch\"`",
    "EXAMPLES": "#include \"hbextcdp.ch\"\nLOCAL cTxt := \"A\" + hb_BChar( 142 ) + \"BC\"\n? \"CP-850 text:\", hb_StrToHex( cTxt )\n? \"UTF-8 text:\", hb_Translate( cTxt, \"cp850\", \"UTF8\" )",
    "STATUS": "R",
    "COMPLIANCE": "This function is a Harbour Extension.",
    "PLATFORMS": "All",
    "FILES": "",
    "SEEALSO": "hb_langSelect(), hb_cdpSelect(), NationMsg(), REQUEST"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/left.txt",
    "AUTHOR": "2016 Pete D. <pete_westg@yahoo.gr>",
    "TEMPLATE": "Function",
    "NAME": "hb_LeftEq()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Checks if a sub-string matches to leftmost part of a string.",
    "SYNTAX": "hb_LeftEq( <cString>, <cSubString> ) --> lMatch",
    "ARGUMENTS": "<cString> Main string of comparison.\n\n<cSubString> Sub-string compared to leftmost part of <cString>",
    "RETURNS": "<lMatch> Boolean flag indicating if the matching was successful",
    "DESCRIPTION": "This function checks if all characters (one by one and with the given order)\nof <cSubString> match to leftmost (same length) part of <cString>\nor in other words, checks if <cString> starts with <cSubString>,\nin which case returns .T., otherwise .F.\n\nBasically it's equivalent to the expression:\n`Left( <cString>, Len( <cSubString> ) ) == <cSubString>`\nbut faster and shorter.\n\nNOTE: Case sensitive!",
    "EXAMPLES": "? hb_LeftEq( \"Harbour\", \"Ha\" )  // --> .T.\n? hb_LeftEq( \"Harbour\", \"ha\" )  // --> .F.",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "hb_LeftEqI(), Left(), At()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/left.txt",
    "AUTHOR": "2016 Pete D. <pete_westg@yahoo.gr>",
    "TEMPLATE": "Function",
    "NAME": "hb_LeftEqI()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Checks if a sub-string matches to leftmost part of a string.",
    "SYNTAX": "hb_LeftEqI( <cString>, <cSubString> ) --> lMatch",
    "ARGUMENTS": "<cString> Main string of comparison.\n\n<cSubString> Sub-string compared to leftmost part of <cString>.",
    "RETURNS": "<lMatch> Boolean flag indicating if the matching was successful.",
    "DESCRIPTION": "This function is identical to hb_LeftEq() (see above for details)\nbut it is case *insensitive*!",
    "EXAMPLES": "? hb_LeftEqI( \"Harbour\", \"HA\" )  // --> .T.\n? hb_LeftEqI( \"Harbour\", \"ha\" )  // --> .T.\n? hb_LeftEq( \"Harbour\", \"HA\" )   // --> .F.",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "hb_LeftEqI(), Left(), At()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/macro.txt",
    "TEMPLATE": "Document",
    "NAME": "Macro compiler",
    "CATEGORY": "Document",
    "SUBCATEGORY": "Compiler",
    "DESCRIPTION": "<b>Invoking the macro compiler:</b>\n```\n&variable\n```\nor\n```\n&( expression )\n```\nor\n```\n&variable.text\n```"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/macro.txt",
    "TEMPLATE": "Function",
    "NAME": "hb_SetMacro()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Macro",
    "ONELINER": "Enable/disable the macro compiler runtime features.",
    "SYNTAX": "hb_SetMacro( <nOption>, [<lOnOff>] ) --> lOldSetting",
    "ARGUMENTS": "<nOption> One of the `HB_SM_*` constants defined in set.ch.\n\n<lOnOff> .T. to enable or .F. to disable a feature",
    "RETURNS": "hb_SetMacro() return the old state of requested feature.",
    "DESCRIPTION": "This function enables or disables some features of the macro\ncompiler. The Harbour is extending the macro features compared\nto an original set available in CA-Cl*pper. Enabling/disabling\nsome of them allows to keep strict CA-Cl*pper compatibility.\n\nAvailable features are:\n\n`HB_SM_HARBOUR` - enables Harbour extensions:\n      operators: `++`, `--`, `+=`, `-=`, `*=`, `/=`, `^=`\n      objects: assignments to an instance variable\n\n`HB_SM_XBASE` - enables other Xbase++ dialects extensions:\n      expanding of expressions lists\n\n`HB_SM_SHORTCUTS` - enables optimized evaluation of\n      logical operators (`.AND.`, `.OR.`)\n\n`HB_SM_PREPROC` - enables preprocessing of commands\n      This is meaningful if Harbour is compiled with\n      HB_MACRO_STATEMENTS flag\n",
    "EXAMPLES": "#include \"hbmacro.ch\"\nINIT PROCEDURE IWANTCLIPPER()\n   ? hb_SetMacro( HB_SM_HARBOUR, .F. )\n   ? hb_SetMacro( HB_SM_XBASE, .F. )\n   RETURN",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Header file is set.ch\nLibrary is core",
    "SEEALSO": "Macro compiler"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Abs()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Math",
    "ONELINER": "Return the absolute value of a number.",
    "SYNTAX": "Abs( <nNumber> ) --> nAbsNumber",
    "ARGUMENTS": "<nNumber> Any number.",
    "RETURNS": "<nAbsNumber> The absolute numeric value.",
    "DESCRIPTION": "This function yields the absolute value of the numeric value or\nexpression <nNumber>.",
    "EXAMPLES": "LOCAL nNumber := 50\nLOCAL nNumber1 := 27\n\n? nNumber - nNumber1\n? nNumber1 - nNumber\n? Abs( nNumber - nNumber1 )\n? Abs( nNumber1 - nNumber )\n? Abs( -1 * 345 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Exp()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Math",
    "ONELINER": "Calculates the value of e raised to the passed power.",
    "SYNTAX": "Exp( <nNumber> ) --> nValue",
    "ARGUMENTS": "<nNumber> Any  real number.",
    "RETURNS": "<nValue>  The anti-logarithm of <nNumber>",
    "DESCRIPTION": "This function returns the value of e raised to the power of\n<nNumber>. It is the inverse of Log().",
    "EXAMPLES": "? Exp( 45 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Log()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Int()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Math",
    "ONELINER": "Return the integer port of a numeric value.",
    "SYNTAX": "Int( <nNumber> ) --> nIntNumber",
    "ARGUMENTS": "<nNumber> Any  numeric value.",
    "RETURNS": "<nIntNumber> The integer portion of the numeric value.",
    "DESCRIPTION": "This function converts a numeric expression to an integer. All\ndecimal digits are truncated. This function does not round a value\nupward or downward; it merely truncates a number at the decimal\npoint.",
    "EXAMPLES": "Set( _SET_DECIMALS, 5 )\n? Int( 632512.62541 )\n? Int( 845414111.91440 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Round(), StrZero()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Log()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Math",
    "ONELINER": "Returns the natural logarithm of a number.",
    "SYNTAX": "Log( <nNumber> ) --> nLog",
    "ARGUMENTS": "<nNumber> Any numeric expression.",
    "RETURNS": "<nExponent> The natural logarithm of <nNumber>.",
    "DESCRIPTION": "This function returns the natural logarithm of the number <nNumber>.\nIf <nNumber> is 0 or less than 0, a numeric overflow occurs,\nwhich is depicted on the display device as a series of asterisks.\nThis function is the inverse of Exp().",
    "EXAMPLES": "? Log( 632512 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Exp()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Max()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Math",
    "ONELINER": "Returns the maximum of two numbers or dates.",
    "SYNTAX": "Max( <xValue>, <xValue1> ) --> xMax",
    "ARGUMENTS": "<xValue>  Any date or numeric value.\n\n<xValue1> Any date or numeric value (same type as <xValue>).",
    "RETURNS": "<xMax> The larger numeric (or later date) value.",
    "DESCRIPTION": "This function returns the larger of the two passed expressions. If\n<xValue> and <xValue1> are numeric data types, the value returned by\nthis function will be a numeric data type as well and will be the\nlarger of the two numbers passed to it. If <xValue> and <xValue1>\nare date data types, the return value will be a date data type as\nwell. It will be the later of the two dates passed to it.",
    "EXAMPLES": "? Max( 214514214, 6251242142 )\n? Max( 0d20001111, 0d20140621 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Min()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Min()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Math",
    "ONELINER": "Determines the minimum of two numbers or dates.",
    "SYNTAX": "Min( <xValue>, <xValue1> ) --> xMin",
    "ARGUMENTS": "<xValue>  Any date or numeric value.\n\n<xValue1> Any date or numeric value.",
    "RETURNS": "<xMin>  The smaller numeric (or earlier date) value.",
    "DESCRIPTION": "This function returns the smaller of the two passed expressions.\n<xValue> and <xValue1> must be the same data type. If numeric, the\nsmaller number is returned. If dates, the earlier date is returned.",
    "EXAMPLES": "? Min( 214514214, 6251242142 )\n? Min( 0d20001111, 0d20140621 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Max()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "TEMPLATE": "Function",
    "NAME": "Mod()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Math",
    "ONELINER": "Return the modulus of two numbers.",
    "SYNTAX": "Mod( <nNumber>, <nNumber1> ) -->  <nRemainder>",
    "ARGUMENTS": "<nNumber>  Numerator in a divisional expression.\n\n<nNumber1> Denominator in a divisional expression.",
    "RETURNS": "<nRemainder>  The remainder after the division operation.",
    "DESCRIPTION": "This function returns the remainder of one number divided by\nanother.",
    "EXAMPLES": "? Mod( 12, 8.521 )\n? Mod( 12, 0 )\n? Mod( 62412.5142, 4522114.12014 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "%"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Sqrt()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Math",
    "ONELINER": "Calculates the square root of a number.",
    "SYNTAX": "Sqrt( <nNumber> ) --> nSqrt",
    "ARGUMENTS": "<nNumber> Any  numeric value.",
    "RETURNS": "<nSqrt>   The square root of <number>.",
    "DESCRIPTION": "This function returns the square root of <nNumber>. The precision\nof this evaluation is based solely on the setting of `_SET_DECIMALS`.\nAny negative number passed as <nNumber> will always return a 0.",
    "EXAMPLES": "Set( _SET_DECIMALS, 5 )\n? Sqrt( 632512.62541 )\n? Sqrt( 845414111.91440 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Round()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Round()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Math",
    "ONELINER": "Rounds off a numeric expression.",
    "SYNTAX": "Round( <nNumber>, <nPlace> ) --> nResult",
    "ARGUMENTS": "<nNumber> Any numeric value.\n\n<nPlace>  The number of places to round to.",
    "RETURNS": "<nResult> The rounded number.",
    "DESCRIPTION": "This function rounds off the value of <nNumber> to the number of\ndecimal places specified by <nPlace>. If the value of <nPlace> is\na negative number, the function will attempt to round <nNumber> in\nwhole numbers. Numbers from 5 through 9 will be rounded up, all\nothers will be rounded down.",
    "EXAMPLES": "? Round( 632512.62541, 5 )\n? Round( 845414111.91440, 3 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Int(), Str(), Val(), SET FIXED"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2001 IntTec GmbH, Martin Vogel <vogel@inttec.de>",
    "TEMPLATE": "C Function",
    "NAME": "hb_mathGetLastError()",
    "CATEGORY": "C level API",
    "SUBCATEGORY": "Math",
    "ONELINER": "get the last math lib error",
    "SYNTAX": "C Prototype\n\n#include \"hbmath.h\"\nhb_mathGetLastError( HB_MATH_EXCEPTION * phb_exc )\n                    --> int iMathErrorType",
    "ARGUMENTS": "phb_exc     pointer to HB_MATH_EXCEPTION structure, if not NULL,\n            the structure will be filled with information about the\n            last math error:\n```c\ntypedef struct _HB_MATH_EXCEPTION {\n  int type;        // Math error type, is one of the constants\n                   // HB_MATH_ERR_xxx defined in hbmath.ch\n  char *funcname;  // Pointer to name of the math C RTL routine\n                   // that caused the error.\n  char *error;     // Pointer to error description.\n  double arg1;     // First and\n  double arg2;     // Second double argument to the math routine.\n  double retval;   // Corrected return value for the math routine.\n  int retvalwidth; // Width and\n  int retvaldec;   // Decimals of the corrected return value,\n                   // both default to -1\n  int handled;     // 1, if the math error is already corrected,\n                   // 0 otherwise.\n} HB_MATH_EXCEPTION;\n```",
    "RETURNS": "<iMathErrorType>",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "NA",
    "FILES": "Header file is hbmath.h\nLibrary is core",
    "PLATFORMS": "All",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2001 IntTec GmbH, Martin Vogel <vogel@inttec.de>",
    "TEMPLATE": "C Function",
    "NAME": "hb_mathResetError()",
    "CATEGORY": "C level API",
    "SUBCATEGORY": "Math",
    "ONELINER": "Reset the internal math error information structure",
    "SYNTAX": "C Prototype\n\n#include \"hbmath.h\"\nhb_mathResetError( void )",
    "ARGUMENTS": "",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "NA",
    "FILES": "Header file is hbmath.h\nLibrary is core",
    "PLATFORMS": "All",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2001 IntTec GmbH, Martin Vogel <vogel@inttec.de>",
    "TEMPLATE": "C Function",
    "NAME": "hb_mathIsMathErr()",
    "CATEGORY": "C level API",
    "SUBCATEGORY": "Math",
    "ONELINER": "Check if Harbour math error handling is available",
    "SYNTAX": "C Prototype\n\n#include \"hbmath.h\"\nhb_mathIsMathErr( void ) --> int iIsMathHandler",
    "ARGUMENTS": "",
    "RETURNS": "<iIsMathHandler>",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "NA",
    "FILES": "Header file is hbmath.h\nLibrary is core",
    "PLATFORMS": "All",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2001 IntTec GmbH, Martin Vogel <vogel@inttec.de>",
    "TEMPLATE": "C Function",
    "NAME": "hb_mathSetHandler()",
    "CATEGORY": "C level API",
    "SUBCATEGORY": "Math",
    "ONELINER": "set the Harbour math handler",
    "SYNTAX": "C Prototype\n\n#include \"hbmath.h\"\nhb_mathSetHandler( HB_MATH_HANDLERPROC handlerproc )\n                  --> HB_MATH_HANDLERPROC previous_handerproc",
    "ARGUMENTS": "handlerproc             custom math handler\n        typedef int (* HB_MATH_HANDLERPROC)(HB_MATH_EXCEPTION * err)",
    "RETURNS": "previous_handlerproc    previous math handler\n        typedef int (* HB_MATH_HANDLERPROC)(HB_MATH_EXCEPTION * err)",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "NA",
    "FILES": "Header file is hbmath.h\nLibrary is core",
    "PLATFORMS": "All",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2001 IntTec GmbH, Martin Vogel <vogel@inttec.de>",
    "TEMPLATE": "C Function",
    "NAME": "hb_mathGetHandler()",
    "CATEGORY": "C level API",
    "SUBCATEGORY": "Math",
    "ONELINER": "get current Harbour math error handler",
    "SYNTAX": "C Prototype\n\n#include \"hbmath.h\"\nhb_mathGetHandler( void ) --> HB_MATH_HANDLERPROC handlerproc",
    "ARGUMENTS": "handlerproc             custom math handler\n        typedef int (* HB_MATH_HANDLERPROC)(HB_MATH_EXCEPTION * err)",
    "RETURNS": "<handerproc>",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "NA",
    "FILES": "Header file is hbmath.h\nLibrary is core",
    "PLATFORMS": "All",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2001 IntTec GmbH, Martin Vogel <vogel@inttec.de>",
    "TEMPLATE": "C Function",
    "NAME": "hb_mathSetErrMode()",
    "CATEGORY": "C level API",
    "SUBCATEGORY": "Math",
    "ONELINER": "set math error handling mode",
    "SYNTAX": "C Prototype\n\n#include \"hbmath.h\"\nhb_mathSetErrMode( int imode ) --> int ioldmode",
    "ARGUMENTS": "imode        math error handling mode, one of the following\n             constants, defined in hbmath.ch:\n<table-noheader>\nHB_MATH_ERRMODE_DEFAULT\nHB_MATH_ERRMODE_CDEFAULT\nHB_MATH_ERRMODE_USER\nHB_MATH_ERRMODE_USERDEFAULT\nHB_MATH_ERRMODE_USERCDEFAULT\n</table>",
    "RETURNS": "ioldmode     old math error handling mode",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "NA",
    "FILES": "Header file is hbmath.h\nLibrary is core",
    "PLATFORMS": "All",
    "SEEALSO": "hb_mathGetErrMode()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2001 IntTec GmbH, Martin Vogel <vogel@inttec.de>",
    "TEMPLATE": "C Function",
    "NAME": "hb_mathGetErrMode()",
    "CATEGORY": "C level API",
    "SUBCATEGORY": "Math",
    "ONELINER": "get math error handling mode",
    "SYNTAX": "C Prototype\n\n#include \"hbmath.h\"\nhb_mathGetErrMode( void ) --> imode",
    "ARGUMENTS": "",
    "RETURNS": "imode       math error handling mode",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "NA",
    "FILES": "Header file is hbmath.h\nLibrary is core",
    "PLATFORMS": "All",
    "SEEALSO": "hb_mathSetErrMode()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2001 IntTec GmbH, Martin Vogel <vogel@inttec.de>",
    "TEMPLATE": "Function",
    "NAME": "hb_matherMode()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Math",
    "ONELINER": "Set/Get math error handling mode",
    "SYNTAX": "hb_matherMode( [<nNewMode>] ) --> nOldMode",
    "ARGUMENTS": "[<nNumber>]   new math error handling mode, one of the following\n              constants, defined in hbmath.ch:\n<table-noheader>\nHB_MATH_ERRMODE_DEFAULT\nHB_MATH_ERRMODE_CDEFAULT\nHB_MATH_ERRMODE_USER\nHB_MATH_ERRMODE_USERDEFAULT\nHB_MATH_ERRMODE_USERCDEFAULT\n</table>",
    "RETURNS": "<nOldMode>    old math error handling mode",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "",
    "PLATFORMS": "All",
    "FILES": "Header file is hbmath.ch\nLibrary is core",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/math.txt",
    "AUTHOR": "Copyright 2001 IntTec GmbH, Martin Vogel <vogel@inttec.de>",
    "TEMPLATE": "Function",
    "NAME": "hb_matherBlock()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Math",
    "ONELINER": "Set/Get math error handling codeblock",
    "SYNTAX": "hb_matherBlock( [<bNewBlock>] ) --> bOldBlock",
    "ARGUMENTS": "<bNewBlock>",
    "RETURNS": "<bOldBlock> is the current error handler codeblock",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/memo.txt",
    "AUTHOR": "Copyright 1999 Jose Lalin <dezac@corevia.com>",
    "TEMPLATE": "Function",
    "NAME": "MemoTran()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Converts hard and soft carriage returns within strings.",
    "SYNTAX": "MemoTran( <cString>, <cHard>, <cSoft> ) --> cConvertedString",
    "ARGUMENTS": "<cString> is a string of chars to convert.\n\n<cHard> is the character to replace hard returns with. If not\nspecified defaults to semicolon.\n\n<cSoft> is the character to replace soft returns with. If not\nspecified defaults to single space.",
    "RETURNS": "<cConvertedString> Transformed string.",
    "DESCRIPTION": "Returns a string/memo with carriage return chars converted to\nspecified chars.",
    "EXAMPLES": "// FIXME\n? MemoTran( data->CNOTES )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "HardCR(), StrTran()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/memo.txt",
    "AUTHOR": "Copyright 1999 Jose Lalin <dezac@corevia.com>",
    "TEMPLATE": "Function",
    "NAME": "HardCR()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Replace all soft carriage returns with hard carriages returns.",
    "SYNTAX": "HardCR( <cString> ) --> cConvertedString",
    "ARGUMENTS": "<cString> is a string of chars to convert.",
    "RETURNS": "<cConvertedString> Transformed string.",
    "DESCRIPTION": "Returns a string/memo with soft carriage return chars converted to\nhard carriage return chars.",
    "EXAMPLES": "// FIXME\n? HardCR( data->CNOTES )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "MemoTran(), StrTran()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/memo.txt",
    "AUTHOR": "Copyright 2003 Alejandro de Garate <alex_degarate@hotmail.com>",
    "TEMPLATE": "Function",
    "NAME": "MemoRead()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Return the text file's contents as a character string",
    "SYNTAX": "MemoRead( <cFileName> ) --> cString",
    "ARGUMENTS": "<cFileName> is the file name to read from disk.\n            It must include the file extension. If file to be read\n            lives in another directory, you must include the path.",
    "RETURNS": "Returns the contents of a text file as a character string.\n\nIf <cFileName> cannot be found or read MemoRead() returns an empty\nstring (\"\").",
    "DESCRIPTION": "MemoRead() is a function that reads the content of a text file (till\nnow) from disk (floppy, HDD, CD-ROM, etc.) into a memory string.\nIn that way you can manipulate as any character string or assigned\nto a memo field to be saved in a database.\n\nMemoRead() function is used together with MemoEdit() and MemoWrit()\nto get from disk text from several sources that would be edited,\nsearched, replaced, displayed, etc.\n\nIt is used to import data from other sources to our database.\n\nNote:\nMemoRead() does not use the settings SET DEFAULT or SET PATH to\nsearch for <cFileName>.\nIt searches for <cFileName> in the current directory.\n\nOver a network, MemoRead() attempts to open <cFileName> in read-only\nmode and shared.  If the file is used in mode exclusive by another\nprocess, the function will returns a null string (\"\").",
    "EXAMPLES": "// This example uses MemoRead() to assign the contents of a text\n// file to a character variable for later search\n\nLOCAL cFile := \"account.prg\"\nLOCAL cString := MemoRead( cFile )\nLOCAL cCopyright := \"Melina\"\n\nIF ! cCopyright $ cString                     // check for copyright\n   ? MemoWrit( cFile, cCopyright + cString )  // if not, add it!\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "MemoEdit(), MemoWrit(), REPLACE, hb_MemoRead()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/memo.txt",
    "AUTHOR": "Copyright 2003 Alejandro de Garate <alex_degarate@hotmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_MemoRead()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Return the text file's contents as a character string",
    "SYNTAX": "hb_MemoRead( <cFileName> ) --> cString",
    "ARGUMENTS": "<cFileName> is the file name to read from disk.\n            It must include the file extension. If file to be read\n            lives in another directory, you must include the path.",
    "RETURNS": "Returns the contents of a text file as a character string.\n\nIf <cFileName> cannot be found or read hb_MemoRead() returns an empty\nstring (\"\").",
    "DESCRIPTION": "hb_MemoRead() is a function that reads the content of a text file\n(till now) from disk (floppy, HDD, CD-ROM, etc.) into a memory string.\nIn that way you can manipulate as any character string or assigned\nto a memo field to be saved in a database.\n\nhb_MemoRead() function is used together with MemoEdit() and hb_MemoWrit()\nto get from disk text from several sources that would be edited,\nsearched, replaced, displayed, etc.\n\nIt is used to import data from other sources to our database.\n\nNote:\nhb_MemoRead() does not use the settings SET DEFAULT or SET PATH to\nsearch for <cFileName>.\nIt searches for <cFileName> in the current directory.\n\nOver a network, hb_MemoRead() attempts to open <cFileName> in read-only\nmode and shared.  If the file is used in mode exclusive by another\nprocess, the function will returns a null string (\"\").\n\nhb_MemoRead() vs MemoRead():\nhb_MemoRead() is identical to MemoRead() except it won't truncate the\nlast byte (on non-Unix compatible systems) if it's a EOF char.",
    "EXAMPLES": "// This example uses hb_MemoRead() to assign the contents of a text\n// file to a character variable for later search\n\nLOCAL cFile := \"account.prg\"\nLOCAL cString := hb_MemoRead( cFile )\nLOCAL cCopyright := \"Melina\"\n\nIF ! cCopyright $ cString                        // check for copyright\n   ? hb_MemoWrit( cFile, cCopyright + cString )  // if not, add it!\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "MemoEdit(), hb_MemoWrit(), REPLACE, MemoRead()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/memo.txt",
    "AUTHOR": "Copyright 2003 Alejandro de Garate <alex_degarate@hotmail.com>",
    "TEMPLATE": "Function",
    "NAME": "MemoWrit()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Write a memo field or character string to a text file on disk",
    "SYNTAX": "MemoWrit( <cFileName>, <cString> ) --> lSuccess",
    "ARGUMENTS": "<cFileName> is the file name to be written to disk.\n            It must include the file extension. If file to be read\n            lives in another directory, you must include the path.\n\n<cString>   Is the memo field or character string, to be write to\n            <cFile>.",
    "RETURNS": "Function returns true (.T.) if the writing operation was successful;\notherwise, it returns false (.F.).",
    "DESCRIPTION": "This a function that writes a memo field or character string to a\ntext file on disk (floppy, HDD, CD-ROM, etc.)\nIf you not specified a path, MemoWrit() writes <cFileName> to the\ncurrent directory. If <cFileName> exists, it is overwritten.\n\nMemoWrit() function is used together with MemoRead() and MemoEdit()\nto save to disk text from several sources that was edited, searched,\nreplaced, displayed, etc.\n\nNote that MemoWrit() do not use the directory settings SET DEFAULT.",
    "EXAMPLES": "//  This example uses MemoWrit() to write the contents of a character\n// variable to a text file.\n\nLOCAL cFile := \"account.prg\"\nLOCAL cString := MemoRead( cFile )\nLOCAL cCopyright := \"Melina\"\n\nIF ! cCopyright $ cString                     // check for copyright\n   ? MemoWrit( cFile, cCopyright + cString )  // if not, add it!\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "MemoEdit(), MemoRead(), hb_MemoWrit()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/memo.txt",
    "AUTHOR": "Copyright 2003 Alejandro de Garate <alex_degarate@hotmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_MemoWrit()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Write a memo field or character string to a text file on disk",
    "SYNTAX": "hb_MemoWrit( <cFileName>, <cString> ) --> lSuccess",
    "ARGUMENTS": "<cFileName> is the file name to be written to disk.\n            It must include the file extension. If file to be read\n            lives in another directory, you must include the path.\n\n<cString>   Is the memo field or character string, to be write to\n            <cFile>.",
    "RETURNS": "Function returns true (.T.) if the writing operation was successful;\notherwise, it returns false (.F.).",
    "DESCRIPTION": "This a function that writes a memo field or character string to a\ntext file on disk (floppy, HDD, CD-ROM, etc.)\nIf you not specified a path, hb_MemoWrit() writes <cFileName> to the\ncurrent directory. If <cFileName> exists, it is overwritten.\n\nhb_MemoWrit() function is used together with hb_MemoRead() and\nMemoEdit() to save to disk text from several sources that was edited,\nsearched, replaced, displayed, etc.\n\nNote that hb_MemoWrit() do not use the directory settings SET DEFAULT.\n\nhb_MemoWrit() vs MemoWrit():\nhb_MemoWrit() never writes the obsolete EOF char at the end of the file.",
    "EXAMPLES": "//  This example uses hb_MemoWrit() to write the contents of a character\n//  variable to a text file.\n\nLOCAL cFile := \"account.prg\"\nLOCAL cString := hb_MemoRead( cFile )\nLOCAL cCopyright := \"Melina\"\n\nIF ! cCopyright $ cString                        // check for copyright\n   ? hb_MemoWrit( cFile, cCopyright + cString )  // if not, add it!\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "MemoEdit(), MemoRead(), hb_MemoWrit()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/memvar.txt",
    "TEMPLATE": "Statement",
    "NAME": "FIELD",
    "CATEGORY": "Statement",
    "SUBCATEGORY": "RDD",
    "ONELINER": "Declares a list of database field names.",
    "SYNTAX": "FIELD <xField> [, <xFieldn...> [IN <cDatabase>]",
    "ARGUMENTS": "<xField>    A valid field name\n\n<xFieldn>   Additional field name\n\n<cDatabase> An valid alias name",
    "DESCRIPTION": "This command declares the names of fields <xField> (and <xFieldn> and\nfollowing) with an optional alias identifier as <cDatabase> for each.\nThis command allow  Harbour to resolve any reference to a field\nspecified in the field list by viewing it as a field when it is not\nreferenced by an alias. If a field is not listed in this list and it\nis not  explicitly tagged with an alias identifier, it may be viewed\nas a memory variable, which may cause run-time errors. This command\nhas no effect on memory variables or on field reference buried within\na macro expression.",
    "EXAMPLES": "FIELD first\nFIELD age\nUSE test NEW\nfirst := \"FirstName\"\nage := 25",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "None.",
    "SEEALSO": "MEMVAR, PRIVATE, PUBLIC, STATIC"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/memvar.txt",
    "TEMPLATE": "Statement",
    "NAME": "LOCAL",
    "CATEGORY": "Statement",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "Initializes a local memory variable or array",
    "SYNTAX": "LOCAL <xVar> [:= <xInit> ]",
    "ARGUMENTS": "<xVar>    Name of a memory variable or array.\n\n<xInit>   Value to be assigned to a variable or array",
    "DESCRIPTION": "This command created a LOCAL memory variable or array. The name\nof either is specified in <xVar>. If more then one variable is being\ninitialized with the LOCAL command, separate each entry with a comma.\nIf a variable or an array is to be assigned a start-up value, that\nexpression may be specified in <xInit> and following. Is Strong type\ncompile mode is used, the Compiler will check if the value received\nmatches the type specified in <xType>.\n\nLOCAL variables are symbols generated at run time and are resolved\nat compile time. The visibility and life span of a LOCAL variable or\narray is limited to the function or procedure in which it is defined.\n\nNo macro expansions are allowed in the LOCAL declaration statement.\n\nNo Harbour command other then FUNCTION, PROCEDURE, PUBLIC, PRIVATE,\nPARAMETERS, MEMVAR, STATIC and FIELD, may precede the LOCAL command.\n\nLOCAL array reference may not be initialized (i.e., assigned values)\non the same command-line as the LOCAL command statement. This can be\ndone later in the program.\n\nLOCAL variables and arrays are not affected by the RELEASE command.",
    "EXAMPLES": "LOCAL n, lVar := .T.\n\nn := iif( lVar, \"A\", 3 )\nn := 2\nn := \"a\"\nn := Seconds() + 2\nn := Int( Seconds() + 2 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "None",
    "SEEALSO": "FIELD, PRIVATE, PUBLIC, STATIC, MEMVAR"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/memvar.txt",
    "TEMPLATE": "Statement",
    "NAME": "MEMVAR",
    "CATEGORY": "Statement",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "Declares private and public variables and arrays.",
    "SYNTAX": "MEMVAR <xVar>",
    "ARGUMENTS": "<xVar> Memory variable Name",
    "DESCRIPTION": "This command tells the compiler to resolve any reference to a memory\nvariable designated within this list s if it possessed an explicit\nmemory variable alias with either the `M->` or `MEMVAR->` prefix. Only\nthose memory variables that do not contain any such explicit are\naffected by this command. Those memory variables within macro\nexpansions are not affected by this command.\n\nThe MEMVAR declaration must appear before any executable commands; it\nis similar to the LOCAL, STATIC, FIELD, PARAMETERS, FUNCTION, and\nPROCEDURE commands statements.",
    "EXAMPLES": "MEMVAR y AS NUMERIC\n\nLOCAL n, lVar := .T.\n\nn := iif( lVar, \"A\", 3 )\nn := 2\nn := \"a\"\nn := Seconds() + 2\nn := Int( Seconds() + 2 )\ny := n\n\n? y",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "None.",
    "SEEALSO": "LOCAL, STATIC, FIELD, PRIVATE, PUBLIC"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/menu.txt",
    "TEMPLATE": "Function",
    "NAME": "AChoice()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Allows selection of an element from an array",
    "SYNTAX": "AChoice( <nTop>, <nLeft>, <nBottom>, <nRight>, <acMenuItems>, [<alSelableItems> | <lSelableItems>], [<cUserFunction> | <bUserBlock>], [<nInitialItem>], [<nWindowRow>] ) --> nPosition",
    "ARGUMENTS": "<nTop>           - topmost row used to display array (default 0)\n\n<nLeft>          - leftmost row used to display array (default 0)\n\n<nBottom>        - bottommost row used to display array (default MaxRow())\n\n<nRight>         - rightmost row used to display array (default MaxCol())\n\n<acMenuItems>    - the character array of items from which to select\n\n<alSelableItems> - an array of items, either logical or character,\n                   which is used to determine if a particular item\n                   may be selected.  If the type of a given item is\n                   character, it is macro evaluated, and the result\n                   is expected to be a logical.  A value of .T. means\n                   that the item may be selected, .F. that it may not.\n                   (See next argument: `lSelectableItems`)\n\n<lSelableItems>  - a logical value which is used to apply to all\n                   items in `acMenuItems`.  If .T., all items may be\n                   selected; if .F., none may be selected.\n                   (See previous argument: `alSelectableItems`)\n                   Default .T.\n\n<cUserFunction>  - the name of a function to be called which may\n                   affect special processing of keystrokes.  It is\n                   specified without parentheses or parameters.\n                   When it is called, it will be supplied with the\n                   parameters: `nMode`, `nCurElement`, and `nRowPos`.\n                   Default NIL.\n\n<bUserBlock>     - a codeblock to be called which may\n                   affect special processing of keystrokes. It\n                   should be specified in the form\n                   `{| nMode, nCurElemenet, nRowPos | MyFunc( nMode, nCurElemenet, nRowPos ) }`.\n                   Default NIL.\n\n<nInitialItem>   - the number of the element to be highlighted as\n                   the current item when the array is initially\n                   displayed.  1 origin.  Default 1.\n\n<nWindowRow>     - the number of the window row on which the initial\n                   item is to be displayed. 0 origin.  Default 0.",
    "RETURNS": "<nPosition>  - the number of the item to be selected, or 0 if the\nselection was aborted.",
    "DESCRIPTION": "Allows selection of an element from an array.\nPlease see standard CA-Cl*pper documentation for AChoice() for\nadditional detail.",
    "EXAMPLES": "LOCAL aItems := { \"One\", \"Two\", \"Three\" }\nLOCAL nChoice := AChoice( 10, 10, 20, 20, aItems )\nIF nChoice == 0\n   ? \"You did not choose an item\"\nELSE\n   ? ;\n      \"You chose element\", hb_ntos( nChoice ), ;\n      \"which has a value of\", aItems[ nChoice ]\nENDIF",
    "FILES": "Library is core",
    "COMPLIANCE": "C",
    "SEEALSO": "MENU TO"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/menu.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__AtPrompt()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Display a menu item on screen and define a message",
    "SYNTAX": "__AtPrompt( <nRow>, <nCol>, <cPrompt>, [<xMsg>] ) --> .F.",
    "ARGUMENTS": "<nRow> is the row number to display the menu <cPrompt>. Value could\nrange from zero to MaxRow().\n\n<nCol> is the column number to display the menu <cPrompt>. Value\ncould range from zero to MaxCol().\n\n<cPrompt> is the menu item character string to display.\n\n<xMsg> define a message to display each time this menu item is\nhighlighted. <xMsg> could be a character string or code block that\nis evaluated to a character string. If <xMsg> is not specified or\nof the wrong type, an empty string (\"\") would be used.",
    "RETURNS": "__AtPrompt() always return .F.",
    "DESCRIPTION": "With __AtPrompt() you define and display a menu item, each call to\n__AtPrompt() add another item to the menu, to start the menu itself\nyou should call the __MenuTo() function (`MENU TO` command). You can\ndefine any row and column combination and they will be displayed at\nthe order of definition. After each call to __AtPrompt(), the cursor\nis placed one column to the right of the last text displayed, and\nRow() and Col() are updated.\n\n`@...PROMPT` command is preprocessed into __AtPrompt() function during\ncompile time.",
    "EXAMPLES": "LOCAL nChoice\n// display a two line menu with status line at the bottom\n// let the user select favorite day\nSET MESSAGE TO 24 CENTER\n@ 10, 2 PROMPT \"Sunday\" MESSAGE \"This is the 1st item\"\n@ 11, 2 PROMPT \"Monday\" MESSAGE \"Now we're on the 2nd item\"\nMENU TO nChoice\nDO CASE\nCASE nChoice == 0           // user press <Esc> key\n   QUIT\nCASE nChoice == 1           // user select 1st menu item\n   ? \"Guess you don't like Mondays\"\nCASE nChoice == 2           // user select 2nd menu item\n   ? \"Just another day for some\"\nENDCASE",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "AChoice(), MENU TO, SET MESSAGE, SET INTENSITY, SET WRAP, __MenuTo()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/menu.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Command",
    "NAME": "@...PROMPT",
    "CATEGORY": "Command",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Display a menu item on screen and define a message",
    "SYNTAX": "@ <nRow>, <nCol> PROMPT <cPrompt> [MESSAGE <xMsg>]",
    "ARGUMENTS": "<nRow> is the row number to display the menu <cPrompt>. Value could\nrange from zero to MaxRow().\n\n<nCol> is the column number to display the menu <cPrompt>. Value\ncould range from zero to MaxCol().\n\n<cPrompt> is the menu item character string to display.\n\n<xMsg> define a message to display each time this menu item is\nhighlighted. <xMsg> could be a character string or code block that\nis evaluated to a character string. If <xMsg> is not specified or\nof the wrong type, an empty string (\"\") would be used.",
    "DESCRIPTION": "With `@...PROMPT` you define and display a menu item, each call to\n`@...PROMPT` add another item to the menu, to start the menu itself\nyou should call the __MenuTo() function (`MENU TO` command). You can\ndefine any row and column combination and they will be displayed at\nthe order of definition. After each call to `@...PROMPT`, the cursor\nis placed one column to the right of the last text displayed, and\nRow() and Col() are updated.\n\n`@...PROMPT` command is preprocessed into __AtPrompt() function during\ncompile time.",
    "EXAMPLES": "LOCAL nChoice\n// display a two line menu with status line at the bottom\n// let the user select favorite day\nSET MESSAGE TO 24 CENTER\n@ 10, 2 PROMPT \"Sunday\" MESSAGE \"This is the 1st item\"\n@ 11, 2 PROMPT \"Monday\" MESSAGE \"Now we're on the 2nd item\"\nMENU TO nChoice\nDO CASE\nCASE nChoice == 0           // user press <Esc> key\n   QUIT\nCASE nChoice == 1           // user select 1st menu item\n   ? \"Guess you don't like Mondays\"\nCASE nChoice == 2           // user select 2nd menu item\n   ? \"Just another day for some\"\nENDCASE",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "AChoice(), MENU TO, SET MESSAGE, SET INTENSITY, SET WRAP, __MenuTo()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/menu.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__MenuTo()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Invoked a menu defined by set of `@...PROMPT`",
    "SYNTAX": "__MenuTo( <bBlock>, <cVariable> ) --> nChoice",
    "ARGUMENTS": "<bBlock> is a set/get code block for variable named <cVariable>.\n\n<cVariable> is a character string that contain the name of the\nvariable to hold the menu choices, if this variable does not exist\na PRIVATE variable with the name <cVariable> would be created to\nhold the result.",
    "RETURNS": "__MenuTo() return the number of select menu item, or 0 if there was\nno item to select from or if the user pressed the <Esc> key.",
    "DESCRIPTION": "__MenuTo() invoked the menu define by previous __AtPrompt() call\nand display a highlight bar that the user can move to select an\noption from the menu. If <cVariable> does not exist or not visible,\na PRIVATE variable named <cVariable> is created and hold the current\nmenu selection. If there is a variable named <cVariable>, its value\nis used to select the first highlighted item.\n\nMenu prompts and messages are displayed in current Standard color,\nhighlighted bar is displayed using current Enhanced color.\n\nPressing the arrow keys move the highlighted bar. When a menu item\nis highlighted the message associated with it is displayed on the\nline specified with `SET MESSAGE`. If `SET WRAP` is ON and the user\npress <up> arrow while on the first selection the last menu item is\nhighlighted, if the user press <Down> arrow while on the last item,\nthe first item is highlighted.\n\nFollowing are active keys that handled by __MenuTo():\n\n<table>\n key            Meaning\n\n Up             Move to previous item\n Down           Move to next item\n Left           Move to previous item\n Right          Move to next item\n Home           Move to the first item\n End            Move to the last item\n PgUp           Select menu item, return position\n PgDn           Select menu item, return position\n Enter          Select menu item, return position\n Esc            Abort selection, return 0\n First letter   Select next menu with the same first letter,\n                return this item position.\n</table>\nupon exit the cursor is placed at MaxRow() - 1, 0\n__MenuTo() can be nested without loosing the previous prompts.\n\n`MENU TO` command is preprocessed into __MenuTo() function during\ncompile time.",
    "EXAMPLES": "LOCAL nChoice\n// display menu item on each screen corner and let user select one\nCLS\nSET MESSAGE TO MaxRow() / 2 CENTER\nSET WRAP ON\n@ 0           , 0             PROMPT \"1. Upper left\"   MESSAGE \" One \"\n@ 0           , MaxCol() - 16 PROMPT \"2. Upper right\"  MESSAGE \" Two \"\n@ MaxRow() - 1, MaxCol() - 16 PROMPT \"3. Bottom right\" MESSAGE \"Three\"\n@ MaxRow() - 1, 0             PROMPT \"4. Bottom left\"  MESSAGE \"Four \"\nMENU TO nChoice\nSetPos( MaxRow() / 2, MaxCol() / 2 - 10 )\nIF nChoice == 0\n   ?? \"<Esc> was pressed\"\nELSE\n   ?? \"Selected option is\", nChoice\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "@...PROMPT, AChoice(), SET MESSAGE, SET INTENSITY, SET WRAP, __AtPrompt()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/menu.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Command",
    "NAME": "MENU TO",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Invoked a menu defined by set of `@...PROMPT`",
    "SYNTAX": "MENU TO <cVariable>",
    "ARGUMENTS": "<cVariable> is a character string that contain the name of the\nvariable to hold the menu choices, if this variable does not exist\na PRIVATE variable with the name <cVariable> would be created to\nhold the result.",
    "DESCRIPTION": "`MENU TO` invoked the menu define by previous __AtPrompt() call\nand display a highlight bar that the user can move to select an\noption from the menu. If <cVariable> does not exist or not visible,\na PRIVATE variable named <cVariable> is created and hold the current\nmenu selection. If there is a variable named <cVariable>, its value\nis used to select the first highlighted item.\n\nMenu prompts and messages are displayed in current Standard color,\nhighlighted bar is displayed using current Enhanced color.\n\nPressing the arrow keys move the highlighted bar. When a menu item\nis highlighted the message associated with it is displayed on the\nline specified with `SET MESSAGE`. If `SET WRAP` is ON and the user\npress <Up> arrow while on the first selection the last menu item is\nhighlighted, if the user press <Down> arrow while on the last item,\nthe first item is highlighted.\n\nFollowing are active keys that handled by `MENU TO`:\n\n<table>\n key            Meaning\n\n Up             Move to previous item\n Down           Move to next item\n Left           Move to previous item\n Right          Move to next item\n Home           Move to the first item\n End            Move to the last item\n PgUp           Select menu item, return position\n PgDn           Select menu item, return position\n Enter          Select menu item, return position\n Esc            Abort selection, return 0\n First letter   Select next menu with the same first letter,\n                return this item position.\n</table>\nupon exit the cursor is placed at MaxRow() - 1, 0\n`MENU TO` can be nested without loosing the previous prompts.\n\n`MENU TO` command is preprocessed into __MenuTo() function during\ncompile time.",
    "EXAMPLES": "LOCAL nChoice\n// display menu item on each screen corner and let user select one\nCLS\nSET MESSAGE TO MaxRow() / 2 CENTER\nSET WRAP ON\n@ 0           , 0             PROMPT \"1. Upper left\"   MESSAGE \" One \"\n@ 0           , MaxCol() - 16 PROMPT \"2. Upper right\"  MESSAGE \" Two \"\n@ MaxRow() - 1, MaxCol() - 16 PROMPT \"3. Bottom right\" MESSAGE \"Three\"\n@ MaxRow() - 1, 0             PROMPT \"4. Bottom left\"  MESSAGE \"Four \"\nMENU TO nChoice\nSetPos( MaxRow() / 2, MaxCol() / 2 - 10 )\nIF nChoice == 0\n   ?? \"<Esc> was pressed\"\nELSE\n   ?? \"Selected option is\", nChoice\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "@...PROMPT, AChoice(), SET MESSAGE, SET INTENSITY, SET WRAP, __AtPrompt()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/misc.txt",
    "TEMPLATE": "Function",
    "NAME": "OS()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Return the current operating system.",
    "SYNTAX": "OS() --> cOperatingSystem",
    "RETURNS": "<cOperatinSystem> The current operating system.",
    "DESCRIPTION": "This function will return the current operating system.",
    "EXAMPLES": "? OS()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/misc.txt",
    "TEMPLATE": "Function",
    "NAME": "Version()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Returns the version of Harbour compiler",
    "SYNTAX": "Version() --> cReturn",
    "ARGUMENTS": "None",
    "RETURNS": "<cReturn>   String containing the Harbour version",
    "DESCRIPTION": "This function returns the current Harbour version.",
    "EXAMPLES": "? Version()",
    "STATUS": "S",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "OS()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/misc.txt",
    "TEMPLATE": "Function",
    "NAME": "GetEnv()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Obtains a system environmental setting.",
    "SYNTAX": "GetEnv( <cEnviroment> ) --> cReturn",
    "ARGUMENTS": "<cEnviroment> Environmental variable to obtain.",
    "RETURNS": "<cReturn>     Value of the Environment Variable.",
    "DESCRIPTION": "This function yields a string that is the value of the\nenvironment variable <cEnviroment>, which is stored at the\nsystem-level.\n\nIf no environment variable\nis found, an empty string is returned.",
    "EXAMPLES": "? GetEnv( \"PATH\" )\n? GetEnv( \"CONFIG\" )\n? GetEnv( \"HARBOURCMD\", \"-n -l -es2\" )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "GetE()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/misc.txt",
    "TEMPLATE": "Function",
    "NAME": "GetE()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Obtains a system environmental setting.",
    "SYNTAX": "GetE( <cEnviroment> ) --> cReturn",
    "ARGUMENTS": "<cEnviroment> Environmental variable to obtain.",
    "RETURNS": "<cReturn>     Value of the Environment Variable.",
    "DESCRIPTION": "This function yields a string that is the value of the\nenvironment variable <cEnviroment>, which is stored at the\nsystem-level.\n\nIf no environment variable\nis found, an empty string is returned.",
    "EXAMPLES": "? GetE( \"PATH\" )\n? GetE( \"CONFIG\" )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "GetEnv()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/misc.txt",
    "TEMPLATE": "Function",
    "NAME": "hb_GetEnv()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Obtains a system environmental setting.",
    "SYNTAX": "hb_GetEnv( <cEnviroment>, [<cDefaultValue>] ) --> cReturn",
    "ARGUMENTS": "<cEnviroment> Environmental variable to obtain.\n\n<cDefaultValue> Optional value to return if <cEnvironment> is not found.",
    "RETURNS": "<cReturn>     Value of the environment variable or <cDefaultValue> or an empty string.",
    "DESCRIPTION": "This function yields a string that is the value of the\nenvironment variable <cEnviroment>, which is stored at the\nsystem-level.\n\nIf no environment variable\ncan be found, the value of the function will be <cDefaultValue>\nif it is passed, else an empty string.",
    "EXAMPLES": "? hb_GetEnv( \"PATH\" )\n? hb_GetEnv( \"CONFIG\" )\n? hb_GetEnv( \"HARBOURCMD\", \"-n -l -es2\" )",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "GetEnv(), GetE()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/misc.txt",
    "TEMPLATE": "Procedure",
    "NAME": "__Run()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Run an external program.",
    "SYNTAX": "__Run( <cCommand> )",
    "ARGUMENTS": "<cCommand> Command to execute.",
    "DESCRIPTION": "This command runs an external program. Ensure that\nyou have enough free memory to be able to run the external\nprogram. Do not use it to run 'Terminate and Stay Resident' programs\n(in case of MS-DOS) since that causes several problems.\n\nNote: This function is what the RUN command preprocesses into.\n      It is considered bad form to use this function directly.\n      Use the RUN command instead.",
    "EXAMPLES": "__Run( \"edit \" + cMyTextFile )    // Runs an external editor\n__Run( \"command\" )                // Gives a OS shell",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "RUN, hb_run()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/misc.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "Tone()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Sound a tone with a specified frequency and duration.",
    "SYNTAX": "Tone( <nFrequency>, <nDuration> ) --> NIL",
    "ARGUMENTS": "<nFrequency>  A non-negative numeric value that specifies the\nfrequency of the tone in hertz.\n\n<nDuration>   A positive numeric value which specifies the duration\nof the tone in 1/18 of a second units.",
    "RETURNS": "Tone() always returns NIL.",
    "DESCRIPTION": "Tone() is a sound function that could be used to irritate the end\nuser, his or her dog, and the surrounding neighborhood. The frequency\nis limited to the range 0 to 32767 Hz.",
    "EXAMPLES": "// Good sound\nTone(  500, 1 )\nTone( 4000, 1 )\nTone( 2500, 1 )\n\n// Bad sound\nTone(  300, 1 )\nTone(  499, 5 )\nTone(  700, 5 )\n\nTone( 800, 1 )      // same as hb_BChar( 7 )\nTone( 32000, 200 )  // any dogs around yet?\nTone( 130.80, 1 )   // musical note - C\nTone( 400, 0 )      // short beep\nTone( 700 )         // short beep\nTone( 10, 18.2 )    // 1 second delay\nTone( -1 )          // 1/18.2 second delay\nTone()              // 1/18.2 second delay",
    "STATUS": "S",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Chr(), SET BELL"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/misc.txt",
    "TEMPLATE": "Command",
    "NAME": "RUN",
    "CATEGORY": "API",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Run an external program.",
    "SYNTAX": "RUN <cCommand>",
    "ARGUMENTS": "<cCommand> Command to execute.",
    "DESCRIPTION": "This command runs an external program. Please make sure that you have\nenough free memory to be able to run the external program.\nDo not use it to run Terminate and Stay Resident programs\n(in case of DOS) since that causes several problems.",
    "EXAMPLES": "RUN ( \"edit \" + cMyTextFile )  // Runs an external editor\nRUN command                    // Gives a OS shell",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "RUN"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/natmsg.txt",
    "AUTHOR": "Copyright 1999 Jose Lalin <dezac@corevia.com>",
    "TEMPLATE": "Function",
    "NAME": "IsAffirm()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Language and Nation",
    "ONELINER": "Checks if passed char is an affirmation char",
    "SYNTAX": "IsAffirm( <cChar> ) --> lTrueOrFalse",
    "ARGUMENTS": "<cChar> is a char or string of chars",
    "RETURNS": "<lTrueOrFalse> True if passed char is an affirmation char, otherwise\nfalse",
    "DESCRIPTION": "This function is used to check if a user's input is true or not\naccording to the msgxxx module used.",
    "EXAMPLES": "// Wait until user enters Y\nDO WHILE ! IsAffirm( cYesNo )\n   ACCEPT \"Sure: \" TO cYesNo\nENDDO",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "IsNegative(), NationMsg()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/natmsg.txt",
    "AUTHOR": "Copyright 1999 Jose Lalin <dezac@corevia.com>",
    "TEMPLATE": "Function",
    "NAME": "IsNegative()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Language and Nation",
    "ONELINER": "Checks if passed char is a negation char.",
    "SYNTAX": "IsNegative( <cChar> ) --> lTrueOrFalse",
    "ARGUMENTS": "<cChar> is a char or string of chars",
    "RETURNS": "<lTrueOrFalse> True if passed char is a negation char, otherwise\nfalse.",
    "DESCRIPTION": "This function is used to check if a user's input is true or not\naccording to the msgxxx module used.",
    "EXAMPLES": "// Wait until user enters N\nDO WHILE ! IsNegative( cYesNo )\n   ACCEPT \"Sure: \" TO cYesNo\nENDDO",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "IsAffirm(), NationMsg()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/natmsg.txt",
    "AUTHOR": "Copyright 1999 Jose Lalin <dezac@corevia.com>",
    "TEMPLATE": "Function",
    "NAME": "NationMsg()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Language and Nation",
    "ONELINER": "Returns international strings messages.",
    "SYNTAX": "NationMsg( <nMsg> ) --> cMessage",
    "ARGUMENTS": "<nMsg> is the message number you want to get.",
    "RETURNS": "<cMessage> if <nMsg> is a valid message selector, returns the message.\nIf <nMsg> is NIL, it returns \"Invalid Argument\", and if <nMsg> is any\nother type it returns an empty string.",
    "DESCRIPTION": "NationMsg() returns international message descriptions.",
    "EXAMPLES": "// Displays \"Sure Y/N: \"  and waits until user enters Y\n// Y/N is the string for NationMsg( 12 ) with default natmsg module.\nDO WHILE ! IsAffirm( cYesNo )\n   ACCEPT \"Sure \" + NationMsg( 12 ) + \": \" TO cYesNo\nENDDO",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "IsAffirm(), IsNegative()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/objfunc.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__objHasData()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Objects",
    "ONELINER": "Determine whether a symbol exist in object as VAR",
    "SYNTAX": "__objHasData( <oObject>, <cSymbol> ) --> lExist",
    "ARGUMENTS": "<oObject> is an object to scan.\n\n<cSymbol> is the name of the symbol to look for.",
    "RETURNS": "__objHasData() return .T. if the given <cSymbol> exist as VAR\n(instance variable) in object <oObject), .F. if it does not exist.",
    "DESCRIPTION": "__objHasData() is a low-level class support function that let you\nfind out if a symbol is an instance variable in a given object.",
    "EXAMPLES": "LOCAL oB := TBrowseNew( 0, 0, 24, 79 )\n? __objHasData( oB, \"nLeft\" )     // --> .T.\n? __objHasData( oB, \"lBugFree\" )  // --> .F.\n? __objHasData( oB, \"Left\" )      // --> .F. since this is a METHOD",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "__objGetMethodList(), __objGetMsgList(), __objHasMethod()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/objfunc.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__objHasMethod()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Objects",
    "ONELINER": "Determine whether a symbol exist in object as METHOD",
    "SYNTAX": "__objHasMethod( <oObject>, <cSymbol> ) --> lExist",
    "ARGUMENTS": "<oObject> is an object to scan.\n\n<cSymbol> is the name of the symbol to look for.",
    "RETURNS": "__objHasMethod() return .T. if the given <cSymbol> exist as METHOD\n(class function) in object <oObject), .F. if it does not exist.",
    "DESCRIPTION": "__objHasMethod() is a low-level class support function that let you\nfind out if a symbol is a class function in a given object.",
    "EXAMPLES": "LOCAL oB := TBrowseNew( 0, 0, 24, 79 )\n? __objHasMethod( oB, \"nLeft\" )    // --> .F. since this is a VAR\n? __objHasMethod( oB, \"FixBugs\" )  // --> .F.\n? __objHasMethod( oB, \"Left\" )     // --> .T.",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "__objGetMethodList(), __objGetMsgList(), __objHasData()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/objfunc.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__objGetMsgList()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Objects",
    "ONELINER": "Return names of all VAR or METHOD for a given object",
    "SYNTAX": "__objGetMsgList( <oObject>, [<lData>], [nClassType] ) --> aNames",
    "ARGUMENTS": "<oObject> is an object to scan.\n\n<lData> is an optional logical value that specifies the information\nto return. A value of .T. instruct the function to return list of\nall VAR names, .F. return list of all METHOD names. Default value\nis .T.\n\n<nClassType> is on optional numeric code for selecting which class\ntype to return. Default value is HB_MSGLISTALL, returning the whole\nlist.",
    "RETURNS": "__objGetMsgList() return an array of character stings with all VAR\nnames or all METHOD names for a given object. __objGetMsgList()\nwould return an empty array {} if the given object does not contain\nthe requested information.",
    "DESCRIPTION": "__objGetMsgList() is a low-level class support function that let you\nfind all instance variable or method names for a given object.\n\nIf specified, the following table shows the values for <nClassType>\nthat allow you to distinguish between VAR and CLASS VAR:\n\n<table>\n hboo.ch           Meaning\n\n HB_MSGLISTALL     All types\n HB_MSGLISTCLASS   CLASS VAR only\n HB_MSGLISTPURE    VAR only\n</table>\n\nVAR are instance variable usable within each object from a class,\nwhere each object has its own VARs.\n\nCLASS VAR are shared by all objects from a Class, so the changed\nvalue within Object1 will be reflected when accessing the CLASS VAR\nfrom Object2.",
    "EXAMPLES": "#include \"hboo.ch\"\n// show information about TBrowse class\nLOCAL oB := TBrowseNew( 0, 0, 24, 79 ), tmp\nFOR EACH tmp IN __objGetMsgList( oB, .T. )\n   ? \"VAR name:\", tmp\nNEXT\nFOR EACH tmp IN __objGetMsgList( oB, .T., HB_MSGLISTCLASS )\n   ? \"CLASS VAR name:\", tmp\nNEXT\nFOR EACH tmp IN __objGetMsgList( oB, .F. )\n   ? \"METHOD name:\", tmp\nNEXT",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Header file is hboo.ch\nLibrary is core",
    "SEEALSO": "__objGetMethodList(), __objGetValueList(), __objHasData(), __objHasMethod()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/objfunc.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__objGetMethodList()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Objects",
    "ONELINER": "Return names of all METHOD for a given object",
    "SYNTAX": "__objGetMethodList( <oObject> ) --> aMethodNames",
    "ARGUMENTS": "<oObject> is an object to scan.",
    "RETURNS": "__objGetMethodList() return an array of character stings with all\nMETHOD names for a given object. __objGetMethodList() would return\nan empty array {} if the given object does not contain any METHOD.",
    "DESCRIPTION": "__objGetMethodList() is a low-level class support function that let\nyou find all class functions names for a given object.\nIt is equivalent to `__objGetMsgList( oObject, .F. )`.",
    "EXAMPLES": "// show information about TBrowse class\nLOCAL oB := TBrowseNew( 0, 0, 24, 79 ), tmp\nFOR EACH tmp IN __objGetMethodList( oB )\n   ? \"METHOD name:\", tmp\nNEXT",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "__objGetMsgList(), __objGetValueList(), __objHasData(), __objHasMethod()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/objfunc.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__objGetValueList()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Objects",
    "ONELINER": "Return an array of VAR names and values for a given object",
    "SYNTAX": "__objGetValueList( <oObject>, [<aExcept>] ) --> aData",
    "ARGUMENTS": "<oObject> is an object to scan.\n\n<aExcept> is an optional array with VAR names you want to exclude\nfrom the scan.",
    "RETURNS": "__objGetValueList() return a 2D array that contain pairs of a VAR\nsymbol name and the value of VAR. __objGetValueList() would return\nan empty array {} if the given object does not contain the requested\ninformation.",
    "DESCRIPTION": "__objGetValueList() is a low-level class support function that\nreturn an array with VAR names and value, each array element is a\npair of: `aData[ i ][ HB_OO_DATA_SYMBOL ]` contain the symbol name\n         `aData[ i ][ HB_OO_DATA_VALUE  ]` contain the value of VAR",
    "EXAMPLES": "// FIXME\n// show information about TBrowse class\n#include \"hboo.ch\"\nLOCAL oB := TBrowseNew( 0, 0, 24, 79 ), tmp\nFOR EACH tmp IN __objGetValueList( oB )\n   ? ;\n     \"VAR name:\", tmp[ HB_OO_DATA_SYMBOL ], ;\n     \"   value=\", tmp[ HB_OO_DATA_VALUE ]\nNEXT",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Header file is hboo.ch\nLibrary is core",
    "SEEALSO": "__objGetMethodList(), __objGetMsgList(), __objHasData(), __objHasMethod(), __objSetValueList()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/objfunc.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__objSetValueList()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Objects",
    "ONELINER": "Set object with an array of VAR names and values",
    "SYNTAX": "__objSetValueList( <oObject>, <aData> ) --> oObject",
    "ARGUMENTS": "<oObject> is an object to set.\n\n<aData> is a 2D array with a pair of instance variables and values\nfor setting those variable.",
    "RETURNS": "__objSetValueList() return a reference to <oObject>.",
    "DESCRIPTION": "__objSetValueList() is a low-level class support function that let\nyou set a group of instance variables with values. each array\nelement in <aData> is a pair of:\naData[ i ][ HB_OO_DATA_SYMBOL ] which contain the variable name to set\naData[ i ][ HB_OO_DATA_VALUE  ] contain the new variable value.",
    "EXAMPLES": "// set some TBrowse instance variable\n#include \"hboo.ch\"\nLOCAL oB := TBrowse():New()\nLOCAL aData := Array( 4, 2 )\naData[ 1 ][ HB_OO_DATA_SYMBOL ] := \"nTop\"\naData[ 1 ][ HB_OO_DATA_VALUE  ] := 1\naData[ 2 ][ HB_OO_DATA_SYMBOL ] := \"nLeft\"\naData[ 2 ][ HB_OO_DATA_VALUE  ] := 10\naData[ 3 ][ HB_OO_DATA_SYMBOL ] := \"nBottom\"\naData[ 3 ][ HB_OO_DATA_VALUE  ] := 20\naData[ 4 ][ HB_OO_DATA_SYMBOL ] := \"nRight\"\naData[ 4 ][ HB_OO_DATA_VALUE  ] := 70\n__objSetValueList( oB, aData )\n? oB:nTop     // --> 1\n? oB:nLeft    // --> 10\n? oB:nBottom  // --> 20\n? oB:nRight   // --> 70",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Header file is hboo.ch\nLibrary is core",
    "SEEALSO": "__objGetValueList()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/objfunc.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__objAddMethod()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Objects",
    "ONELINER": "Add a METHOD to an already existing class",
    "SYNTAX": "__objAddMethod( <oObject>, <cMethodName>, <nFuncPtr> ) --> oObject",
    "ARGUMENTS": "<oObject> is the object to work on.\n\n<cMethodName> is the symbol name of the new METHOD to add.\n\n<nFuncPtr> is a pointer to a function to associate with the method.",
    "RETURNS": "__objAddMethod() return a reference to <oObject>.",
    "DESCRIPTION": "__objAddMethod() is a low-level class support function that add a\nnew METHOD to an object. <oObject> is unchanged if a symbol with the\nname <cMethodName> already exist in <oObject>.\n\nNote that <nFuncPtr> is a special pointer to a function that was\ncreated using the @ operator, see example below.",
    "EXAMPLES": "// create a new THappy class and add a Smile method\nLOCAL oHappy := HBClass():New( \"THappy\" )\n__objAddMethod( oHappy, \"Smile\", @MySmile() )\n? oHappy:Smile( 1 )       // --> :)\n? oHappy:Smile( 2 )       // --> ;)\n? oHappy:Smile( 3 )       // --> *SMILE*\n\nSTATIC FUNCTION MySmile( nType )\n   IF HB_ISNUMERIC( nType )\n      SWITCH nType\n      CASE 1 ; RETURN \":)\"\n      CASE 2 ; RETURN \";)\"\n      CASE 3 ; RETURN \"*SMILE*\"\n      ENDSWITCH\n   ENDIF\n   RETURN NIL",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "__objAddInline(), __objAddData(), __objDelMethod(), __objGetMethodList(), __objGetMsgList(), __objHasMethod(), __objModMethod()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/objfunc.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__objAddInline()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Objects",
    "ONELINER": "Add an INLINE to an already existing class",
    "SYNTAX": "__objAddInline( <oObject>, <cInlineName>, <bInline> ) --> oObject",
    "ARGUMENTS": "<oObject> is the object to work on.\n\n<cInlineName> is the symbol name of the new INLINE to add.\n\n<bInline> is a code block to associate with the INLINE method.",
    "RETURNS": "__objAddInline() return a reference to <oObject>.",
    "DESCRIPTION": "__objAddInline() is a low-level class support function that add a\nnew INLINE method to an object. <oObject> is unchanged if a symbol\nwith the name <cInlineName> already exist in <oObject>.",
    "EXAMPLES": "// create a new THappy class and add a Smile INLINE method\nLOCAL oHappy := HBClass():New( \"THappy\" )\nLOCAL bInline := {| Self, nType | HB_SYMBOL_UNUSED( Self ), ;\n   { \":)\", \";)\", \"*SMILE*\" }[ nType ] }\n__objAddInline( oHappy, \"Smile\", bInline )\n? oHappy:Smile( 1 )       // --> :)\n? oHappy:Smile( 2 )       // --> ;)\n? oHappy:Smile( 3 )       // --> *SMILE*",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "__objAddData(), __objAddMethod(), __objDelInline(), __objGetMethodList(), __objGetMsgList(), __objHasMethod(), __objModInline()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/objfunc.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__objAddData()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Objects",
    "ONELINER": "Add a VAR to an already existing class",
    "SYNTAX": "__objAddData( <oObject>, <cDataName> ) --> oObject",
    "ARGUMENTS": "<oObject> is the object to work on.\n\n<cDataName> is the symbol name of the new VAR to add.",
    "RETURNS": "__objAddData() return a reference to <oObject>.",
    "DESCRIPTION": "__objAddData() is a low-level class support function that add a new\nVAR to an object. <oObject> is unchanged if a symbol with the name\n<cDataName> already exist in <oObject>.",
    "EXAMPLES": "// create a new THappy class and add a lHappy VAR\nLOCAL oHappy := HBClass():New( \"THappy\" )\n__objAddData( oHappy, \"lHappy\" )\noHappy:lHappy := .T.\nIF oHappy:lHappy\n   ? \"Happy, Happy, Joy, Joy !!!\"\nELSE\n   ? \":(...\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "__objAddInline(), __objAddMethod(), __objDelData(), __objGetMsgList(), __objGetValueList(), __objHasData(), __objSetValueList()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/objfunc.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__objModMethod()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Objects",
    "ONELINER": "Modify (replace) a METHOD in an already existing class",
    "SYNTAX": "__objModMethod( <oObject>, <cMethodName>, <nFuncPtr> ) --> oObject",
    "ARGUMENTS": "<oObject> is the object to work on.\n\n<cMethodName> is the symbol name of the METHOD to modify.\n\n<nFuncPtr> is a pointer to a new function to associate with the\nmethod.",
    "RETURNS": "__objModMethod() return a reference to <oObject>.",
    "DESCRIPTION": "__objModMethod() is a low-level class support function that modify\na METHOD in an object and replace it with a new function. <oObject>\nis unchanged if a symbol with the name <cMethodName> does not exist\nin <oObject>. __objModMethod() is used in inheritance mechanism.\n\nNote that <nFuncPtr> is a special pointer to a function that was\ncreated using the @ operator, see example below.",
    "EXAMPLES": "// create a new THappy class and add a Smile method\nLOCAL oHappy := HBClass():New( \"THappy\" )\n__objAddMethod( oHappy, \"Smile\", @MySmile() )\n? oHappy:Smile( 1 )       // --> :)\n? oHappy:Smile( 2 )       // --> ;)\n// replace Smile method with a new function\n__objAddMethod( oHappy, \"Smile\", @YourSmile() )\n? oHappy:Smile( 1 )       // --> *SMILE*\n? oHappy:Smile( 2 )       // --> *WINK*\n\nSTATIC FUNCTION MySmile( nType )\n   DO CASE\n   CASE nType == 1\n      RETURN \":)\"\n   CASE nType == 2\n      RETURN \";)\"\n   ENDCASE\n   RETURN NIL\n\nSTATIC FUNCTION YourSmile( nType )\n   DO CASE\n   CASE nType == 1\n      RETURN \"*SMILE*\"\n   CASE nType == 2\n      RETURN \"*WINK*\"\n   ENDCASE\n   RETURN NIL",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "__objAddMethod(), __objDelMethod(), __objGetMethodList(), __objGetMsgList(), __objHasMethod()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/objfunc.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__objModInline()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Objects",
    "ONELINER": "Modify (replace) an INLINE method in an already existing class",
    "SYNTAX": "__objModInline( <oObject>, <cInlineName>, <bInline> ) --> oObject",
    "ARGUMENTS": "<oObject> is the object to work on.\n\n<cInlineName> is the symbol name of the INLINE method to modify.\n\n<bInline> is a new code block to associate with the INLINE method.",
    "RETURNS": "__objModInline() return a reference to <oObject>.",
    "DESCRIPTION": "__objModInline() is a low-level class support function that modify\nan INLINE method in an object and replace it with a new code block.\n<oObject> is unchanged if a symbol with the name <cInlineName> does\nnot exist in <oObject>. __objModInline() is used in inheritance\nmechanism.",
    "EXAMPLES": "// create a new THappy class and add a Smile INLINE method\nLOCAL oHappy := HBClass():New( \"THappy\" )\nLOCAL bMyInline   := {| Self, nType | HB_SYMBOL_UNUSED( Self ), ;\n   { \":)\", \";)\" }[ nType ] }\nLOCAL bYourInline := {| Self, nType | HB_SYMBOL_UNUSED( Self ), ;\n   { \"*SMILE*\", \"*WINK*\" }[ nType ] }\n__objAddInline( oHappy, \"Smile\", bMyInline )\n? oHappy:Smile( 1 )       // --> :)\n? oHappy:Smile( 2 )       // --> ;)\n// replace Smile inline method with a new code block\n__objModInline( oHappy, \"Smile\", bYourInline )\n? oHappy:Smile( 1 )       // --> *SMILE*\n? oHappy:Smile( 2 )       // --> *WINK*",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "__objAddInline(), __objDelInline(), __objGetMethodList(), __objGetMsgList(), __objHasMethod()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/objfunc.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__objDelMethod()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Objects",
    "ONELINER": "Delete a METHOD  from class",
    "SYNTAX": "__objDelMethod( <oObject>, <cSymbol> ) --> oObject",
    "ARGUMENTS": "<oObject> is the object to work on.\n\n<cSymbol> is the symbol name of METHOD or INLINE method to be\ndeleted (removed) from the object.",
    "RETURNS": "__objDelMethod() return a reference to <oObject>.",
    "DESCRIPTION": "__objDelMethod() is a low-level class support function that deletes\n(removes) a METHOD or an INLINE method from an object. <oObject> is\nunchanged if a symbol with the name <cSymbol> does not exist in\n<oObject>.\n\n__objDelInline() is exactly the same as __objDelMethod().",
    "EXAMPLES": "// create a new THappy class and add a Smile method\nLOCAL oHappy := HBClass():New( \"THappy\" )\n__objAddMethod( oHappy, \"Smile\", @MySmile() )\n? __objHasMethod( oHappy, \"Smile\" )  // --> .T.\n// remove Smile method\n__objDelMethod( oHappy, \"Smile\" )\n? __objHasMethod( oHappy, \"Smile\" )  // --> .F.\n\nSTATIC FUNCTION MySmile( nType )\n   DO CASE\n   CASE nType == 1\n      RETURN \":)\"\n   CASE nType == 2\n      RETURN \";)\"\n   ENDCASE\n   RETURN NIL",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "__objAddInline(), __objAddMethod(), __objGetMethodList(), __objGetMsgList(), __objHasMethod(), __objModInline(), __objModMethod()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/objfunc.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__objDelInline()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Objects",
    "ONELINER": "Delete a METHOD INLINE from class",
    "SYNTAX": "__objDelInline( <oObject>, <cSymbol> ) --> oObject",
    "ARGUMENTS": "<oObject> is the object to work on.\n\n<cSymbol> is the symbol name of METHOD or INLINE method to be\ndeleted (removed) from the object.",
    "RETURNS": "__objDelInline() return a reference to <oObject>.",
    "DESCRIPTION": "__objDelInline() is a low-level class support function that delete\n(remove) a METHOD or an INLINE method from an object. <oObject> is\nunchanged if a symbol with the name <cSymbol> does not exist in\n<oObject>.",
    "EXAMPLES": "// create a new THappy class and add a Smile method\nLOCAL oHappy := HBClass():New( \"THappy\" )\n__objAddMethod( oHappy, \"Smile\", @MySmile() )\n? __objHasMethod( oHappy, \"Smile\" )  // --> .T.\n// remove Smile method\n__objDelInline( oHappy, \"Smile\" )\n? __objHasMethod( oHappy, \"Smile\" )  // --> .F.\n\nSTATIC FUNCTION MySmile( nType )\n   DO CASE\n   CASE nType == 1\n      RETURN \":)\"\n   CASE nType == 2\n      RETURN \";)\"\n   ENDCASE\n   RETURN NIL",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "__objAddInline(), __objAddMethod(), __objGetMethodList(), __objGetMsgList(), __objHasMethod(), __objModInline(), __objModMethod()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/objfunc.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__objDelData()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Objects",
    "ONELINER": "Delete a VAR (instance variable) from class",
    "SYNTAX": "__objDelMethod( <oObject>, <cDataName> ) --> oObject",
    "ARGUMENTS": "<oObject> is the object to work on.\n\n<cDataName> is the symbol name of VAR to be deleted (removed) from\nthe object.",
    "RETURNS": "__objDelData() return a reference to <oObject>.",
    "DESCRIPTION": "__objDelData() is a low-level class support function that delete\n(remove) a VAR from an object. <oObject> is unchanged if a symbol\nwith the name <cDataName> does not exist in <oObject>.",
    "EXAMPLES": "// create a new THappy class and add a lHappy VAR\nLOCAL oHappy := HBClass():New( \"THappy\" )\n__objAddData( oHappy, \"lHappy\" )\n? __objHasData( oHappy, \"lHappy\" )  // --> .T.\n// remove lHappy VAR\n__objDelData( oHappy, \"lHappy\" )\n? __objHasData( oHappy, \"lHappy\" )  // --> .F.",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "__objAddData(), __objGetMsgList(), __objGetValueList(), __objHasData(), __objSetValueList()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/objfunc.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__objDerivedFrom()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Objects",
    "ONELINER": "Determine whether a class is derived from another class",
    "SYNTAX": "__objDerivedFrom( <oObject>, <xSuper> ) --> lIsParent",
    "ARGUMENTS": "<oObject> is the object to check.\n\n<xSuper> is the object that may be a parent. <xSuper> can be either\nan Object or a Character string with the class name.",
    "RETURNS": "__objDerivedFrom() return a logical TRUE (.T.) if <oObject> is\nderived from <xSuper>.",
    "DESCRIPTION": "__objDerivedFrom() is a low-level class support function that check\nis one class is a super class of the other, or in other words, does\nclass <oObject> a child or descendant of <xSuper>.",
    "EXAMPLES": "// Create three classes and check their relations\n\n#include \"hbclass.ch\"\nPROCEDURE Main()\n   LOCAL oSuper  := TMood():New()\n   LOCAL oObject := THappy():New()\n   LOCAL oDress  := TShirt():New()\n   ? __objDerivedFrom( oObject, oSuper )  // --> .T.\n   ? __objDerivedFrom( oSuper, oObject )  // --> .F.\n   ? __objDerivedFrom( oObject, oDress )  // --> .F.\n   RETURN\n\nCREATE CLASS TMood\n   METHOD New() INLINE Self\nENDCLASS\n\nCREATE CLASS THappy INHERIT TMood\n   METHOD Smile() INLINE QOut( \"*smile*\" )\nENDCLASS\n\nCREATE CLASS TShirt\n   VAR Color\n   VAR Size\n   METHOD New() INLINE Self\nENDCLASS",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "__objHasData(), __objHasMethod()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/proc.txt",
    "AUTHOR": "Copyright 1999 Jose Lalin <dezac@corevia.com>",
    "TEMPLATE": "Function",
    "NAME": "ProcName()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Application",
    "ONELINER": "Gets the name of the current function on the stack",
    "SYNTAX": "ProcName( <nLevel> ) --> cProcName",
    "ARGUMENTS": "<nLevel> is the function level required.",
    "RETURNS": "<cProcName> The name of the function that it is being executed.",
    "DESCRIPTION": "This function looks at the top of the stack and gets the current\nexecuted function if no arguments are passed. Otherwise it returns\nthe name of the function or procedure at <nLevel>.",
    "EXAMPLES": "// This test will show the functions and procedures in stack.\n// before executing it.\nLOCAL n := 1\nDO WHILE ! Empty( ProcName( n ) )\n   ? ProcName( n++ )\nENDDO",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "ProcLine(), ProcFile()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/proc.txt",
    "AUTHOR": "Copyright 1999 Jose Lanin <dezac@corevia.com>",
    "TEMPLATE": "Function",
    "NAME": "ProcLine()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Application",
    "ONELINER": "Gets the line number of the current function on the stack.",
    "SYNTAX": "ProcLine( <nLevel> ) --> nLine",
    "ARGUMENTS": "<nLevel> is the function level required.",
    "RETURNS": "<nLine> The line number of the function that it is being executed.",
    "DESCRIPTION": "This function looks at the top of the stack and gets the current\nline number of the executed function if no arguments are passed.\nOtherwise it returns the line number of the function or procedure\nat <nLevel>.",
    "EXAMPLES": "? ProcLine( 0 )\n? ProcName( 2 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "ProcName(), ProcFile()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/proc.txt",
    "AUTHOR": "Copyright 1999 Jose Lanin <dezac@corevia.com>",
    "TEMPLATE": "Function",
    "NAME": "ProcFile()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Application",
    "ONELINER": "This function always returns an empty string.",
    "SYNTAX": "ProcFile( <xExp> ) --> cEmptyString",
    "ARGUMENTS": "<xExp> is any valid type.",
    "RETURNS": "<cEmptyString> Return an empty string",
    "DESCRIPTION": "This function is added to the RTL for full compatibility. It\nalways returns an empty string.",
    "EXAMPLES": "? ProcFile()\n? ProcFile( NIL )\n? ProcFile( 2 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "ProcName(), ProcLine()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "dbEval()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Execute and Execution",
    "ONELINER": "Performs a code block operation on the current Database",
    "SYNTAX": "dbEval( <bBlock>,\n[<bFor>], [<bWhile>],\n[<nNext>], [<nRecord>],\n[<lRest>] ) --> NIL",
    "ARGUMENTS": "<bBlock> Operation that is to be performed\n\n<bFor> Code block for the For condition\n\n<bWhile> Code block for the WHILE condition\n\n<nNext> Number of NEXT records  to process\n\n<nRecord> Record number to work on exactly\n\n<lRest> Toggle to rewind record pointer",
    "RETURNS": "dbEval() always returns NIL",
    "DESCRIPTION": "Performs a code block operation on the current Database",
    "EXAMPLES": "LOCAL nCount\n\nUSE test\n\ndbGoto( 4 )\n? RecNo()\nCOUNT TO nCount NEXT 10\n? RecNo(), nCount\nCOUNT TO nCount\n? RecNo(), nCount",
    "STATUS": "S",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "Eval()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "TEMPLATE": "Function",
    "NAME": "Dbf()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Alias name of a work area",
    "SYNTAX": "Dbf() --> cWorkArea",
    "RETURNS": "<cWorkArea> Name of alias",
    "DESCRIPTION": "This function returns the same alias name of the currently selected\nwork area.",
    "EXAMPLES": "USE test\nSELECT 0\n? iif( Dbf() == \"\", \"No Name\", Dbf() )\n? test->( Dbf() )\n? Alias( 1 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "Alias()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "dbAppend()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Appends a new record to a database file.",
    "SYNTAX": "dbAppend( [<lLock>] ) --> NIL",
    "ARGUMENTS": "<lLock> Toggle to release record locks",
    "RETURNS": "dbAppend() always returns NIL",
    "DESCRIPTION": "This function add a new record to the end of the database\nin the selected or aliased work area. All fields in that\ndatabase will be given empty data values - character fields\nwill be filled with blank spaces, date fields with hb_SToD(),\nnumeric fields with 0, logical fields with .F., and memo fields\nwith NULL bytes. The header of the database is not updated until\nthe record is flushed from the buffer and the contents are\nwritten to the disk.\n\nUnder a networking environment, dbAppend() performs an additional\noperation: It attempts to lock the newly added record. If\nthe database file is currently locked or if a locking assignment\nis made to `LastRec() + 1`, NetErr() will return a logical true (.T.)\nimmediately after the dbAppend() function. This function does\nnot unlock the locked records.\n\nIf <lLock> is passed a logical true (.T.) value, it will\nrelease the record locks, which allows the application to maintain\nmultiple record locks during an appending operation. The\ndefault for this parameter is a logical false (.F.).",
    "EXAMPLES": "LOCAL cName := \"Harbour\", nAge := 15\nUSE test\ntest->( dbAppend() )\ntest->first := cName\ntest->age   := nAge",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbUnlock(), dbUnlockAll()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "dbClearFilter()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Clears the current filter condition in a work area",
    "SYNTAX": "dbClearFilter() --> NIL",
    "RETURNS": "dbClearFilter() always returns NIL",
    "DESCRIPTION": "This function clears any active filter conduction\nfor the current or selected work area.",
    "EXAMPLES": "USE test\nSET FILTER TO hb_LeftEq( test->first, \"An\" )\ndbGoTop()\ndbEval( {|| QOut( test->first ) } )\ndbClearFilter()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbSetFilter(), dbFilter()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "dbCloseAll()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Close all open files in all work areas.",
    "SYNTAX": "dbCloseAll() --> NIL",
    "RETURNS": "dbCloseAll() always return NIL",
    "DESCRIPTION": "This function close all open databases and all associated\nindexes. In addition, it closes all format files and moves\nthe work area pointer to the first position",
    "EXAMPLES": "USE test NEW\ndbEdit()\nUSE test1 NEW\ndbEdit()\ndbCloseAll()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbUseArea(), dbCloseArea()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "dbCloseArea()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Close a database file in a work area.",
    "SYNTAX": "dbCloseArea()",
    "DESCRIPTION": "This function  will close any database open in the selected\nor aliased work area.",
    "EXAMPLES": "USE test\ndbEdit()\ntest->( dbCloseArea() )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbUseArea(), dbCloseAll()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "dbCommit()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Updates all index and database buffers for a given work area",
    "SYNTAX": "dbCommit()",
    "DESCRIPTION": "This function updates all of the information for a give, selected,\nor active work area. This operation includes all database and index\nbuffers for that work area only. This function does not update all\nopen work areas.",
    "EXAMPLES": "LOCAL GetList := {}\nLOCAL cName := Space( 40 )\nLOCAL nAge := 0\n\nUSE test EXCLUSIVE NEW\n\n@ 10, 10 GET cName\n@ 11, 10 GET nAge\nREAD\n\nIF Updated()\n   dbAppend()\n   test->first := cName\n   test->age   := nAge\n   dbCommit()\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbCloseAll(), dbCommitAll(), dbUnlock()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "dbCommitAll()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Flushes the memory buffer and performs a hard-disk write",
    "SYNTAX": "dbCommit()",
    "DESCRIPTION": "This function performs a hard-disk write for all work areas.\nBefore the disk write is performed, all buffers are flushed.\nopen work areas.",
    "EXAMPLES": "// FIXME\nLOCAL GetList := {}\nLOCAL cName := Space( 40 )\nLOCAL nId := 0\n\nUSE test EXCLUSIVE NEW\nUSE testid NEW INDEX testid\n\n@ 10, 10 GET cName\n@ 11, 10 GET nId\nREAD\n\nIF Updated()\n   dbAppend()\n   test->first := cName\n   test->Id    := nId\n   IF ! testid->( dbSeek( nId ) )\n      testid->( dbAppend() )\n      testid->Id := nId\n   ENDIF\nENDIF\ndbCommitAll()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbCloseAll(), dbCommit(), dbUnlock()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "dbCreate()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Creates an empty database from a array.",
    "SYNTAX": "dbCreate( <cFile>, <aStruct>, [<cRDD>], [<lKeepOpen>], [<cAlias>],\n          [<cDelimArg>], [<cCodePage>], [<nConnection>] )",
    "ARGUMENTS": "<cFile>     Name of database file to be create\n\n<aStruct>   Name of a multidimensional array that contains the\n            database structure\n\n<cRDD>      Name of the RDD\n\n<lKeepOpen> 3-way toggle to Open the file in New or Current work area:\n\n            <table-noheader>\n                 NIL     The file is not opened.\n                 True    It is opened in a New area.\n                 False   It is opened in the current area.\n            </table>\n\n<cAlias>    Name of database Alias",
    "DESCRIPTION": "This function creates the database file specified as <cDatabase> from the\nmultidimensional array <aStruct>. If no file extension is use with <cDatabase>\nthe .dbf extension is assumed.\nThe array specified in <aStruct> must follow a few guidelines when being\nbuilt prior to a call to dbCreate():\n\n- All subscripts values in the second dimension must be set to proper values\n\n- The fourth subscript value in the second dimension - which contains\n  the decimal value-must he specified. even 1kw non-numeric fields.\n\n- The second subscript value in the second dimension-which contains\n  the field data type-must contain a proper value: C, D, L, M or N\n  It is possible to use additional letters for clarity (e.g., 'Numeric'\n  for 'N'): however, the first letter of this array element must\n  be a proper value.\n\nThe dbCreate() function does not use the decimal field to\ncalculate the length of a character held longer than 256. Values\nup to the maximum length of a character field (which is 65519 bytes)\nare stored directly in the database in the length attribute if that\ndatabase was created via this function. However, a file containing\nfields longer than 256 bytes is not compatible with any interpreter.\n\nThe <cRDD> parameter specifies the name of the Replaceable\nDatabase Driver to use to create the database. If it is not\nspecified, then the Replaceable Database Driver in the current work\narea is used.\n\nThe <lKeepOpen> parameter specifies if the already created database is\nto be opened, and where.  If NIL, the file is not opened. If True,\nit is opened in a New area, and if False it is opened in the current\narea (closing any file already occupying that area).\nThe <cAlias> parameter specifies the alias name for the new opened\ndatabase.",
    "EXAMPLES": "LOCAL aStruct := { ;\n   { \"CHARACTER\", \"C\", 25, 0 }, ;\n   { \"NUMERIC\",   \"N\",  8, 0 }, ;\n   { \"DOUBLE\",    \"N\",  8, 2 }, ;\n   { \"DATE\",      \"D\",  8, 0 }, ;\n   { \"LOGICAL\",   \"L\",  1, 0 }, ;\n   { \"MEMO1\",     \"M\", 10, 0 }, ;\n   { \"MEMO2\",     \"M\", 10, 0 } }\n\nREQUEST DBFCDX\n\n? dbCreate( \"testdbf\", aStruct, \"DBFCDX\", .T., \"MYALIAS\" )",
    "STATUS": "R",
    "COMPLIANCE": "This function is not CA-Cl*pper compliant",
    "FILES": "Library is rdd\nHeader is dbstruct.ch",
    "SEEALSO": "AFields()*, dbStruct()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "dbDelete()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Mark a record for deletion in a database.",
    "SYNTAX": "dbDelete()",
    "DESCRIPTION": "This function marks a record for deletion in the selected\nor aliased work area. If the DELETED setting is on, the record\nwill still be visible until the record pointer in that work area\nis moved to another record.\n\nIn a networking situation, this function requires that the record\nbe locked prior to issuing the dbDelete() function.",
    "EXAMPLES": "LOCAL nAge := 50\nUSE test NEW\nINDEX ON field->age TO test\nIF dbSeek( nAge ) .AND. RLock()\n   dbDelete()\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbRecall()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "dbFilter()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Return the filter expression in a work area",
    "SYNTAX": "dbFilter() --> cFilter",
    "RETURNS": "dbFilter() returns the filter expression.",
    "DESCRIPTION": "This function return the expression of the `SET FILTER TO` command\nfor the current or designated work area. If no filter condition\nis present, a null string will be returned.",
    "EXAMPLES": "USE test INDEX test NEW\nSET FILTER TO field->first = \"Harbour\"\nUSE testid INDEX testid NEW\nSET FILTER TO field->age == 25\nSELECT test\n\n? dbFilter()\n? testid->( dbFilter() )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbRelation(), dbRSelect()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "dbGoBottom()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Moves the record pointer to the bottom of the database.",
    "SYNTAX": "dbGoBottom()",
    "DESCRIPTION": "This function moves the record pointer in the selected or aliased\nwork area to the end of the file. The position of the record pointer\nis affected by the values in the index key or by an active FILTER\ncondition. Otherwise, if no index is active or if no filter condition\nis present, the value of the record pointer will be LastRec().",
    "EXAMPLES": "USE test\ndbGoTop()\n? RecNo()\ndbGoBottom()\n? RecNo()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "Bof(), Eof(), dbSkip(), dbSeek(), dbGoTop()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "dbGoto()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Position the record pointer to a specific location.",
    "SYNTAX": "dbGoto( <xRecordNumber> )",
    "ARGUMENTS": "<xRecordNumber> Record number or unique identity",
    "DESCRIPTION": "This function places the record pointer, if working with a .dbf file,\nin selected or aliased work area at the record number specified by\n<xRecordNumber>. The position is not affected by an active index or\nby any environmental SET condition.\n\nThe parameter <xRecordNumber> may be something other than a record\nnumber. In some data formats, for example, the value of <xRecordNumber>\nis a unique primary key while in other formats, <xRecordNumber> could\nbe an array offset if the data set was an array.\n\nIssuing a `dbGoto( RecNo() )` call in a network environment will refresh\nthe database and index buffers. This is the same as a `dbSkip( 0 )` call.",
    "EXAMPLES": "// The following example uses dbGoto() to iteratively process\n// every fourth record:\n\ndbUseArea( .T., \"DBFNTX\", \"sales\", \"sales\", .T. )\n\n// toggle every fourth record\nDO WHILE ! Eof()\n   dbGoto( RecNo() + 4 )\n   sales->Group := \"Bear\"\nENDDO",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "Bof(), Eof(), dbGoTop(), dbGoBottom(), dbSeek(), dbSkip()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "dbGoTop()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Moves the record pointer to the top of the database.",
    "SYNTAX": "dbGoTop()",
    "DESCRIPTION": "This function moves the record pointer in the selected or aliased\nwork area to the top of the file. The position of the record pointer\nis affected by the values in the index key or by an active FILTER\ncondition. Otherwise, if no index is active or if no filter condition\nis present, the value of RecNo() will be 1.",
    "EXAMPLES": "USE test\ndbGoTop()\n? RecNo()\ndbGoBottom()\n? RecNo()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "Bof(), Eof(), dbSkip(), dbSeek(), dbGoBottom()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "dbRecall()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Recalls a record previously marked for deletion.",
    "SYNTAX": "dbRecall()",
    "DESCRIPTION": "This function unmarks those records marked for deletion and\nreactivates them in the aliased or selected work area. If a record\nis DELETED and the DELETED setting is on, the record will still be\nvisible for a dbRecall() provided that the database record pointer\nhas not been skipped. Once a record marked for deletion with the\nDELETE setting ON has been skipped, it no longer can be brought back\nwith dbRecall().",
    "EXAMPLES": "USE test NEW\ndbGoto( 10 )\ndbDelete()\n? Deleted()\ndbRecall()\n? Deleted()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbDelete()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "dbRLock()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "This function locks the record based on identity",
    "SYNTAX": "dbRLock( [<xIdentity>] ) --> lSuccess",
    "ARGUMENTS": "<xIdentity> Record identifier",
    "RETURNS": "dbRLock() returns a logical true (.T.) if lock was successful",
    "DESCRIPTION": "This function attempts to lock a record which is identified\nby <xIdentity> in the active data set. If the lock is successful\nthe function will return a logical true (.T.) value; otherwise\na logical false (.F.) will be returned. If <xIdentity> is not\npassed it will be assumed to lock the current active record/data\nitem.",
    "EXAMPLES": "LOCAL nRecNo\nUSE test NEW\nFOR nRecNo := 1 TO LastRec()\n   IF ! dbRLock()\n      dbUnlock()\n   ENDIF\nNEXT",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbUnlock(), dbUnlockAll(), FLock(), RLock()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "dbRLockList()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "This function return a list of locked records in the database work area",
    "SYNTAX": "dbRLockList() --> aRecordLocks",
    "RETURNS": "<aRecordList> is an array of lock records",
    "DESCRIPTION": "This function will return an array of locked records in a given\nand active work area. If the return array is an empty array\n(meaning no elements in it), then there are no locked records in that\nwork area.",
    "EXAMPLES": "LOCAL nRecNo\nUSE test NEW\ndbGoto( 10 )\n? RLock()\ndbGoto( 100 )\n? RLock()\nFOR EACH nRecNo IN dbRLockList()\n   ? nRecNo\nNEXT",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "RLock(), dbRLock(), dbRUnlock()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "dbRUnlock()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Unlocks a record based on its identifier",
    "SYNTAX": "dbRUnlock( [<xIdentity>] )",
    "ARGUMENTS": "<xIdentity> Record identifier, typically a record number",
    "DESCRIPTION": "This function will attempt to unlock the record specified as\n<xIdentity>, which in a .dbf format is the record number. If not\nspecified, them the current active record/data item will be\nunlocked",
    "EXAMPLES": "USE test NEW\ndbGoto( 10 )\nIF RLock()\n   ? test->age\n   dbRUnlock()\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "RLock(), dbRLock(), dbRLockList()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "dbSeek()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Searches for a value based on an active index.",
    "SYNTAX": "dbSeek( <expKey>, [<lSoftSeek>], [<lFindLast>] ) --> lFound",
    "ARGUMENTS": "<expKey> Any expression\n\n<lSoftSeek> Toggle SOFTSEEK condition\n\n<lFindLast> is an optional logical value that set the current\nrecord position to the last record if successful",
    "RETURNS": "dbSeek() returns logical true (.T.) if found, otherwise false",
    "DESCRIPTION": "This function searches for the first record in a database file whose\nindex key matches <expKey>. If the item is found, the function will\nreturn a logical true (.T.), the value of Found() will be a logical\ntrue (.T.), and the value of Eof() will be a logical false (.F.). If\nno item is found. then the function will return a logical false, the\nvalue of Found() will be a logical false (.F.), and the value of\nEof() will be a logical true (.T.).\n\nThis function always \"rewinds\" the database pointer and starts the\nsearch from the top of the file.\n\nIf the SOFTSEEK flag is on or if <lSoftSeek> is set to a logical true\n(.T.) the value of Found() will be a logical false and Eof() will be\nfalse if there is an item in the index key with a greater value than\nthe key expression <expKey>; at this point the record pointer will\nposition itself on that record. However, if there is no greater key\nin the index, Eof() will return a logical true (.T.) value. If\n<lSoftSeek> is not passed, the function will look to the internal\nstatus of SOFTSEEK before performing the operation. The default of\n<lSoftSeek> is a logical false (.F.)",
    "EXAMPLES": "PROCEDURE Main()\n\n   LOCAL nAge\n\n   USE test NEW\n   INDEX ON field->age TO test\n   dbGoto( 10 )\n   nAge := test->age\n   dbGoTop()\n   IF dbSeek( nAge )\n      ? test->first\n   ENDIF\n\n   RETURN\n\nSTATIC PROCEDURE EmployeeLookup()\n\n   LOCAL cName\n\n   ACCEPT \"Employee name: \" TO cName\n   IF Employee->( dbSeek( cName ) )\n      Employee->( ViewRecord() )\n   ELSE\n      ? \"Not found\"\n   ENDIF\n\n   RETURN\n\nSTATIC PROCEDURE ViewRecord()\n\n   ? field->name\n\n   RETURN",
    "STATUS": "S",
    "COMPLIANCE": "dbSeek() is  Compatible with CA-Cl*pper 5.3",
    "FILES": "Library is rdd",
    "SEEALSO": "dbGoBottom(), dbGoTop(), dbSkip(), Eof(), Bof(), Found()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "dbSelectArea()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Change to another work area",
    "SYNTAX": "dbSelectArea( <xArea> ) --> NIL",
    "ARGUMENTS": "<xArea> Alias or work area",
    "DESCRIPTION": "This function moves the Harbour internal primary focus to the work\narea designated by <xArea>. If <xArea> is numeric, then it will\nselect the numeric work area; if <xArea> is character, then it will\nselect the work area with the alias name.\n\n`dbSelectArea( 0 )` will select the next available and unused work area.\nUp to 65534 work areas are supported. Each work area has its own alias\nand record pointer, as well as its own Found(), dbFilter(),\ndbRSelect() and dbRelation() function values.",
    "EXAMPLES": "LOCAL nAge\nUSE test NEW\nCOPY TO test1\nUSE test1 NEW\nINDEX ON field->age TO test1\ndbSelectArea( \"test\" )\ndbGoto( 100 )\n? nAge := field->age\ndbSelectArea( \"test1\" )\nIF dbSeek( nAge )\n   ? field->first\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbUseArea(), Select()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "dbSetDriver()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Establishes the RDD name for the selected work area",
    "SYNTAX": "dbSetDriver( [<cDriver>] ) --> cCurrentDriver",
    "ARGUMENTS": "<cDriver> Optional database driver name",
    "RETURNS": "dbSetDriver() returns the name of active driver",
    "DESCRIPTION": "This function returns the name of the current database driver for the\nselected work area. The default will be \"DBFNTX\". If specified,\n<cDriver> contains the name of the database driver that should be\nused to activate and manage the work area. If the specified driver is\nnot available, this function will have no effect.",
    "EXAMPLES": "? dbSetDriver( \"DBFNSX\" )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbUseArea()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "dbSkip()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Moves the record pointer in the selected work area.",
    "SYNTAX": "dbSkip( [<nRecords>] )",
    "ARGUMENTS": "<nRecords> Numbers of records to move record pointer.",
    "DESCRIPTION": "This function moves the record pointer <nRecords> in the selected or\naliased work area. The default value for <nRecords> will be 1.\nA `dbSkip( 0 )` will flush and refresh the internal database buffer and\nmake any changes made to the record visible without moving the record\npointer in either direction.",
    "EXAMPLES": "USE test NEW\ndbGoTop()\nDO WHILE ! Eof()\n   ? test->age, test->first\n   dbSkip()\nENDDO",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "Bof(), dbGoBottom(), dbGoTop(), dbSeek(), Eof()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "dbSetFilter()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Establishes a filter condition for a work area.",
    "SYNTAX": "dbSetFilter( <bCondition>, [<cCondition>] )",
    "ARGUMENTS": "<bCondition> Code block expression for filtered evaluation.\n\n<cCondition> Optional character expression of code block.",
    "DESCRIPTION": "This function masks a database so that only those records that meet\nthe condition prescribed by the expression in the code block\n<bCondition> and literally expressed as <cCondition> are visible.\nIf <cCondition> is not passed to this function, then the dbFilter()\nfunction will return an empty string showing no filter in that work\narea which in fact, would be not correct.",
    "EXAMPLES": "USE test NEW\ndbSetFilter( {|| test->age > 30 }, \"test->age > 30\" )\ndbGoTop()\n? RecNo()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbFilter(), dbClearFilter()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "dbStruct()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Creates a multidimensional array of a database structure.",
    "SYNTAX": "dbStruct() --> aStruct",
    "RETURNS": "dbStruct() returns an array pointer to database structure",
    "DESCRIPTION": "This function returns a multidimensional array. This array has array\npointers to other arrays, each of which contains the characteristic\nof a field in the active work area. The length of this array is based\nin the number of fields in that particular work area. In other words,\n`Len( dbStruct() )` is equal to the value obtained from FCount().\nEach subscript position",
    "EXAMPLES": "#include \"dbstruct.ch\"\nLOCAL field\nUSE test NEW\nFOR EACH field IN dbStruct()\n   ? field[ DBS_NAME ]\nNEXT",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd\nHeader is dbstruct.ch",
    "SEEALSO": "AFields()*"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "dbUnlock()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Unlock a record or release a file lock",
    "SYNTAX": "dbUnlock()",
    "DESCRIPTION": "This function releases the file or record lock in the currently\nselected or aliased work area. It will not unlock an associated lock\nin a related databases.",
    "EXAMPLES": "LOCAL nAge := 30\nUSE test NEW\nINDEX ON field->age TO test\nIF test->( dbSeek( nAge ) )\n   IF test->( RLock() )\n      dbDelete()\n   ELSE\n      dbUnlock()\n   ENDIF\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbUnlockAll(), FLock(), RLock()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "dbUnlockAll()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Unlocks all records and releases all file locks in all work areas.",
    "SYNTAX": "dbUnlockAll()",
    "DESCRIPTION": "This function will remove all file and record locks in all work area.",
    "EXAMPLES": "LOCAL nAge := 50\nUSE test NEW\nINDEX ON field->age TO test\nIF test->( dbSeek( nAge ) )\n   IF test->( RLock() )\n      dbDelete()\n   ELSE\n      dbUnlock()\n   ENDIF\nELSE\n   dbUnlockAll()\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbUnlock(), FLock(), RLock()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rdddb.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "dbUseArea()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Opens a work area and uses a database file.",
    "SYNTAX": "dbUseArea( [<lNewArea>], [<cDriver>], <cName>, [<xcAlias>],\n[<lShared>], [<lReadonly>] )",
    "ARGUMENTS": "<lNewArea>  A optional logical expression for the new work area\n\n<cDriver>   Database driver name\n\n<cName>     File Name\n\n<xcAlias>   Alias name\n\n<lShared>   Shared/exclusive status flag\n\n<lReadonly> Read-write status flag.",
    "DESCRIPTION": "This function opens an existing database named <cName> in the current\nwork area. If <lNewArea> is set to a logical true (.T.) value, then\nthe database <cName> will be opened in the next available and unused\nwork area. The default value of <lNewArea> is a logical false (.F.).\nIf used, <cDriver> is the name of the database driver associated with\nthe file <cName> that is opened. The default for this will be the\nvalue of dbSetDriver().\n\nIf used, <xcAlias> contains the alias name for that work area, If not\nspecified, the root name of the database specified in <cName> will be\nused.\n\nIf <lShared> is set to a logical true (.T.) value, the database that\nis specified in <cName> will be opened by the user *exclusively*. Thus\nlocking it from all other nodes or users on the network. If <lShared>\nis set to a logical false (.F.) value, then the database will be in\nSHARED mode. If <lShared> is not passed, then the function will turn\nto the internal setting of SET EXCLUSIVE to determine a setting.\n\nIf <lReadOnly> is specified, the file will be set to *read only* mode.\nIf it is not specified, the file will he opened in normal read-write\nmode.",
    "EXAMPLES": "? dbUseArea( .T.,, \"test\" )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbCloseArea(), dbSetDriver(), Select(), Set()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "AFields()*",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Fills referenced arrays with database field information",
    "SYNTAX": "AFields( <aNames>, [<aTypes>], [<aLen>], [<aDecs>] ) --> nFields",
    "ARGUMENTS": "<aNames>  Array of field names\n\n<aTypes>  Array of field names\n\n<aLens>  Array of field names\n\n<aDecs>  Array of field names",
    "RETURNS": "<nFields> Number of fields in a database or work area",
    "DESCRIPTION": "This function will fill a series of arrays with field\nnames, field types, field lengths, and number of field\ndecimal positions for the currently selected or designed\ndatabase. Each array parallels the different descriptors\nof a file's structure. The first array will consist of the\nnames of the fields in the current work area. All other arrays\nare optional and will be filled with the corresponding data.\nThis function will return zero if no parameters are specified\nor if no database is available in the current work area. Otherwise,\nthe number of fields or the length of the shortest array argument,\nwhichever is smaller, will be returned.\n\nAFields() is a compatibility function, it is superseded by\ndbStruct() which returns one multidimensional array.\n\nNOTE: The destination arrays must be initialized to a given size,\n      usually FCount(), before calling this function.\n",
    "EXAMPLES": "PROCEDURE Main()\n\n   LOCAL nCount\n\n   USE test\n\n   nCount := FCount()\n   ? \"Number of fields:\", nCount\n   PrintFields( nCount )  // Information for all fields\n   PrintFields( 4 )       // Information for first 4 fields\n\n   RETURN\n\nSTATIC PROCEDURE PrintFields( nCount )\n\n   LOCAL aNames  := Array( nCount )\n   LOCAL aTypes  := Array( nCount )\n   LOCAL aLens   := Array( nCount )\n   LOCAL aDecs   := Array( nCount )\n\n   LOCAL nFields := AFields( aNames, aTypes, aLens, aDecs ), i\n\n   ? \"Number of items:\", nFields\n   FOR tmp := 1 TO nFields\n      ? tmp, ;\n         PadR( aNames[ tmp ], 12 ), ;\n         aTypes[ tmp ], ;\n         aLens[ tmp ], ;\n         aDecs[ tmp ]\n   NEXT\n\n   RETURN",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbStruct()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "Alias()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Returns the alias name of a work area",
    "SYNTAX": "Alias( [<nWorkArea>] ) --> cWorkArea",
    "ARGUMENTS": "<nWorkArea> Number of a work area",
    "RETURNS": "<cWorkArea> Name of alias",
    "DESCRIPTION": "This function returns the alias of the work area indicated by <nWorkArea>.\nIf <nWorkArea> is not provided, the alias of the current work area is\nreturned.",
    "EXAMPLES": "USE test\nSELECT 0\n? iif( Alias() == \"\", \"No Name\", Alias() )\n? test->( Alias() )\n? Alias( 1 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "Dbf()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "Bof()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Test for the beginning-of-file condition",
    "SYNTAX": "Bof() --> lBegin",
    "RETURNS": "Bof() Logical true (.T.) or false (.F.)",
    "DESCRIPTION": "This function determines if the beginning of the file marker has been\nreached. If so, the function will return a logical true (.T.); otherwise,\na logical false (.F.) will be returned.\nBy default, Bof() will apply to the currently selected database unless\nthe function is preceded by an alias",
    "EXAMPLES": "USE test NEW\n? \"Is Bof()\", Bof()\ndbGoTop()\nDO WHILE ! Bof()\n   dbSkip( -1 )\nENDDO\n? \"Is Bof()\", Bof()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "Eof(), Found(), LastRec()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Command",
    "NAME": "ZAP",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Database",
    "ONELINER": "Remove all records from the current database file",
    "SYNTAX": "ZAP",
    "ARGUMENTS": "(This command has no arguments)",
    "DESCRIPTION": "This command removes all of the records from the database in the\ncurrent work area. This operation also updates any index file in\nuse at the time of this operation. In addition, this command removes\nall items within an associated memo file.\nIn a network environment, any file that is about to be ZAPped must\nbe used exclusively.",
    "EXAMPLES": "USE test\n? LastRec()  // --> 500\nZAP\n? LastRec()  // --> 0",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "DELETE, PACK, USE"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "Deleted()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Tests the record's deletion flag.",
    "SYNTAX": "Deleted() --> lDeleted",
    "ARGUMENTS": "(This command has no arguments)",
    "RETURNS": "Deleted() return a logical true (.T.) or false (.F.).",
    "DESCRIPTION": "This function returns a logical true (.T.) if the current record in the\nselected or designated work area has been marked for deletion. If not,\nthe function will return a logical false (.F.).",
    "EXAMPLES": "USE test NEW\ndbGoto( 10 )\ndbDelete()\n? \"Is Record Deleted\", test->( Deleted() )\ndbRecall()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbDelete()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "Eof()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Test for end-of-file condition.",
    "SYNTAX": "Eof() --> lEnd",
    "ARGUMENTS": "(This command has no arguments)",
    "RETURNS": "<lEnd> A logical true (.T.) or false (.F.)",
    "DESCRIPTION": "This function determines if the end-of-file marker has been reached.\nIf it has, the function will return a logical true (.T.); otherwise\na logical false (.F.) will be returned",
    "EXAMPLES": "USE test NEW\ndbGoTop()\n? \"Is Eof()\", Eof()\ndbGoBottom()\nDO WHILE ! Eof()\n   dbSkip()\nENDDO\n? \"Is Eof()\", Eof()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "Bof(), Found(), LastRec()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "FCount()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Counts the number of fields in an active database.",
    "SYNTAX": "FCount() --> nFields",
    "RETURNS": "<nFields> Return the number of fields",
    "DESCRIPTION": "This function returns the number of fields in the current or designated\nwork area. If no database is open in this work area, the function will\nreturn 0.",
    "EXAMPLES": "USE test NEW\n? \"This database has\", hb_ntos( test->( FCount() ) ), \"field(s)\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "FieldName(), Type()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "FieldGet()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Obtains the value  of a specified field",
    "SYNTAX": "FieldGet( <nField> ) --> ValueField",
    "ARGUMENTS": "<nField> Is the numeric field position",
    "RETURNS": "<ValueField>  Any expression",
    "DESCRIPTION": "This function returns the value of the field at the <nField>th location\nin the selected or designed work area. If the value in <nField> does not\ncorrespond to n available field position in this work area, the function\nwill return a NIL data type.",
    "EXAMPLES": "USE test NEW\n? test->( FieldGet( 1 ) )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "FieldPut()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "FieldName()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Return the name of a field at a numeric field location.",
    "SYNTAX": "FieldName()/Field( <nPosition> ) --> cFieldName",
    "ARGUMENTS": "<nPosition> Field order in the database.",
    "RETURNS": "<cFieldName> returns the field name.",
    "DESCRIPTION": "This function return the name of the field at the <nPosition>th position.\nIf the numeric value passed to this function does not correspond to an\nexisting field in the designated or selected work area, this function\nwill return a NULL byte.",
    "EXAMPLES": "LOCAL nField\nUSE test NEW\nFOR nField := 1 TO test->( FCount() )\n   ? \"Field Name:\", FieldName( nField )\nNEXT",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbStruct(), FCount(), Len(), ValType()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "FieldPos()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Return the ordinal position of a field.",
    "SYNTAX": "FieldPos( <cFieldName> ) --> nFieldPos",
    "ARGUMENTS": "<cFieldName> Name of a field.",
    "RETURNS": "<nFieldPos> is ordinal position of the field.",
    "DESCRIPTION": "This function return the ordinal position of the specified field <cField>\nin the current or aliased work area. If there isn't field under the name\nof <cField> or of no database is open in the selected work area, the\nfunction will return a 0.",
    "EXAMPLES": "USE test NEW\n? test->( FieldPos( \"LAST\" ) )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "FieldGet(), FieldPut()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "FieldPut()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Set the value of a field variable",
    "SYNTAX": "FieldPut( <nField>, <expAssign> ) --> ValueAssigned",
    "ARGUMENTS": "<nField> The field numeric position\n\n<expAssign> Expression to be assigned to the specified field",
    "RETURNS": "<ValueAssigned> Any expression",
    "DESCRIPTION": "This function assigns the value in <expAssing> to the <nField>th\nfield in the current or designated work area. If the operation is\nsuccessful, the return value of the function will be the same value\nassigned to the specified field. If the operation is not successful,\nthe function will return a NIL data type",
    "EXAMPLES": "USE test NEW\n? FieldPut( 1, \"Mr. Jones\" )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "FieldGet()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "FLock()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Locks a file",
    "SYNTAX": "FLock() --> lSuccess",
    "RETURNS": "<lSuccess> A true (.T.) value, if the lock was successful; otherwise\nfalse (.F.)",
    "DESCRIPTION": "This function returns a logical true (.T.) if a file lock is\nattempted and is successfully placed on the current or designated\ndatabase. This function will also unlock all records locks placed\nby the same network station.",
    "EXAMPLES": "LOCAL nSum\nUSE test NEW\nIF FLock()\n   SUM test->age TO nSum\n   ? nSum\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "RLock()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "Found()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Determine the success of a previous search operation.",
    "SYNTAX": "Found() --> lSuccess",
    "ARGUMENTS": "(This function has no arguments)",
    "RETURNS": "<lSuccess> A logical true (.T.) is successful; otherwise, false (.F.)",
    "DESCRIPTION": "This function is used to test if the previous SEEK, LOCATE, CONTINUE,\nor FIND operation was successful. Each work area has its own Found()\nflag, so that a Found() condition may be tested in unselected work\nareas by using an alias.",
    "EXAMPLES": "LOCAL nAge := 40\nUSE test NEW\nINDEX ON field->age TO test\nSEEK nAge\nIF Found()\n   ? test->first\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "Eof()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "Header()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Return the length of a database file header",
    "SYNTAX": "Header() --> nBytes",
    "RETURNS": "<nBytes> The numeric size of a database file header in bytes",
    "DESCRIPTION": "This function returns the number of bytes in the header of the\nselected database of the database in the designated work area.\n\nIf used in conjunction with the LastRec(), RecSize() and DiskSpace()\nfunctions, this functions is capable of implementing a backup and\nrestore routine.",
    "EXAMPLES": "USE test NEW\n? Header()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "DiskSpace(), LastRec(), RecSize()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "LastRec()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Returns the number of records in an active work area or database.",
    "SYNTAX": "LastRec() | RecCount()* --> nRecords",
    "RETURNS": "<nRecords > The number of records",
    "DESCRIPTION": "This function returns the number of records present in the database\nin the selected or designated work area. If no records are present\nthe value of this function will be 0. Additionally, if no database is\nin use in the selected or designated work area, this function will\nreturn a 0 value as well.",
    "EXAMPLES": "USE test NEW\n? LastRec(), RecCount()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is rdd",
    "SEEALSO": "Eof()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "LUpdate()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Yields the date the database was last updated.",
    "SYNTAX": "LUpdate() --> dModification",
    "ARGUMENTS": "(This function has no arguments)",
    "RETURNS": "<dModification>  The date of the last modification.",
    "DESCRIPTION": "This function returns the date recorded by the OS when the selected\nor designated database was last written to disk. This function will\nonly work for those database files in USE.",
    "EXAMPLES": "USE test NEW\n? LUpdate()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is rdd",
    "SEEALSO": "FieldName(), LastRec(), RecSize()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "NetErr()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Tests the success of a network function",
    "SYNTAX": "NetErr( [<lNewError>] ) --> lError",
    "ARGUMENTS": "<lNewError> Is a logical Expression.",
    "RETURNS": "<lError> A value based on the success of a network operation or\nfunction.",
    "DESCRIPTION": "This function return a logical true (.T.) is a USE, dbAppend(), or\na `USE...EXCLUSIVE` command is issue and fails in a network environment.\nIn the case of USE and `USE...EXCLUSIVE` commands, a NetErr() value\nof .T. would be returned if another node of the network has the\nexclusive use of a file. And the case of the dbAppend() command,\nNetErr() will return a logical true (.T.) if the file or record\nis locked by another node or the value of LastRec() has been advanced\nThe value of NetErr() may be changed via the value of <lNewError>.\nThis allow the run-time error-handling system to control the way\ncertain errors are handled.",
    "EXAMPLES": "USE test NEW\nIF ! NetErr()\n   INDEX ON field->first TO test\n   SET INDEX TO test\n   test->first := \"Harbour\"\n   IF dbSeek( \"Harbour\" )\n      ? test->first\n   ENDIF\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "FLock(), RLock()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "RecCount()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Counts the number of records in a database.",
    "SYNTAX": "RecCount()* | LastRec() --> nRecords",
    "ARGUMENTS": "(This function has no arguments)",
    "RETURNS": "<nRecords>  The number of records\nCRIPTION$*\nThis function returns the number of records present in the database\nin the selected or designated work area. If no records are present\nthe value of this function will be 0. Additionally, if no database is\nin use in the selected or designated work area, this function will\nreturn a 0 value as well.",
    "EXAMPLES": "USE test NEW\n? RecCount()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "Eof(), LastRec(), RecNo(), dbGoBottom()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "RecNo()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Returns the current record number or identity.",
    "SYNTAX": "RecNo() --> Identity",
    "ARGUMENTS": "(This function has no arguments)",
    "RETURNS": "RecNo() The record number or identity",
    "DESCRIPTION": "This function returns the position of the record pointer in the\ncurrently selected of designated work area.\n\nIf the database file is empty and if the RDD is the traditional .dbf\nfile, the value of this function will be 1.",
    "EXAMPLES": "USE test NEW\ndbGoTop()\n? RecNo()     // --> 1\ndbGoto( 50 )\n? RecNo()     // --> 50",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "dbGoto(), dbGoTop(), dbGoBottom(), LastRec(), Eof(), Bof()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "RecSize()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Returns the size of a single record in an active database.",
    "SYNTAX": "RecSize() --> nBytes",
    "ARGUMENTS": "(This function has no arguments)",
    "RETURNS": "<nBytes> The record size.",
    "DESCRIPTION": "This function returns the number of bytes used by a single record\nin the currently selected or designated database file. If no database\nis in use in this work area, the return value from this function\nwill be 0.",
    "EXAMPLES": "USE test NEW\ndbGoTop()\n? RecSize()   // --> 1\ndbGoto( 50 )\n? RecSize()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "DiskSpace(), FieldName(), Header(), LastRec()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "RLock()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Lock a record in a work area",
    "SYNTAX": "RLock() --> lSuccess",
    "ARGUMENTS": "(This function has no arguments)",
    "RETURNS": "RLock() True (.T.) if record lock is successful; otherwise, it\nreturns false (.F.).",
    "DESCRIPTION": "This function returns a logical true (.T.) if an attempt to lock a\nspecific record in a selected or designated work area is successful.\nIt will yield a false (.F.) if either the file or the desired record\nis currently locked.\nA record that is locked remains locked until another RLock() is issued\nor until an UNLOCK command is executed.\nOn a Network environment the follow command need that the record is\nlocked:\n\n`@...GET`\n\nDELETE (single record)\n\nRECALL (single record)\n\nREPLACE (single record)",
    "EXAMPLES": "LOCAL nAge := 50\nUSE test NEW\nINDEX ON field->age TO test\nIF dbSeek( nAge ) .AND. RLock()\n   dbDelete()\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "FLock()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "Select()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Returns the work area number for a specified alias.",
    "SYNTAX": "Select( [<cAlias>] ) --> nWorkArea",
    "ARGUMENTS": "<cAlias> is the target work area alias name.",
    "RETURNS": "Select() returns the work area number.",
    "DESCRIPTION": "This function returns the work area number for the specified alias\nname <cAlias>. If no parameter is specified, the current work area will\nbe the return value of the function.",
    "EXAMPLES": "LOCAL cOldArea\nUSE test NEW\nUSE names NEW\ncOldArea := Select( \"names\" )\nSELECT test\nLIST\nSELECT cOldArea",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "Alias(), Used()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Function",
    "NAME": "Used()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Checks whether a database is in use in a work area",
    "SYNTAX": "Used() --> lDbfOpen",
    "ARGUMENTS": "(This function has no arguments)",
    "RETURNS": "<lDbfOpen> True is a database is Used;otherwise False",
    "DESCRIPTION": "This function returns a logical true (.T.) if a database file is in\nUSE in the current or designated work area. If no alias is specified\nalong with this function , it will default to the currently selected\nwork area.",
    "EXAMPLES": "USE test NEW\nUSE names NEW\n? Used()            // --> .T.\n? test->( Used() )  // --> .T.\ndbCloseArea()\n? Used()            // --> .F.\nSELECT test\n? Used()            // --> .T.",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": "Alias(), Select()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddmisc.txt",
    "TEMPLATE": "Command",
    "NAME": "PACK",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Database",
    "ONELINER": "Remove records marked for deletion from a database",
    "SYNTAX": "PACK",
    "ARGUMENTS": "(This command has no arguments)",
    "DESCRIPTION": "This command removes records that were marked for deletion from the\ncurrently selected database. This command does not pack the contents\nof a memo field; those files must be packed via low-level functions.\n\nAll open index files will be automatically reindexed once PACK command\nhas completed its operation. On completion, the record pointer is placed\non the first record in the database.",
    "EXAMPLES": "USE test\ndbGoto( 10 )\nDELETE NEXT 10\n? LastRec()\nPACK\n? LastRec()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "dbEval(), DELETE, Deleted(), ZAP, RECALL"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddord.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "ordBagExt()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Returns the Order Bag extension",
    "SYNTAX": "ordBagExt() --> cBagExt",
    "ARGUMENTS": "None",
    "RETURNS": "<cBagExt> The RDD extension name.",
    "DESCRIPTION": "This function return th character name of the RDD extension for\nthe order bag. This is determined by the active RDD for the selected\nwork area.\n\nThis function replaces the IndexOrd() function.",
    "EXAMPLES": "USE test VIA \"DBFNTX\"\n? ordBagExt()  // --> \".ntx\"\nUSE test VIA \"DBFCDX\"\n? ordBagExt()  // --> \".cdx\"",
    "STATUS": "S",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is rdd",
    "SEEALSO": "IndexExt(), ordBagName()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddord.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "ordBagName()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Returns the Order Bag Name.",
    "SYNTAX": "ordBagName( <nOrder> | <cOrderName> ) --> cOrderBagName",
    "ARGUMENTS": "<nOrder> A numeric value representing the Order bag number.\n\n<cOrderName> The character name of the Order Bag.",
    "RETURNS": "ordBagName() returns the Order bag name",
    "DESCRIPTION": "This function returns the name of the order bag for the specified\nwork area. If <nOrder> is specidied, it will represent the position\nin the order list of the target order. If <cOrderName> is specified,\nit will represent the name of the target order. In essence, it will\ntell the name of the database (if That RDD is in use) for a given\nindex name or index order number. If <cOrderName> is not specified\nor <nOrder> is 0, the Current active order will be used.",
    "EXAMPLES": "USE test VIA \"DBFCDX\" NEW\nSET INDEX TO test\n? ordBagName( \"TeName\" )    // --> \"Customer\"\n? ordBagName( \"TeLast\" )    // --> \"Customer\"\n? ordBagName( \"teZip\" )     // --> \"Customer\"\nordSetFocus( \"TeName\" )\n? ordBagName()              // --> \"Custumer\"",
    "STATUS": "S",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is rdd",
    "SEEALSO": "IndexOrd(), ordBagExt(), Alias()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddord.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "ordCondSet()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Set the Condition and scope for an order",
    "SYNTAX": "ordCondSet( [<cForCondition>],\n  [<bForCondition>],\n  [<lAll>],\n  [<bWhileCondition>],\n  [<bEval>],\n  [<nInterval>],\n  [<nStart>],\n  [<nNext>],\n  [<nRecord>],\n  [<lRest>],\n  [<lDescend>],\n  [<lAdditive>],\n  [<lCurrent>],\n  [<lCustom>],\n  [<lNoOptimize>] )",
    "ARGUMENTS": "<cForCondition> is a string that specifies the FOR condition for the\norder.\n\n<bForCondition> is a code block that defines a FOR condition that\neach record within the scope must meet in order to be processed. If\na record does not meet the specified condition, it is ignored and the\nnext  record is processed. Duplicate keys values are not added to the\nindex file when a FOR condition is Used.",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "S",
    "COMPLIANCE": "C",
    "FILES": "Library is rdd",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddord.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "ordCreate()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Create an Order in an Order Bag",
    "SYNTAX": "ordCreate( <cOrderBagName>,[<cOrderName>], <cExpKey>,\n[<bExpKey>], [<lUnique>] )",
    "ARGUMENTS": "<cOrderBagName>  Name of the file that contains one or more Orders.\n\n<cOrderName> Name of the order to be created.\n\n<cExpKey> Key value for order for each record in the current work area\n\n<bExpKey> Code block that evaluates to a key for the order for each\nrecord in the work area.\n\n<lUnique> Toggle the unique status of the index.",
    "DESCRIPTION": "This function creates an order for the current work area. It is\nsimilar to the dbCreateIndex() except that this function allows\ndifferent orders based on the RDD in effect. The name of the file\n<cOrderBagName> or the name of the order <cOrderName> are technically\nboth considered to be \"optional\" except that at least one of two\nmust exist in order to create the order.\n\nThe parameter <cExpKey> is the index key expression; typically in\na .dbf driver, the maximum length of the key is 255 characters.\n\nIf <bExpKey> is not specified, then the code block is create by\nmacro expanding the value of <cExpKey>.\n\nIf <lUnique> is not specified, then the current internal setting of\n`SET UNIQUE ON` or OFF will be observed.\n\nThe active RDD driver determines the capacity in the order for a\nspecific order bag.\n\nIf the name <cOrderBagName> is found in the order bag can contain\na single order, the the name <cOrderBagName> is erased and a new\norder is added to the order list in the current or specified work\narea.On the other hand, if it can contain multiples tags and if\n<cOrderBagName> does not already exist in the order list, then it is\nadded. It is does exist, then the <cOrderBagName> replaces the former\nname in the order list in the current or specified work area.",
    "EXAMPLES": "USE test VIA \"DBFNTX\"\n? ordCreate( \"FNAME\",, \"field->first\" )\n\nUSE test VIA \"DBFCDX\"\n? ordCreate( , \"LNAME\", \"field->last\" )",
    "STATUS": "S",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is rdd",
    "SEEALSO": "dbCreateIndex(), ordName(), ordSetFocus()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddord.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "ordDestroy()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Remove an Order from an Order Bag",
    "SYNTAX": "ordDestroy( <cOrderName> [, <cOrderBagName> ] )",
    "ARGUMENTS": "<cOrderName> Name of the order to remove\n\n<cOrderBagName> Name of the order bag from which order id to be\nremoved",
    "DESCRIPTION": "This function attempts to remove the order named <cOrderName> from the\nfile containing the order bag name <cOrderBagName>. If <cOrderBagName>\nis not specified, then the name of the file will be based on the value\nof the ordName() function. If the extension is not included with the\nname of the order file, then the extension will be obtained from the\ndefault extension of the current and active RDD.\n\nThe DBFNTX driver do not support multiple order bags; therefore, there\ncannot be an order to \"destroy\" from a bag. This function only works\nfor those drivers with support multiple orders bags (e.q. DBFCDX\nand RDDADS drivers).",
    "EXAMPLES": "USE test VIA \"DBFCDX\" NEW\n? ordDestroy( \"lName\", \"test\" )",
    "STATUS": "S",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is rdd",
    "SEEALSO": "ordCreate()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddord.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "ordFor()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Return the FOR expression of an Order",
    "SYNTAX": "ordFor( <xOrder>[, <cOrderBagName>] ) --> cForExp",
    "ARGUMENTS": "<xOrder>  It the name of the target order, or the numeric position\nof the order.\n\n<cOrderBagName> Name of the order bag.",
    "RETURNS": "ordFor() returns a expression containing the FOR condition for\nan order.",
    "DESCRIPTION": "This function returns a character string that is the expression for\nthe FOR condition for the specified order. The order may be specified\nif <xOrder> is the name of the order. However, <xOrder> may be an\nnumeric which represent the position in the order list of the desired\nOrder.",
    "EXAMPLES": "USE test NEW VIA \"DBFCDX\"\nINDEX ON field->first TO test FOR field->age > 50\n? ordFor( \"test\" )        // --> \"field->age > 50\"",
    "STATUS": "S",
    "COMPLIANCE": "This function is CA-Cl*pper compliant with one exception:\nIf the <xOrder> paramter is not specified or <xOrder> is 0, the current\nactive order is used.",
    "PLATFORMS": "All",
    "FILES": "Library is rdd",
    "SEEALSO": "ordKey(), ordCreate(), ordName(), ordNumber()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddord.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "ordKey()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Return the key expression of an Order",
    "SYNTAX": "ordKey( <cOrderName> | <nOrder> [, <cOrderBagName>] ) --> cExpKey",
    "ARGUMENTS": "<xOrder>  It the name of the target order, or the numeric position\nof the order.\n\n<cOrderBagName> Name of the order bag.",
    "RETURNS": "<cExpKey> Returns a character string, cExpKey.",
    "DESCRIPTION": "",
    "EXAMPLES": "USE test NEW VIA \"DBFCDX\"\nINDEX ON field->first TO test FOR field->first > \"CK\"\nINDEX ON field->age   TO testage\n\n? ordKey( \"test\" )  // --> \"field->first\"\nordSetFocus( 2 )\n? ordKey()          // --> \"field->age\"",
    "STATUS": "S",
    "COMPLIANCE": "This function is CA-Cl*pper compliant with one exception:\nIf the <xOrder> paramter is not specified or <xOrder> is 0, the current\nactive order is used.",
    "PLATFORMS": "All",
    "FILES": "Library is rdd",
    "SEEALSO": "ordFor(), ordName(), ordNumber(), ordKey()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddord.txt",
    "TEMPLATE": "Function",
    "NAME": "IndexExt()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Returns the file extension of the index module used in an application",
    "SYNTAX": "IndexExt() --> cExtension",
    "ARGUMENTS": "None.",
    "RETURNS": "<cExtension>   Current driver file extension",
    "DESCRIPTION": "This function returns a string that tells what indexes are to be used\nor will be created in the compiled application. The default value is\n`.ntx`. This is controlled by the particular database driver that is\nlinked with the application.",
    "EXAMPLES": "IF IndexExt() == \".ntx\"\n   ? \"Current driver being used is DBFNTX\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is rdd",
    "SEEALSO": "IndexKey(), IndexOrd()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddord.txt",
    "TEMPLATE": "Function",
    "NAME": "IndexKey()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Yields the key expression of a specified index file.",
    "SYNTAX": "IndexKey( <nOrder> ) --> cIndexKey",
    "ARGUMENTS": "<nOrder>  Index order number",
    "RETURNS": "<cIndexKey>   The index key",
    "DESCRIPTION": "This function returns a character string stored in the header of the\nindex file\n\nThe index key is displayed for an index file that is designated by\n<nOrder>, its position in the `USE...INDEX` or `SET INDEX TO` command in\nthe currently selected or designated work area. If there is no\ncorresnponding index key at the specified order position, a NULL\nbyte will be returned.",
    "EXAMPLES": "USE test NEW\nINDEX ON field->first TO test\n? IndexKey( 1 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is rdd",
    "SEEALSO": "IndexOrd()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/rddord.txt",
    "TEMPLATE": "Function",
    "NAME": "IndexOrd()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Database",
    "ONELINER": "Returns the numeric position of the controlling index.",
    "SYNTAX": "IndexOrd() --> nPosition",
    "ARGUMENTS": "None.",
    "RETURNS": "<nPosition>   Ordinal position of a controling index",
    "DESCRIPTION": "The IndexOrd() function returns the numeric position of the current\ncontrolling index in the selected or designated work area.\nA returned value of 0 indicated that no active index is controlling\nthe database, which therefore is in the natural order.",
    "EXAMPLES": "USE test NEW\nINDEX ON field->first TO test\nIF IndexOrd() > 0\n   ? \"Current order is\", hb_ntos( IndexOrd() )\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is rdd",
    "SEEALSO": "IndexKey()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/readvar.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "ReadVar()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Return variable name of current GET or MENU",
    "SYNTAX": "ReadVar( [<cVarName>] ) --> cOldVarName",
    "ARGUMENTS": "<cVarName> is a new variable name to set.",
    "RETURNS": "ReadVar() return the old variable name. If no variable previously\nwas set, ReadVar() return \"\".",
    "DESCRIPTION": "ReadVar() is set inside a READ or `MENU TO` command to hold the\nuppercase name of the GET / `MENU TO` variable, and re-set back to old\nvalue when those commands finished. You should not normally set a\nvariable name but rather use it to retrieve the name of a GET\nvariable when executing a VALID or WHEN clause, or during `SET KEY`\nexecution and you are inside a READ or `MENU TO`.",
    "EXAMPLES": "#include \"inkey.ch\"\nLOCAL What_Is_Bug\n// display a menu, press <F1> to view the MENU TO variable name\nCLS\n@ 1, 10 PROMPT \"blood sucking insect that infect beds   \"\n@ 2, 10 PROMPT \"germ; virus infection                   \"\n@ 3, 10 PROMPT \"defect; snag; (source of) malfunctioning\"\n@ 4, 10 PROMPT \"small hidden microphone                 \"\n@ 6, 10 SAY \"(Press <F1> for a hint)\"\nSetKey( K_F1, {|| ShowVar() } )\nMENU TO What_Is_Bug\n\nSTATIC PROCEDURE ShowVar()\n   Alert( ReadVar() )  // --> \"WHAT_IS_BUG\"\n   RETURN",
    "STATUS": "R",
    "COMPLIANCE": "ReadVar() works exactly like CA-Cl*pper's ReadKey().\n\nNote however,\nthat the <cVarName> parameter is not documented and used internally\nby CA-Cl*pper.",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "@...GET, @...PROMPT, MENU TO, READ, SetKey(), __AtPrompt(), __MenuTo()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/sayget.txt",
    "TEMPLATE": "Command",
    "NAME": "@...GET",
    "CATEGORY": "Command",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Creates a GET object and displays it to the screen",
    "SYNTAX": "@ <nRow>, <nCol> [SAY <cSay> [PICTURE <cSayPict>] COLOR <cSayColor> ]\nGET <xVar> [PICTURE <cGetPict>] [WHEN <lWhen>] [COLOR <cGetColor>]\n[VALID <lValid> / RANGE <xStart>, <xEnd>]",
    "ARGUMENTS": "<nRow>      The row coordinate.\n\n<nCol>      The column coordinate.\n\n<cSay>      Message to display.\n\n<cSayPict>  Character expression of PICTURE displayed.\n\n<cSayColor> Color to be Used for the SAY expression.\n\n<xVar>      An variable/field name.\n\n<cGetPict>  Character expression of PICTURE to get.\n\n<lWhen>     Logical expression to allow GET.\n\n<lValid>    Logical expression to validate GET input.\n\n<xStart>    Lower RANGE value.\n\n<xEnd>      Upper RANGE value.\n\n<cGetColor> Color string to be used for the GET expression.",
    "DESCRIPTION": "This command adds a GET object to the reserved array variable\nnamed `GetList` and displays it to the screen. The field or variable\nto be added to the GET object is specified in <xVar> and is displayed\nat row, column coordinate <nRow>, <nCol>.\n\nIf the SAY clause is used <cSay> will be displayed starting at\n<nRow>, <nCol>, with the field variable <xVar> displayed at Row(),\n`Col() + 1`. If <cSayPicr>, the picture template for the SAY expression\n<cSay>, is used, all formatting rules contained will apply See the\nTRANSFORM I function for further information.\n\nIf <cGetPict> is specified, the PICTURE clause of <xVar> will be\nused for the GET object and all formatting rules will apply. See\nthe table below for GET formatting rules.\n\nIf the WHEN clause is specified, when <lWhen> evaluates to a logical\ntrue (.T.) condition, the GET object will he activated otherwise the\nGET object will be skipped and no information will be obtained via\nthe screen. The name of a user-defined function returning a logical\ntrue (.T.) or false ( F.) or a code block may be, specified in <lWhen>\nThis clause not activated until a READ command or ReadModal()\nfunction call is issued.\n\nIf the VALID clause is specified and <lValid> evaluates to it logical\ntrue (.T.) condition the current GET will be considered valid and\nthe get operation will continue onto the next active GET object. If\nnot, the cursor will remain on this GET object until aborted or\nuntil the condition in <lValid> evaluates to true (.T.). The name\nof a user-defined function returning a logical true (.T.) or false\n(.F.) or it code block may be specified in <lValid>. This clause is\nnot activated until a READ command or ReadModal() function call is\nissued.\n\nIf the RANGE clause is specified instead of the VALID clause, the\ntwo inclusive range values for <xVar> must be specified in <xStart>\nand <xEnd>. Id <xVar> is a date data type, <xStart> and <xEnd> must\nalso be date data types; if <xVar> is a numeric data type <xStart>\nand <xEnd> must also be numeric data types. If a value fails the\nRANGE test, the message \"OUT OF RANGE\" will appear in the SCOREBOARD\narea (row = 0, col = 60). The RANGE message may be turned off it the\n`SET SCOREBOARD` command or Set() function appropriately toggled.\n",
    "NOTES": "GET functions/formatting rules:\n\n<table-noheader>\n@A          Allows only alphabetic characters.\n@B          Numbers will be left justified\n@C          All positive numbers will be followed by CR.\n@D          All dates will be in the SET DATE format.\n@E          Dates will be in British formal: numbers in European format.\n@K          Allows a suggested value to be seen within the GET\n            area but clears It if any non cursor key is pressed when\n            the cursor is in the first Position in the GET area.\n@R          Non template characters will be inserted.\n@S<nSize>   Allows horizontal scrolling of a field or variable that\n            is <nSize> characters wide.\n@X          All negative numbers will be followed by DB\n@Z          Displays zero values as blanks.\n@!          Forces uppercase lettering\n@(          Displays negative numbers in parentheses with leading spaces.\n@)          Displays negative numbers in parentheses without leading spaces.\n</table>\n\nGET templates/formatting rules:\n\n<table-noheader>\nA   Only alphabetic characters allowed.\nN   Only alphabetic and numeric characters allowed\nX   Any character allowed.\nL   Only T or F allowed For logical data.\nY   Only Y or N allowed for logical data.\n9   Only digits, including signs, will be allowed.\n#   Only digits, signs. and spaces will he allowed.\n!   Alphabetic characters are converted to Uppercase.\n$   Dollar  will be displayed in place of leading\n    spaces for numeric data types.\n*   Asterisk,, will Be displayed in place of leading spaces\n    for numeric data types.\n.   Position of decimal point.\n,   Position of comma.\n</table>\n\nFormat PICTURE functions may he grouped together as well as used\nin conjunction with a PICTURE templates; however, a blank space must\nbe included in the PICTURE string if there are both functions and\ntemplates.",
    "EXAMPLES": "LOCAL cVar := Space( 50 ), nId := 0\nLOCAL GetList := {}\nCLS\n@ 3, 1 SAY \"Name\" GET cVar PICTURE \"@!S 30\"\n@ 4, 1 SAY \"Id\"   GET nId  PICTURE \"999.999\"\nREAD\n? \"The name you entered is\", cVar\n? \"The id you entered is\", nId",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "SEEALSO": "@...SAY, READ, Transform()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/sayget.txt",
    "TEMPLATE": "Command",
    "NAME": "@...SAY",
    "CATEGORY": "Command",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Displays data at specified coordinates of the current device.",
    "SYNTAX": "@ <nRow>, <nCol> SAY <xValue> [ PICTURE <cPict> ] [COLOR <cColor>]",
    "ARGUMENTS": "<nRow>     Row coordinate\n\n<nCol>     Column coordinate\n\n<xValue>   Value to display\n\n<cPict>    PICTURE format\n\n<cColor>   Color string",
    "DESCRIPTION": "This command displays the contents of <xValue> at row column\ncoordinates <nRow>, <nCol>. A PICTURE clause may be specified\nin <cPict>. If the current device is set to the printer, the output\nwill go to the printer; the default is for all output to go to\nthe screen.\n\nFor a complete list of PICTURES templates and functions, see the\n`@...GET` command.",
    "EXAMPLES": "CLS\n@ 2, 1 SAY \"Harbour\"\n@ 3, 1 SAY \"is\" COLOR \"b/r+\"\n@ 4, 1 SAY \"Power\" PICTURE \"@!\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "",
    "SEEALSO": "@...GET, SET DEVICE, Transform()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 1999 David G. Holm <dholm@jsd-llc.com>",
    "TEMPLATE": "Function",
    "NAME": "__SetCentury()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Set the Current Century",
    "SYNTAX": "__SetCentury([<lFlag> | <cOnOff> ] ) --> lPreviousValue",
    "ARGUMENTS": "optional <lFlag> or <cOnOff> (not case sensitive)\n        .T. or `\"ON\"` to enable the century setting (4-digit years)\n        .F. or `\"OFF\"` to disable the century setting (2-digit years)",
    "RETURNS": "Either the current or previous century setting as a logical value",
    "FILES": "Library is core",
    "COMPLIANCE": "C"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 1999 David G. Holm <dholm@jsd-llc.com>",
    "TEMPLATE": "Function",
    "NAME": "Set()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Changes or evaluated environmental settings",
    "SYNTAX": "Set( <nSet> [, <xNewSetting> [, <xOption> ] ] ) --> xPreviousSetting",
    "ARGUMENTS": "<nSet> Set Number\n\n<xNewSetting> Any expression to assign a value to the setting\n\n<xOption> Logical expression\n\n          <nSet>            <xNewSetting>          <xOption>\n\n        `_SET_ALTERNATE`   <lFlag> | <cOnOff>\n\n             If enabled, QOut() and QQOut() write to the screen and to\n             a file, provided that a file has been opened or created\n             with `_SET_ALTFILE`. If disabled, which is the default,\n             QOut() and QQOut() only write to the screen (and/or to\n             the PRINTFILE). Defaults to disabled.\n\n        `_SET_ALTFILE`     <cFileName>             <lAdditive>\n\n             When set, creates or opens file to write QOut() and\n             QQOut() output to. If <lAdditive> is TRUE and the file\n             already exists, the file is opened and positioned at end\n             of file. Otherwise, the file is created. If a file is\n             already opened, it is closed before the new file is\n             opened or created (even if it is the same file). The\n             default file extension is `.txt`. There is no default\n             file name. Call with an empty string to close the file.\n\n        `_SET_AUTOPEN`     <lFlag> | <cOnOff>\n\n             TODO: Document\n\n        `_SET_AUTORDER`    <lFlag> | <cOnOff>\n\n             TODO: Document\n\n        `_SET_AUTOSHARE`   <lFlag> | <cOnOff>\n\n             TODO: Document\n\n        `_SET_BELL`        <lFlag> | <cOnOff>\n\n             When enabled, the bell sounds when the last position of\n             a GET is reached and/or when a GET validation fails.\n             Disabled by default.\n\n        `_SET_CANCEL`      <lFlag> | <cOnOff>\n\n             When enabled, which is the default, pressing <Alt+C> or\n             <Ctrl+Break> terminates the program. When disabled, both\n             keystrokes can be read by Inkey(). Note: `SET KEY` has\n             precedence over `SET CANCEL`.\n\n        `_SET_COLOR`       <cColorSet>\n\n             Sets the current color scheme, using color pairs in the\n             sequence `\"<standard>, <enhanced>, <border>, <background>,\n             <unselected>\"`. Each color pair uses the format\n             `\"<foreground>/<background>\"`. The color codes are space\n             or `\"N\"` for black, `\"B\"` for blue, `\"G\"` for green, `\"BG\"` for\n             Cyan, `\"R\"` for red, `\"RB\"` for magenta, `\"GR\"` for brown, `\"W\"`\n             for white, `\"N+\"` for gray, `\"B+\"` for bright blue, `\"G+\"` for\n             bright green, `\"BG+\"` for bright cyan, `\"R+\"` for bright red,\n             `\"RB+\"` for bright magenta, `\"GR+\"` for yellow, and `\"W+\"` for\n             bright white. Special codes are `\"I\"` for inverse video,\n             `\"U\"` for underline on a monochrome monitor (blue on a\n             color monitor), and `\"X\"` for blank. The default color is\n             `\"W/N,N/W,N,N,N/W\"`.\n\n        `_SET_CONFIRM`     <lFlag> | <cOnOff>\n\n             If enabled, an exit key must be pressed to leave a GET.\n             If disabled, which is the default, typing past the end\n             will leave a GET.\n\n        `_SET_CONSOLE`     <lFlag> | <cOnOff>\n\n             If enabled, which is the default, all screen output goes\n             to the screen. When disabled, screen output is suppressed\n             (Note: This setting does not affect OutStd() or OutErr()).\n\n        `_SET_CURSOR`      <nCursorType>\n\n             If enabled, which is the default, the cursor is displayed\n             on screen. If disabled, the screen cursor is hidden.\n\n        `_SET_DATEFORMAT`  <cDateFormat>\n\n             Sets the default date format for display, date input, and\n             date conversion. Defaults to American `mm/dd/yy`. Other\n             formats include ANSI `yy.mm.dd`, British `dd/mm/yy`,\n             French `dd/mm/yy`, German `dd.mm.yy`, Italian\n             `dd-mm-yy`, Japan `yy/mm/dd`, and USA `mm-dd-yy`.\n             `SET CENTURY` modifies the date format. `SET CENTURY ON`\n             replaces the `y`s with `YYYY`. `SET CENTURY OFF` replaces\n             the `y`s with `YY`.\n\n        `_SET_DEBUG`       <lStatus>\n\n             When set to .T., pressing <Alt+D> activates the debugger.\n             When set to .F., which is the default, <Alt+D> can be read\n             by Inkey(). (Also affected by `AltD( 1 )` and `AltD( 0 )`)\n\n        `_SET_DECIMALS`    <nNumberOfDecimals>\n\n             Sets the number of decimal digits to use when displaying\n             printing numeric values when `SET FIXED` is ON. Defaults to\n             2. If `SET FIXED` is OFF, then `SET DECIMALS` is only used to\n             determine the number of decimal digits to use after using\n             Exp(), Log(), Sqrt(), or division. Other math operations\n             may adjust the number of decimal digits that the result\n             will display. Note: This never affects the precision of\n             a number. Only the display format is affected.\n\n        `_SET_DEFAULT`     <cDefaultDirectory>\n\n             Sets the default directory in which to open, create and\n             check for files. Defaults to current directory (blank).\n\n        `_SET_DELETED`     <lFlag> | <cOnOff>\n\n             If enabled, deleted records will be processed. If\n             disabled, which is the default, deleted records will\n             be ignored.\n\n        `_SET_DELIMCHARS`  <cDelimiters>\n\n             Sets the GET delimiter characters. Defaults to `\"::\"`.\n\n        `_SET_DELIMITERS`  <lFlag> | <cOnOff>\n\n             If enabled, GETs are delimited on screen. If disabled,\n             which is the default, no GET delimiters are used.\n\n        `_SET_DEVICE`      <cDeviceName>\n\n             Selects the output device for DevOut(). When set to\n             `\"PRINTER\"`, all output is sent to the printer device or\n             file set by `_SET_PRINTFILE`. When set to anything else,\n             all output is sent to the screen. Defaults to `\"SCREEN\"`.\n\n        `_SET_EOF`         <lFlag> | <cOnOff>\n\n             Defaults to FALSE on *nix, but defaults to TRUE on\n             everything else. If set to FALSE, then `Chr( 26 )` does not\n             get written when using `COPY TO DELIMITED`, `COPY TO SDF`,\n             or when closing any of the various text files that are\n             created using various SET values.\n             [This is a Harbour extension]\n\n        `_SET_EPOCH`       <nYear>\n\n             Determines how to handle the conversion of 2-digit years\n             to 4 digit years. When a 2-digit year is greater than or\n             equal to the year part of the epoch, the century part of\n             the epoch is added to the year. When a 2-digit year is\n             less than the year part of the epoch, the century part\n             of the epoch is incremented and added to the year. The\n             default epoch is 1900, which converts all 2-digit years\n             to 19xx. Example: If the epoch is set to 1950, 2-digit\n             years in the range from 50 to 99 get converted to 19xx\n             and 2-digit years in the range 00 to 49 get converted\n             to 20xx.\n\n        `_SET_ESCAPE`      <lFlag> | <cOnOff>\n\n             When enabled, which is the default, pressing <Esc> will\n             exit a READ. When disabled, pressing <Esc> during a READ\n             is ignored, unless the <Esc> key has been assigned to a\n             function using `SET KEY`.\n\n        `_SET_EVENTMASK`   <nEventCodes>\n\n             Determines which events Inkey() will respond to.\n             INKEY_MOVE allows mouse movement events. INKEY_LDOWN\n             allows the left mouse button down click. INKEY_LUP\n             allows the left mouse button up click. INKEY_RDOWN\n             allows the right mouse button down click. INKEY_RUP\n             allows the right mouse button up clock. INKEY_KEYBOARD\n             allows keyboard keystrokes. INKEY_ALL allows all of the\n             preceding events. Events may be combined (e.g., using\n             `INKEY_LDOWN + INKEY_RUP` will allow left mouse button\n             down clicks and right mouse button up clicks). The\n             default is INKEY_KEYBOARD.\n\n        `_SET_EXACT`       <lFlag> | <cOnOff>\n\n             When enabled, all string comparisons other than `==`\n             exclude trailing spaces when checking for equality.\n             When disabled, which is the default, all string\n             comparisons other than `==` treat two strings as\n             equal if the right hand string is \"\" or if the right\n             hand string is shorter than or the same length as the\n             left hand string and all of the characters in the right\n             hand string match the corresponding characters in the\n             left hand string.\n\n        `_SET_EXCLUSIVE`   <lFlag> | <cOnOff>\n\n             When enabled, which is the default, all database files\n             are opened in exclusive mode. When disabled, all\n             database files are opened in shared mode. Note: The\n             EXCLUSIVE and SHARED clauses of the USE command can be\n             used to override this setting.\n\n        `_SET_EXIT`        <lFlag> | <cOnOff>\n\n             Toggles the use of <Up> and <Down> as READ exit keys.\n             Specifying true (.T.) enables them as exit keys, and\n             false (.F.) disables them. Used internally by the\n             ReadExit() function.\n\n        `_SET_EXTRA`       <lFlag> | <cOnOff>\n\n             QUESTION: What is this for?\n             It does not affect `_SET_EXTRAFILE` in CA-Cl*pper!\n\n        `_SET_EXTRAFILE`   <cFileName>             <lAdditive>\n\n             When set, creates or opens file to write QOut() and\n             QQOut() output to. If <lAdditive> is TRUE and the file\n             already exists, the file is opened and positioned at end\n             of file. Otherwise, the file is created. If a file is\n             already opened, it is closed before the new file is\n             opened or created (even if it is the same file). The\n             default file extension is `.prn`. There is no default\n             file name. Call with an empty string to close the file.\n\n        `_SET_FIXED`       <lFlag> | <cOnOff>\n\n             When enabled, all numeric values will be displayed\n             and printed with the number of decimal digits set\n             by `SET DECIMALS`, unless a PICTURE clause is used.\n             When disabled, which is the default, the number\n             of decimal digits that are displayed depends upon\n             a variety of factors. See `_SET_DECIMALS` for more.\n\n        `_SET_INSERT`      <lFlag> | <cOnOff>\n\n             When enabled, characters typed in a GET or MemoEdit()\n             are inserted. When disabled, which is the default,\n             characters typed in a GET or MemoEdit() overwrite.\n             Note: This setting can also be toggled between on and\n             off by pressing the Insert key during a GET or MemoEdit().\n\n        `_SET_INTENSITY`   <lFlag> | <cOnOff>\n\n             When enabled, which is the default, GETs and PROMPTs\n             are displayed using the enhanced color setting. When\n             disabled, GETs and PROMPTs are displayed using the\n             standard color setting.\n\n        `_SET_LANGUAGE`    <cLanguageID>\n\n             Specifies the language to be used for Harbour messages.\n             [This is a Harbour extension]\n\n        `_SET_MARGIN`      <nColumns>\n\n             Sets the left margin for all printed output. The default\n             value is 0. Note: PCol() reflects the printer's column\n             position including the margin (e.g., `SET MARGIN TO 5`\n             followed by `DevPos( 5, 10 )` makes PCol() return 15).\n\n        `_SET_MBLOCKSIZE` <nMemoBlockSize>\n\n             TODO: Document\n\n        `_SET_MCENTER`     <lFlag> | <cOnOff>\n\n             If enabled, display PROMPTs centered on the MESSAGE row.\n             If disabled, which is the default, display PROMPTS at\n             column position 0 on the MESSAGE row.\n\n        `_SET_MESSAGE`     <nRow>\n\n             If set to 0, which is the default, PROMPTs are always\n             suppressed. Otherwise, PROMPTs are displayed on the\n             set row. Note: It is not possible to display prompts\n             on the top-most screen row, because row 0 is reserved\n             for the SCOREBOARD, if enabled.\n\n        `_SET_MFILEEXT`    <cMemoFileExt>\n\n             TODO: Document\n\n        `_SET_OPTIMIZE`    <lFlag> | <cOnOff>\n\n             TODO: Document\n\n        `_SET_PATH`        <cDirectories>\n\n             Specifies a path of directories to search through to\n             locate a file that cannot be located in the DEFAULT\n             directory. Defaults to no path `\"\"`. Directories must\n             be separated by a semicolon (e.g., `/hb/bin;/hb/tests`).\n\n        `_SET_PRINTER`     <lFlag> | <cOnOff>\n\n             If enabled, QOut() and QQOut() write to the screen and to\n             a file, provided that a file has been opened or created\n             with `_SET_ALTFILE`. If disabled, which is the default,\n             QOut() and QQOut() only write to the screen (and/or to\n             the ALTFILE).\n\n        `_SET_PRINTFILE`   <cFileName>             <lAdditive>\n\n             When set, creates or opens file to write QOut(), QQOut()\n             and DevOut() output to. If <lAdditive> is TRUE and the\n             file already exists, the file is opened and positioned\n             at end of file. Otherwise, the file is created. If a\n             file is already opened, it is closed before the new file\n             is opened or created (even if it is the same file). The\n             default file extension is `.prn`. The default file name\n             is `PRN`, which maps to the default printer device. Call\n             with an empty string to close the file.\n\n        `_SET_SCOREBOARD`  <lFlag> | <cOnOff>\n\n             When enabled, which is the default, READ and MemoEdit()\n             display status messages on screen row 0. When disabled,\n             READ and MemoEdit() status messages are suppressed.\n\n        `_SET_SCROLLBREAK` <lFlag> | <cOnOff>\n\n             QUESTION: What is this flag for?\n\n        `_SET_SOFTSEEK`    <lFlag> | <cOnOff>\n\n             When enabled, a SEEK that fails will position the record\n             pointer to the first key that is higher than the sought\n             after key or to `LastRec() + 1` if there is no higher key.\n             When disabled, which is the default, a SEEK that fails\n             will position the record pointer to `LastRec() + 1`.\n\n        `_SET_STRICTREAD`  <lFlag> | <cOnOff>\n\n             TODO: Document\n\n        `_SET_TYPEAHEAD`   <nKeyStrokes>\n\n             Sets the size of the keyboard typeahead buffer. Defaults\n             to 50. The minimum is 16 and the maximum is 4096.\n\n        `_SET_UNIQUE`      <lFlag> | <cOnOff>\n\n             When enabled, indexes are not allowed to have duplicate\n             keys. When disabled, indexes are allowed duplicate keys.\n\n        `_SET_VIDEOMODE`   <nValue>\n\n             TODO: Document\n\n        `_SET_WRAP`        <lFlag> | <cOnOff>\n\n             When enabled, lightbar menus can be navigated from the\n             last position to the first and from the first position\n             to the last. When disabled, which is the default, there\n             is a hard stop at the first and last positions.",
    "RETURNS": "Set() The current or previous setting",
    "FILES": "Library is core",
    "COMPLIANCE": "C"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__SetFunction()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Events",
    "ONELINER": "Assign a character string to a function key",
    "SYNTAX": "__SetFunction( <nFunctionKey>, [<cString>] ) --> NIL",
    "ARGUMENTS": "<nFunctionKey> is a number in the range 1..40 that represent the\nfunction key to be assigned.\n\n<cString> is a character string to set. If <cString> is not\nspecified, the function key is going to be set to NIL releasing by\nthat any previous __SetFunction() or SetKey() for that function.",
    "RETURNS": "__SetFunction() always return NIL.",
    "DESCRIPTION": "__SetFunction() assign a character string with a function key, when\nthis function key is pressed, the keyboard is stuffed with this\ncharacter string. __SetFunction() has the effect of clearing any\nSetKey() previously set to the same function number and vice versa.\n\n<table>\n nFunctionKey   Key to be set\n\n  1 .. 12       <F1> .. <F12>\n 13 .. 20       <Shift+F3> .. <Shift+F10>\n 21 .. 30       <Ctrl+F1> .. <Ctrl+F10>\n 31 .. 40       <Alt+F1> .. <Alt+F10>\n</table>\n\n`SET FUNCTION` command is preprocessed into __SetFunction() function\nduring compile time.",
    "EXAMPLES": "#include \"inkey.ch\"\nLOCAL cTest, GetList := {}\n// Associate <F1> with a string\n__SetFunction( 1, \"I Am Lazy\" + Chr( K_ENTER ) )\nCLS\ncTest := Space( 20 )\n@ 10, 0 SAY \"type something or <F1> for lazy mode\" GET cTest\nREAD\n? cTest",
    "STATUS": "R",
    "COMPLIANCE": "Harbour use 11 and 12 to represent <F11> and <F12>, while CA-Cl*pper use\n11 and 12 to represent <Shift+F1> and <Shift+F2>.",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Inkey(), SetKey(), __Keyboard(), SET KEY"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 1999 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Command",
    "NAME": "SET FUNCTION",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Assign a character string to a function key",
    "SYNTAX": "SET FUNCTION <nFunctionKey> TO [<cString>]",
    "ARGUMENTS": "<nFunctionKey> is a number in the range 1..40 that represent the\nfunction key to be assigned.\n\n<cString> is a character string to set. If <cString> is not\nspecified, the function key is going to be set to NIL releasing by\nthat any previous Set Function or SetKey() for that function.",
    "DESCRIPTION": "Set Function assign a character string with a function key, when\nthis function key is pressed, the keyboard is stuffed with this\ncharacter string. Set Function has the effect of clearing any\nSetKey() previously set to the same function number and vice versa.\n\n<table>\n nFunctionKey   Key to be set\n\n  1 .. 12       <F1> .. <F12>\n 13 .. 20       <Shift+F3> .. <Shift+F10>\n 21 .. 30       <Ctrl+F1> .. <Ctrl+F10>\n 31 .. 40       <Alt+F1> .. <Alt+F10>\n</table>\n\n`SET FUNCTION` command is preprocessed into __SetFunction() function\nduring compile time.",
    "EXAMPLES": "#include \"inkey.ch\"\nLOCAL cTest, GetList := {}\n// Associate <F1> with a string\nSET FUNCTION 1 TO \"I Am Lazy\" + Chr( K_ENTER )\nCLS\ncTest := Space( 20 )\n@ 10, 0 SAY \"type something or <F1> for lazy mode\" GET cTest\nREAD\n? cTest",
    "STATUS": "R",
    "COMPLIANCE": "Harbour use 11 and 12 to represent <F11> and <F12>, while CA-Cl*pper use\n11 and 12 to represent <Shift+F1> and <Shift+F2>.",
    "PLATFORMS": "All",
    "SEEALSO": "Inkey(), SetKey(), __Keyboard()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 1999 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "SetKey()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Events",
    "ONELINER": "Assign an action block to a key",
    "SYNTAX": "SetKey( <anKey> [, <bAction> [, <bCondition> ] ] )",
    "ARGUMENTS": "<anKey> is either a numeric key value, or an array of such values\n\n<bAction> is an optional code-block to be assigned\n\n<bCondition> is an optional condition code-block",
    "RETURNS": "Current assigned action-block",
    "DESCRIPTION": "The SetKey() function returns the current code-block assigned to a\nkey when called with only the key value.  If the action block (and\noptionally the condition block) are passed, the current block is\nreturned, and the new code block and condition block are stored.\nA group of keys may be assigned the same code block/condition block\nby using an array of key values in place on the first parameter.",
    "EXAMPLES": "#include \"getexit.ch\"\n#include \"inkey.ch\"\nLOCAL bOldF10 := SetKey( K_F10, {|| Yahoo() } )\nLOCAL bBlock\n// some other processing ...\nSetKey( K_F10, bOldF10 )\n// some other processing ...\nbBlock := SetKey( K_SPACE )\nIF bBlock != NIL  // ...\n\n   // make <F10> exit current get, but only if in a get - ignores other\n   // wait states such as menus, achoices, etc...\n   SetKey( K_F10, {|| GetActive():State := GE_WRITE }, ;\n      {|| GetActive() != NIL } )\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "SetKey() is mostly CA-Cl*pper compliant. The only difference is the\naddition of the condition code-block parameter, allowing set-keys to\nbe conditionally turned off or on.  This condition-block cannot be\nreturned once set - see hb_SetKeyGet()",
    "FILES": "Library is core",
    "SEEALSO": "hb_SetKeySave(), hb_SetKeyGet()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 1999 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_SetKeyGet()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Events",
    "ONELINER": "Determine a set-key code block and condition-block",
    "SYNTAX": "hb_SetKeyGet( <nKey> [, <bConditionByRef> ] )",
    "ARGUMENTS": "<anKey> is an numeric key value\n\n<bConditionByRef> is an optional return-parameter",
    "RETURNS": "Current assigned action-block",
    "DESCRIPTION": "The hb_SetKeyGet() function returns the current code-block assigned to\na key, and optionally assigns the condition-block to the\nreturn-parameter",
    "EXAMPLES": "#include \"inkey.ch\"\nLOCAL bOldF10, bOldF10Cond\nbOldF10 := hb_SetKeyGet( K_F10, @bOldF10Cond )\n// some other processing ...\nSetKey( K_F10, bOldF10, bOldF10Cond )",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "SetKey(), hb_SetKeySave(), hb_SetKeyCheck()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 1999 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_SetKeySave()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Events",
    "ONELINER": "Returns a copy of internal set-key list, optionally overwriting",
    "SYNTAX": "hb_SetKeySave( [ <OldKeys> ] )",
    "ARGUMENTS": "<OldKeys> is an optional set-key list from a previous call to\nhb_SetKeySave(), or NIL to clear current set-key list",
    "RETURNS": "Current set-key list",
    "DESCRIPTION": "hb_SetKeySave() is designed to act like the Set() function which\nreturns the current state of an environment setting, and optionally\nassigning a new value.  In this case, the \"environment setting\" is the\ninternal set-key list, and the optional new value is either a value\nreturned from a previous call to hb_SetKeySave() - to restore that list,\nor the value of NIL to clear the current list.",
    "EXAMPLES": "LOCAL aKeys := hb_SetKeySave( NIL )  // removes all current set=keys\n// some other processing ...\nhb_SetKeySave( aKeys )",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "SetKey()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 1999 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Function",
    "NAME": "hb_SetKeyCheck()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Events",
    "ONELINER": "Implements common hot-key activation code",
    "SYNTAX": "hb_SetKeyCheck( <nKey> [, <p1> ][, <p2> ][, <p3> ] )",
    "ARGUMENTS": "<nKey> is a numeric key value to be tested code-block, if executed\n\n<p1>..<p3> are optional parameters that will be passed to the code-block",
    "RETURNS": "True if there is a hot-key associated with <nKey> and it was executed;\notherwise False\nIf there is a hot-key association (before checking any condition):\n- if there is a condition-block, it is passed one parameter - <nKey>\n- when the hot-key code-block is called, it is passed 1 to 4 parameters,\ndepending on the parameters passed to hb_SetKeyCheck().  Any\nparameters so passed are directly passed to the code-block, with an\nadditional parameter being <nKey>",
    "DESCRIPTION": "hb_SetKeyCheck() is intended as a common interface to the SetKey()\nfunctionality for such functions as AChoice(), dbEdit(), MemoEdit(),\nACCEPT, INPUT, READ, and WAIT",
    "EXAMPLES": "// FIXME\n#include \"inkey.ch\"\n// within ReadModal()\nIF hb_SetKeyCheck( K_ALT_X, GetActive() )\n   // some other processing ...\nENDIF\n// within TBrowse handler\nCASE hb_SetKeyCheck( nInkey, oTBrowse )\n   RETURN\nCASE nInKey == K_ESC\n   // some other processing ...",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "SetKey(), hb_SetKeySave()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 1999 April White <bright.tigra gmail.com>",
    "TEMPLATE": "Command",
    "NAME": "SET KEY",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Assign an action block to a key",
    "SYNTAX": "SET KEY <anKey> TO <bAction>] [WHEN <bCondition>]",
    "ARGUMENTS": "<anKey> is either a numeric key value, or an array of such values\n\n<bAction> is an optional code-block to be assigned\n\n<bCondition> is an optional condition code-block",
    "DESCRIPTION": "The `SET KEY` Command function is translated to the SetKey() function\nwitch returns the current code-block assigned to a\nkey when called with only the key value.  If the action block (and\noptionally the condition block) are passed, the current block is\nreturned, and the new code block and condition block are stored.\nA group of keys may be assigned the same code block/condition block\nby using an array of key values in place on the first parameter.",
    "EXAMPLES": "#include \"getexit.ch\"\n#include \"inkey.ch\"\nLOCAL bOldF10 := SetKey( K_F10, {|| Yahoo() } )\nLOCAL bBlock\n// some other processing ...\nSET KEY K_F10 TO bOldF10\n// some other processing ...\nbBlock := SetKey( K_SPACE )\nIF bBlock != NIL  // ...\n\n   // make <F10> exit current get, but only if in a get - ignores other\n   // wait-states such as menus, achoices, etc...\n   SetKey( K_F10, {|| GetActive():State := GE_WRITE }, ;\n      {|| GetActive() != NIL } )\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "`SET KEY` is mostly CA-Cl*pper compliant. The only difference is the\naddition of the condition code-block parameter, allowing set-keys to\nbe conditionally turned off or on.  This condition-block cannot be\nreturned once set - see hb_SetKeyGet()",
    "SEEALSO": "hb_SetKeySave(), hb_SetKeyGet()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 1999 Jose Lalin <dezac@corevia.com>",
    "TEMPLATE": "Function",
    "NAME": "SetTypeahead()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Sets the typeahead buffer to given size.",
    "SYNTAX": "SetTypeahead( <nSize> ) --> nPreviousSize",
    "ARGUMENTS": "<nSize> is a valid typeahead size.",
    "RETURNS": "<nPreviousSize> The previous state of `_SET_TYPEAHEAD`",
    "DESCRIPTION": "This function sets the typeahead buffer to a valid given size as is\n`Set( _SET_TYPEAHEAD )` where used.",
    "EXAMPLES": "// Sets typeahead to 12\nSetTypeahead( 12 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "__Accept(), __Input()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 1999 Jose Lalin <dezac@corevia.com>",
    "TEMPLATE": "Function",
    "NAME": "__XHelp()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Internal",
    "ONELINER": "Determines whether a HELP() user defined function exists.",
    "SYNTAX": "__XHelp() --> xValue",
    "ARGUMENTS": "None",
    "RETURNS": "This function returns aleatory values.",
    "DESCRIPTION": "This is an internal undocumented CA-Cl*pper function, which will\ntry to call the user defined function HELP() if it is defined\nin the current application. This is the default SetKey() handler\nfor the <F1> key.",
    "STATUS": "R",
    "COMPLIANCE": "C52U",
    "FILES": "Library is core"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <Culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "SET DEFAULT",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Establishes the Harbour search drive and directory.",
    "SYNTAX": "SET DEFAULT TO [<cPath>]",
    "ARGUMENTS": "<cPath> Drive and/or path.",
    "DESCRIPTION": "This command changes the drive and directory used for reading and\nwriting database, index, memory, and alternate files. Specifying no\nparameters with this command will default the operation to the\ncurrent logged drive and directory.",
    "EXAMPLES": "SET DEFAULT TO /hb/tests\nSet( _SET_DEFAULT, hb_DirSepToOS( \"/hb/tests\" ) )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "SET PATH, CurDir(), Set()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <Culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "SET WRAP",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Toggle wrapping the PROMPTs in a menu.",
    "SYNTAX": "SET WRAP on | OFF | ( <lWrap> )",
    "ARGUMENTS": "<lWrap> Logical expression for toggle",
    "DESCRIPTION": "This command toggles the highlighted bars in a `@...PROMPT` command\nto wrap around in a bottom-to-top and top-to-bottom manner. If the\nvalue of the logical expression <lWrap> is a logical false (.F.),\nthe wrapping mode is set OFF; otherwise, it is set ON.",
    "EXAMPLES": "// See tests/menuto.prg",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "@...PROMPT, MENU TO"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <Culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "SET MESSAGE",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Establishes a message row for `@...PROMPT` command",
    "SYNTAX": "SET MESSAGE TO [<nRow> [CENTER]]",
    "ARGUMENTS": "<nRow> Row number to display the message",
    "DESCRIPTION": "This command is designed to work in conjunction with the `MENU TO` and\n`@...PROMPT` commands. With this command, a row number between 0 and\nMaxRow() may be specified in <nRow>. This establishes the row on\nwitch any message associated with an `@...PROMPT` command will appear.\n\nIf the value of <nRow> is 0, all messages will be suppressed.\nAll messaged will be left-justifies unless the CENTER clause is\nused. In this case, the individual messages in each `@...PROMPT` command\nwill be centered at the designated row (unless <nRow> is 0). All\nmessages are independent; therefore, the screen area is cleared out\nby the centered message will vary based on the length of each\nindividual message.\n\nSpecifying no parameters with this command set the row value to 0,\nwitch suppresses all messages output.\nThe British spelling of CENTRE is also supported.",
    "EXAMPLES": "See tests/menuto.prg",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "Set(), SET WRAP, @...PROMPT, MENU TO"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <Culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "SET PATH",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Specifies a search path for opening files",
    "SYNTAX": "SET PATH TO [<cPath>]",
    "ARGUMENTS": "<cPath> Search path for files",
    "DESCRIPTION": "This command specifies the search path for files required by most\ncommands and functions not found in the current drive and directory.\nThis pertains primarily, but not exclusively, to databases, indexes,\nand memo files, as well as to memory, labels and reports files. The\nsearch hierarchy is: 1 Current drive and directory, 2 The `SET DEFAULT`\npath; 3 The `SET PATH` path.",
    "EXAMPLES": "SET PATH TO /hb/tests\nSet( _SET_PATH, hb_DirSepToOS( \"/hb/tests\" ) )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "SET DEFAULT, CurDir(), Set()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <Culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "SET INTENSITY",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Toggles the enhanced display of PROMPTs and GETs.",
    "SYNTAX": "SET INTENSITY ON | off | ( <lInte> )",
    "ARGUMENTS": "<lInte> Logical expression for toggle command",
    "DESCRIPTION": "This command set the field input color and `@...PROMPT` menu color\nto either highlighted (inverse video) or normal color. The default\ncondition is ON (highlighted).",
    "EXAMPLES": "SET INTENSITY ON",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "@...GET,@...PROMPT,@...SAY, Set()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <Culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "SET ALTERNATE",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Toggle and echos output to an alternate file",
    "SYNTAX": "SET ALTERNATE TO <cFile> [ADDITIVE]\nSET ALTERNATE on | OFF | ( <lAlter> )",
    "ARGUMENTS": "<cFile> Name of alternate file.\n\n<lAlter> Logical expression for toggle",
    "DESCRIPTION": "This command toggles and output console information to the alternate\nfile <cFile>, provided that the command is toggled on or the condition\n<lAlter> is set to a logical true (.T.). If <cFile> does not has a\nfile extension, .txt will be assumed. The file name may optionally\nhave a drive letter and/or directory path. If none is specified, the\ncurrent drive and directory will be used.\nIf the ALTERNATE file is created but no `ALTERNATE ON` command is\nissued, nothing will be echoed to the file.\nIf ADDITIVE clause is used, then the information will be appended\nto the existing alternate file. Otherwise, a new file will be created\nwith the specified name (or an existing one will be overwritten) and\nthe information will be appended to the file. The default is to create\na new file.\nA `SET ALTERNATE TO` command will close the alternate file",
    "EXAMPLES": "SET ALTERNATE TO test.txt\nSET ALTERNATE ON\n? \"Harbour\"\n? \"is\"\n? \"Power\"\nSET ALTERNATE TO\nSET ALTERNATE OFF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "CLOSE, SET PRINTER, SET CONSOLE, Set()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <Culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "SET CENTURY",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Toggle the century digits in all dates display",
    "SYNTAX": "SET CENTURY on | OFF | ( <lCent> )",
    "ARGUMENTS": "<lCent> Logical expression for toggle",
    "DESCRIPTION": "This command allows the input and display of dates with the century\nprefix. It will be in the standard `MM/DD/YYYY` format unless specified\nby the `SET DATE` command or Set() function. If <lCent> is a logical\ntrue (.T.), the command will be set on; otherwise, the command will\nbe set off",
    "EXAMPLES": "SET CENTURY ON\n? Date()\nSET CENTURY OFF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "SET DATE, SET EPOCH, CToD(), Date(), DToC(), Set()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <Culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "SET DATE",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Assigns a date format or chooses a predefined date data set.",
    "SYNTAX": "SET DATE FORMAT [TO] <cFormat>\n\nSET DATE [TO] [ANSI / BRITISH / FRENCH / GERMAN / ITALIAN / JAPAN / USA / AMERICAN]",
    "ARGUMENTS": "<cFormat> Keyword for date format",
    "DESCRIPTION": "This command sets the date format for function display purposes.\nIf specified, <cFormat> may be a customized date format in which the\nletters d, m and y may be used to design a date format. The default\nis an AMERICAN date format; specifying no parameters will set the\ndate format to AMERICAN. Below is a table of the various predefined\ndates formats.\n\n<table>\n Syntax         Date Format\n ANSI           yy.mm.dd\n BRITISH        dd/mm/yy\n FRENCH         dd/mm/yy\n GERMAN         dd.mm.yy\n ITALIAN        dd-mm-yy\n JAPAN          yy.mm.dd\n USA            mm-dd-yy\n AMERICAN       mm/dd/yy\n</table>",
    "EXAMPLES": "SET DATE JAPAN\n? Date()\nSET DATE GERMAN\n? Date()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "SET DATE, SET EPOCH, CToD(), Date(), DToC(), Set()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <Culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "SET EPOCH",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Specify a base year for interpreting dates",
    "SYNTAX": "SET EPOCH TO <nEpoch>",
    "ARGUMENTS": "<nEpoch> Base Century.",
    "DESCRIPTION": "This command sets the base year value for dates that have only two\ndigits. The default setting is 1900. Dates between 0100-01-01 and\n2999-12-31 are fully supported.",
    "EXAMPLES": "SET EPOCH TO 2000",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "SET DATE, SET CENTURY, CToD(), Date(), DToC(), Set()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <Culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "SET FIXED",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Set the number of decimal position to be displayed",
    "SYNTAX": "SET FIXED on | OFF | ( <lFixed> )",
    "ARGUMENTS": "<lFixed> Logical expression for toggle",
    "DESCRIPTION": "This command activates a system wide fixed placement of decimals\nplaces shown for all numeric outputs. If the value of <lFixed> is\na logical true (.T.), FIXED will be turned ON; otherwise it will be\nturned OFF.\n\nWhen `SET DECIMALS OFF` is used, the following rules apply to the number\nof decimal placed displayed.\n\n<table-noheader>\n Addition         Same as operand with the greatest number of decimal digits\n Subtraction      Same as operand with the greatest number of decimal digits\n Multiplication   Sum of operand decimal digits\n Division         Determined by SET DECIMALS TO\n Exponential      Determined by SET DECIMALS TO\n Log()            Determined by SET DECIMALS TO\n Exp()            Determined by SET DECIMALS TO\n Sqrt()           Determined by SET DECIMALS TO\n Val()            Determined by SET DECIMALS TO\n</table>",
    "EXAMPLES": "SET FIXED ON\n? 25141251 / 362\nSET FIXED OFF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "SET DECIMALS, Exp(), Log(), Sqrt(), Val(), Set()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <Culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "SET PRINTER",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Toggles the printer and controls the printer device",
    "SYNTAX": "SET PRINTER on | OFF\nSET PRINTER ( <lPrinter> )\nSET PRINTER TO [<cPrinter>] [ADDITIVE]",
    "ARGUMENTS": "<lPrinter>   Logical condition by which to toggle the printer\n\n<cPrinter> A device name or an alternate name",
    "DESCRIPTION": "This command can direct all output that is not controlled by the\n`@...SAY` command and the DevPos() and DevOut() functions to the\nprinter. If specified, the condition <lPrinter> toggles the printer\nON if a logical true (.T.) and OFF if a logical false (.F.). If no\nargument is specified in the command, the alternate file (if one\nis open) is closed, or the device is reselected and the PRINTER\noption is turned OFF.\n\nIf a device is specified in <cPrinter>, the output will be directed\nto that device instead of to the PRINTER. A specified device may be\na literal string or a variable, as long as the variable is enclosed\nin parentheses. For a network, do not use a trailing colon when\nredirecting to a device.\n\nIf an alternate file is specified, <cPrinter> becomes the name of a\nfile that will contain the output. If no file extension is specified\nan extension of .prn will be defaulted to.\n\nIf the ADDITIVE clause is specified, the information will be appended\nto the end of the specified output file. Otherwise, a new file will\nbe created with the specified name (or an existing file will first\nbe cleared) and the information will then be appended to the file.\nThe default is to create a new file.",
    "EXAMPLES": "SET PRINTER ON\nSET PRINTER TO LPT1\n? 25141251 / 362\nSET PRINTER ( .F. )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "SET DEVICE, SET CONSOLE, DevOut(), Set()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <Culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "SET CONSOLE",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Toggle the console display",
    "SYNTAX": "SET CONSOLE ON | off | ( <lConsole> )",
    "ARGUMENTS": "<lConsole> Logical expression for toggle command",
    "DESCRIPTION": "This command turns the screen display either off or on for all\nscreens display other then direct output via the `@...SAY` commands\nor the <-> DevOut() function.\n\nIf <lConsole> is a logical true (.T.), the console will be turned\nON; otherwise, the console will be turned off.",
    "EXAMPLES": "SET CONSOLE ON\n? Date()\nSET CONSOLE OFF\n? Date()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "SET DEVICE, Set()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "TEMPLATE": "Command",
    "NAME": "SET DECIMALS",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Toggle the console display",
    "SYNTAX": "SET DECIMALS TO [<nDecimal>]",
    "ARGUMENTS": "<nDecimal> Number of decimals places",
    "DESCRIPTION": "This command establishes the number of decimal places that Harbour\nwill display in mathematical calculations, functions, memory variables,\nand fields. Issuing no parameter with this command will the default\nnumber of decimals to 0. For decimals to be seen, the `SET FIXED ON`\ncommand must be activated.",
    "EXAMPLES": "SET FIXED ON\n? 25141251 / 362\nSET DECIMALS TO 10\n? 214514.214 / 6325",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "SET FIXED, Set()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "TEMPLATE": "Command",
    "NAME": "SET DEVICE",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Directs all `@...SAY` output to a device.",
    "SYNTAX": "SET DEVICE TO [printer | SCREEN ]",
    "ARGUMENTS": "None.",
    "DESCRIPTION": "This command determines whether the output from the `@...SAY` command\nand the DevPos() and DevOut() function will be displayed on the\nprinter.\n\nWhen the device is set to the PRINTER, the `SET MARGIN` value adjusts\nthe position of the column values accordingly. Also, an automatic\npage eject will be issued when the current printer head position is\nless than the last printed row. Finally, if used in conjunction with\nthe `@...GET` commands, the values for the GETs will all be ignored.",
    "EXAMPLES": "SET DEVICE TO SCREEN\n? 25141251 / 362\nSET DEVICE TO PRINTER\nSET PRINTER TO LPT1\n? 214514.214 / 6325\nSET PRINTER OFF\nSET DEVICE TO SCREEN",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "@...SAY, SET PRINTER, SetPRC(), Set()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <Culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "SET BELL",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Toggle the bell to sound once a GET has been completed.",
    "SYNTAX": "SET BELL on | OFF | ( <lBell> )",
    "ARGUMENTS": "<lBell> Logical expression for toggle command",
    "DESCRIPTION": "This command toggles the bell to sound whenever a character is\nentered into the last character position of a GET, or if an invalid\ndata type is entered into a GET.\n\nIf <lBell> is a logical true (.T.), the bell will be turned\nON; otherwise, the bell will be turned off.",
    "EXAMPLES": "LOCAL cDummy, GetList := {}\nSET BELL ON\ncDummy := Space( 20 )\n@ 3, 2 GET cDummy\nREAD\nSET BELL OFF",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "Set()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "TEMPLATE": "C Function",
    "NAME": "hb_setListenerAdd()",
    "CATEGORY": "C level API",
    "SUBCATEGORY": "Environment",
    "ONELINER": "",
    "SYNTAX": "C Prototype\n\n#include \"hbset.h\"\nhb_setListenerAdd( PHB_SET_LISTENER_CALLBACK callback ) --> int",
    "ARGUMENTS": "<callback>\nA pointer to a function taking two enum parameters and returning\nno value. The first parameter identifies the SET parameter that is\nto be changed and the second parameter identifies whether the call\nis from before or after the value is changed. The callback function\nwill be called twice whenever a SET parameter is changed using the\nHarbour SET function. The first call takes place before the SET\nvalue is changed and the second one is after the SET parameter has\nbeen changed.",
    "RETURNS": "An integer value representing the callback handle, in case the\ncaller needs to deactivate the callback function.",
    "DESCRIPTION": "This function allows a subsystem that needs to track the status\nof some SET parameters to be notified whenever a SET parameter gets\nchanged.",
    "EXAMPLES": "void callback_function( HB_set_enum set, HB_set_listener_enum when )\n{\n   printf(\"\\nCalled for SET parameter %d %s changing.\",\n      set, (when ? \"after\" : \"before\"));\n}\nint handle = hb_setListenerAdd( callback_function );",
    "STATUS": "R",
    "COMPLIANCE": "NA",
    "FILES": "Library is core",
    "PLATFORMS": "All",
    "SEEALSO": "hb_setListenerRemove()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "TEMPLATE": "C Function",
    "NAME": "hb_setListenerNotify()",
    "CATEGORY": "C level API",
    "SUBCATEGORY": "Environment",
    "ONELINER": "",
    "SYNTAX": "C Prototype\n\n#include \"hbset.h\"\nhb_setListenerNotify( HB_set_enum set, HB_set_listener_enum\nwhen ) --> int",
    "ARGUMENTS": "<set>\nThe number of the SET parameter that is to be or was changed.\n\n<when>\nSet to HB_SET_LISTENER_BEFORE when called before the SET parameter\nis to be changed and set to HB_SET_LISTENER_AFTER when called\nafter the SET parameter has been changed.",
    "RETURNS": "<int>",
    "DESCRIPTION": "This function notifies all SET listener callback functions. It\nmust be called any time you change the value of a SET parameter\ndirectly instead of using the Harbour SET function. Both before\nand after the change.",
    "EXAMPLES": "hb_setListenerNotify( HB_SET_DECIMALS, HB_SET_LISTENER_BEFORE );\nhb_set.HB_SET_DECIMALS = 3;\nhb_setListenerNotify( HB_SET_DECIMALS, HB_SET_LISTENER_AFTER );",
    "STATUS": "R",
    "COMPLIANCE": "NA",
    "FILES": "Library is core",
    "PLATFORMS": "All",
    "SEEALSO": "hb_setListenerAdd()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/set.txt",
    "TEMPLATE": "C Function",
    "NAME": "hb_setListenerRemove()",
    "CATEGORY": "C level API",
    "SUBCATEGORY": "Environment",
    "ONELINER": "",
    "SYNTAX": "C Prototype\n\n#include \"hbset.h\"\nhb_setListenerRemove( int handle ) --> int",
    "ARGUMENTS": "<handle>\nThe handle for the SET listener callback function to be removed.",
    "RETURNS": "The handle if the callback function could not be located or the\nnegative value of the handle if the callback function was removed.",
    "DESCRIPTION": "This function removes a SET listener callback function.",
    "EXAMPLES": "int handle = hb_setListenerAdd( callback_function );\n/* ... */\nhb_setListenerRemove( handle );",
    "STATUS": "R",
    "COMPLIANCE": "NA",
    "FILES": "Library is core",
    "PLATFORMS": "All",
    "SEEALSO": "hb_setListenerAdd()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "IsAlpha()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Checks if leftmost character in a string is an alphabetic character",
    "SYNTAX": "IsAlpha( <cString> ) --> lAlpha",
    "ARGUMENTS": "<cString> Any character string",
    "RETURNS": "<lAlpha> Logical true (.T.) or false (.F.).",
    "DESCRIPTION": "This function return a logical true (.T.) if the first character\nin <cString> is an alphabetic character. If not, the function will\nreturn a logical false (.F.).",
    "EXAMPLES": "? IsAlpha( \"hello\" )\n? IsAlpha( \"12345\" )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "IsDigit(), IsLower(), IsUpper(), Lower(), Upper()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "IsDigit()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Checks if leftmost character is a digit character",
    "SYNTAX": "IsDigit( <cString> ) --> lDigit",
    "ARGUMENTS": "<cString> Any character string",
    "RETURNS": "<lDigit> Logical true (.T.) or false (.F.).",
    "DESCRIPTION": "This function takes the character string <cString> and checks to\nsee if the leftmost character is a digit, from 1 to 9. If so, the\nfunction will return a logical true (.T.); otherwise, it will\nreturn a logical false (.F.).",
    "EXAMPLES": "? IsDigit( \"12345\" )  // --> .T.\n? IsDigit( \"abcde\" )  // --> .F.",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "IsAlpha(), IsLower(), IsUpper(), Lower(), Upper()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "IsUpper()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Checks if leftmost character is an uppercased letter.",
    "SYNTAX": "IsUpper( <cString> ) --> lUpper",
    "ARGUMENTS": "<cString> Any character string",
    "RETURNS": "<lUpper> Logical true (.T.) or false (.F.).",
    "DESCRIPTION": "This function checks to see if the leftmost character\nif <cString> is a uppercased letter. If so, the\nfunction will return a logical true (.T.); otherwise, it will\nreturn a logical false (.F.).",
    "EXAMPLES": "? IsUpper( \"Abcde\" )  // --> .T.\n? IsUpper( \"abcde\" )  // --> .F.",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "IsAlpha(), IsLower(), IsDigit(), Lower(), Upper()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "IsLower()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Checks if leftmost character is an lowercased letter.",
    "SYNTAX": "IsLower( <cString> ) --> lLower",
    "ARGUMENTS": "<cString> Any character string",
    "RETURNS": "<lLower> Logical true (.T.) or false (.F.).",
    "DESCRIPTION": "This function takes the character string <cString> and checks to\nsee if the leftmost character is a lowercased letter. If so, the\nfunction will return a logical true (.T.); otherwise, it will\nreturn a logical false (.F.).",
    "EXAMPLES": "? IsLower( \"ABCde\" )  // --> .F.\n? IsLower( \"aBCde\" )  // --> .T.",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "IsAlpha(), IsDigit(), IsUpper(), Lower(), Upper()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "LTrim()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Removes leading spaces from a string",
    "SYNTAX": "LTrim( <cString> ) --> cReturn",
    "ARGUMENTS": "<cString>  Character expression with leading spaces",
    "RETURNS": "LTrim() returns a copy of the original string with leading spaces\nremoved.",
    "DESCRIPTION": "This function trims the leading space blank",
    "EXAMPLES": "? \"|\" + LTrim( \"Hello     \" ) + \"|\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Trim(), RTrim(), AllTrim()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "At()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Locates the position of a substring in a main string.",
    "SYNTAX": "At( <cSearch>, <cString> ) --> nPos",
    "ARGUMENTS": "<cSearch> Substring to search for\n\n<cString> Main string",
    "RETURNS": "At() return the starting position of the first occurrence of the\nsubstring in the main string",
    "DESCRIPTION": "This function searches the string <cString> for the characters in\nthe first string <cSearch>. If the substring is not contained within\nthe second expression, the function will return 0.",
    "EXAMPLES": "? At( \"cde\", \"abcdefgfedcba\" )  // --> 3",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "RAt()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "hb_At()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Locates the position of a substring in a main string.",
    "SYNTAX": "hb_At( <cSearch>, <cString>, [<nStart>], [<nEnd>] ) --> nPos",
    "ARGUMENTS": "<cSearch> Substring to search for\n\n<cString> Main string\n\n<nStart> First position to search in <cString>, by default 1\n\n<nEnd> End position to search, by default <cString> length",
    "RETURNS": "hb_At() return the starting position of the first occurrence of the\nsubstring in the main string",
    "DESCRIPTION": "This function searches the string <cString> for the characters in\nthe first string <cSearch>. If the substring is not contained within\nthe second expression, the function will return 0. The third and fourth\nparameters lets you indicate a starting and end offset to search in.",
    "EXAMPLES": "? hb_At( \"cde\", \"abcdefgfedcba\" )     // --> 3\n? hb_At( \"cde\", \"abcdefgfedcba\", 4 )  // --> 0",
    "STATUS": "R",
    "COMPLIANCE": "This function is sensitive to HB_CLP_STRICT settings during build.\n\n<nStart> and <nEnd> are Harbour extensions and do not exist if\nHB_CLP_STRICT is defined. In that case, the whole string is searched.",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "hb_RAt()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "RAt()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Searches for last occurrence a substring of a string.",
    "SYNTAX": "RAt( <cSearch>, <cString> ) --> nPos",
    "ARGUMENTS": "<cSearch> Substring to search for\n\n<cString> Main string",
    "RETURNS": "RAt() return the location of beginning position of last occurrence\na substring of a string.",
    "DESCRIPTION": "This function searches for last occurrence a <cSearch> in <cString>.\nIf the function is unable to find any occurrence of <cSearch> in\n<cString>, the return value is 0.",
    "EXAMPLES": "? RAt( \"cde\", \"abcdefgfcdeedcba\" )  // --> 9\n? RAt( \"cdr\", \"abcdefgfedcba\" )     // --> 0",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "At(), SubStr(), Right(), hb_RAt()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "hb_RAt()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Searches for last occurrence a substring of a string.",
    "SYNTAX": "hb_RAt( <cSearch>, <cString>, [<nStart>], [<nEnd>] ) --> nPos",
    "ARGUMENTS": "<cSearch> Substring to search for\n\n<cString> Main string\n\n<nStart> First position to search in <cString>, by default 1.\n\n<nEnd> End position to search, by default <cString> length",
    "RETURNS": "hb_RAt() return the location of beginning position of last occurrence\na substring of a string.",
    "DESCRIPTION": "This function searches for last occurrence a <cSearch> in <cString>.\nIf the function is unable to find any occurrence of <cSearch> in\n<cString>, the return value is 0. 3rd and 4th parameters define\ninclusive range for 2nd parameter on which operation is performed.\nIf 3rd and 4th parameters is not specified, then hb_RAt() is equal\nto RAt().",
    "EXAMPLES": "LOCAL cString := \"acdefcdeedcb\"\nLOCAL cSearch := \"cde\"\nLOCAL i, y, r\nLOCAL nLen := Len( cString )\n\nFOR y := 1 TO nLen\n   FOR i := 1 TO nLen\n      IF ( r := hb_RAt( cSearch, cString, y, i ) ) > 0\n         ? 'hb_RAt( \"' + cSearch + '\", \"' + cString + '\",', hb_ntos( y ) + \",\", hb_ntos( i ), \") =\", ;\n            hb_ntos( r )\n      ENDIF\n   NEXT\nNEXT\n\n? hb_RAt( cSearch, \"abcdefgfedcba\" )  // --> 3",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "hb_At(), SubStr(), Right(), RAt()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Left()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Extract the leftmost substring of a character expression",
    "SYNTAX": "Left( <cString>, <nLen> ) --> cReturn",
    "ARGUMENTS": "<cString> Main character to be parsed\n\n<nLen> Number of bytes to return beginning at the leftmost position",
    "RETURNS": "<cReturn>  Substring of evaluation",
    "DESCRIPTION": "This functions returns the leftmost <nLen> characters of <cString>.\nIt is equivalent to the following expression:\n```\nSubStr( <cString>, 1, <nLen> )\n```",
    "EXAMPLES": "? Left( \"Hello Harbour\", 5 )  // --> \"Hello\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "SubStr(), Right(), At(), RAt()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Right()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Extract the rightmost substring of a character expression",
    "SYNTAX": "Right( <cString>, <nLen> ) --> cReturn",
    "ARGUMENTS": "<cString> Character expression to be parsed\n\n<nLen> Number of bytes to return beginning at the rightmost position",
    "RETURNS": "<cReturn>  Substring of evaluation",
    "DESCRIPTION": "This functions returns the rightmost <nLen> characters of <cString>.\nIt is equivalent to the following expressions:\n```\nSubStr( <cString>, -<nLen> )\n```\n```\nSubStr( <cString>, Len( <cString> ) - <nLen> + 1, <nLen> )\n```",
    "EXAMPLES": "? Right( \"Hello Harbour\", 5 )  // --> \"rbour\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "SubStr(), Left(), At(), RAt()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "SubStr()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Returns a substring from a main string",
    "SYNTAX": "SubStr( <cString>, <nStart>, [<nLen>] ) --> cReturn",
    "ARGUMENTS": "<cString> Character expression to be parsed\n\n<nStart> Start position\n\n<nLen> Number of characters to return",
    "RETURNS": "<cReturn> Substring of evaluation",
    "DESCRIPTION": "This functions returns a character string formed from <cString>,\nstarting at the position of <nStart> and continuing on for a\nlength of <nLen> characters. If <nLen> is not specified, the value\nwill be all remaining characters from the position of <nStart>.\n\nThe value of <nStart> may be negative. If it is, the direction of\noperation is reversed from a default of left-to-right to right-to-left\nfor the number of characters specified in <nStart>. If the number of\ncharacters from <nStart> to the end of the string is less than <nLen>\nthe rest are ignored.",
    "EXAMPLES": "? SubStr( \"Hello Harbour\",  7, 4 )  // --> \"Harb\"\n? SubStr( \"Hello Harbour\", -3, 3 )  // --> \"our\"\n? SubStr( \"Hello Harbour\",  7    )  // --> \"Harbour\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Left(), At(), Right()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "TEMPLATE": "Function",
    "NAME": "Str()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Convert a numeric expression to a character string.",
    "SYNTAX": "Str( <nNumber>, [<nLength>], [<nDecimals>] ) --> cNumber",
    "ARGUMENTS": "<nNumber> is the numeric expression to be converted to a character\nstring.\n\n<nLength> is the length of the character string to return, including\ndecimal digits, decimal point, and sign.\n\n<nDecimals> is the number of decimal places to return.",
    "RETURNS": "Str() returns <nNumber> formatted as a character string. If the\noptional length and decimal arguments are not specified, Str()\nreturns the character string according to the following rules:\n\nResults of Str() with No Optional Arguments\n\n<table>\n Expression               Return Value Length\n\n Field Variable           Field length plus decimals\n Expressions/constants    Minimum of 10 digits plus decimals\n Val()                    Minimum of 3 digits\n Month()/Day()            3 digits\n Year()                   5 digits\n RecNo()                  7 digits\n</table>",
    "DESCRIPTION": "Str() is a numeric conversion function that converts numeric values\nto character strings. It is commonly used to concatenate numeric\nvalues to character strings. Str() has applications displaying\nnumbers, creating codes such as part numbers from numeric values,\nand creating index keys that combine numeric and character data.\n\nStr() is like Transform(), which formats numeric values as character\nstrings using a mask instead of length and decimal specifications.\n\nThe inverse of Str() is Val(), which converts character numbers to\nnumerics.\n\n*  If <nLength> is less than the number of whole number digits in\n   <nNumber>, Str() returns asterisks instead of the number.\n\n*  If <nLength> is less than the number of decimal digits\n   required for the decimal portion of the returned string, Harbour\n   rounds the number to the available number of decimal places.\n\n*  If <nLength> is specified but <nDecimals> is omitted (no\n   decimal places), the return value is rounded to an integer.",
    "EXAMPLES": "? Str( 10, 6, 2 )   // --> \" 10.00\"\n? Str( -10, 8, 2 )  // --> \"  -10.00\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "StrZero(), Transform(), Val()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "TEMPLATE": "Function",
    "NAME": "StrZero()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Convert a numeric expression to a character string, zero padded.",
    "SYNTAX": "StrZero( <nNumber>, [<nLength>], [<nDecimals>] ) --> cNumber",
    "ARGUMENTS": "<nNumber> is the numeric expression to be converted to a character\nstring.\n\n<nLength> is the length of the character string to return, including\ndecimal digits, decimal point, and sign.\n\n<nDecimals> is the number of decimal places to return.",
    "RETURNS": "StrZero() returns <nNumber> formatted as a character string. If the\noptional length and decimal arguments are not specified, StrZero()\nreturns the character string according to the following rules:\n\nResults of StrZero() with No Optional Arguments\n\n<table>\n Expression               Return Value Length\n\n Field Variable           Field length plus decimals\n Expressions/constants    Minimum of 10 digits plus decimals\n Val()                    Minimum of 3 digits\n Month()/Day()            3 digits\n Year()                   5 digits\n RecNo()                  7 digits\n</table>",
    "DESCRIPTION": "StrZero() is a numeric conversion function that converts numeric\nvalues to character strings. It is commonly used to concatenate\nnumeric values to character strings. StrZero() has applications\ndisplaying numbers, creating codes such as part numbers from numeric\nvalues, and creating index keys that combine numeric and character\ndata.\n\nStrZero() is like Transform(), which formats numeric values as\ncharacter strings using a mask instead of length and decimal\nspecifications.\n\nThe inverse of StrZero() is Val(), which converts character numbers\nto numerics.\n\n*  If <nLength> is less than the number of whole number digits in\n   <nNumber>, Str() returns asterisks instead of the number.\n\n*  If <nLength> is less than the number of decimal digits\n   required for the decimal portion of the returned string, Harbour\n   rounds the number to the available number of decimal places.\n\n*  If <nLength> is specified but <nDecimals> is omitted (no\n   decimal places), the return value is rounded to an integer.\n\nThe StrZero() function was part of the CA-Cl*pper samples.",
    "EXAMPLES": "? StrZero( 10, 6, 2 )   // --> \"010.00\"\n? StrZero( -10, 8, 2 )  // --> \"-0010.00\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "Str()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "TEMPLATE": "Function",
    "NAME": "hb_ValToStr()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Converts any scalar type to a string.",
    "SYNTAX": "hb_ValToStr( <xValue> ) --> cString",
    "ARGUMENTS": "<xValue> is any scalar argument.",
    "RETURNS": "<cString> A string representation of <xValue> using default\nconversions.",
    "DESCRIPTION": "hb_ValToStr() can be used to convert any scalar value to a string.",
    "EXAMPLES": "Set( _SET_DATEFORMAT, \"yyyy-mm-dd\" )\n? hb_ValToStr( 4 ) == \"         4\"\n? hb_ValToStr( 4.0 / 2 ) == \"         2.00\"\n? hb_ValToStr( \"String\" ) == \"String\"\n? hb_ValToStr( 0d20010101 ) == \"2001-01-01\"\n? hb_ValToStr( NIL ) == \"NIL\"\n? hb_ValToStr( .F. ) == \".F.\"\n? hb_ValToStr( .T. ) == \".T.\"",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "Str()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "TEMPLATE": "Function",
    "NAME": "Len()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "Returns size of a string or size of an array.",
    "SYNTAX": "Len( <cString> | <aArray> ) --> nLength",
    "ARGUMENTS": "<acString> is a character string or the array to check.",
    "RETURNS": "The length of the string or the number of elements that contains\nan array.",
    "DESCRIPTION": "This function returns the string length or the size of an array or the\nsize of a hash table. If it is used with a multidimensional array it\nreturns the size of the first dimension.",
    "EXAMPLES": "LOCAL cName\n\n? Len( \"Harbour\" )         // --> 7\n? Len( { \"One\", \"Two\" } )  // --> 2\n\ncName := \"\"\nACCEPT \"Enter your name: \" TO cName\n? Len( cName )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "Empty(), RTrim(), LTrim(), AAdd(), ASize()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "TEMPLATE": "Function",
    "NAME": "Empty()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "Checks if the passed argument is empty.",
    "SYNTAX": "Empty( <xExp> ) --> lIsEmpty",
    "ARGUMENTS": "<xExp> is any valid expression.",
    "RETURNS": "A logical value. It is true (.T.) if the passed argument is empty\notherwise it is false (.F.).",
    "DESCRIPTION": "This function checks if an expression has empty value and returns a\nlogical indicating whether it the expression is empty or not.",
    "EXAMPLES": "? Empty( \"I'm not empty\" )  // --> .F.\n? Empty( NIL )              // --> .T.\n? Empty( 0 )                // --> .T.\n? Empty( .F. )              // --> .T.\n? Empty( \"\" )               // --> .T.\n? Empty( \"  \" )             // --> .T.\n? Empty( 1 )                // --> .F.\n? Empty( .T. )              // --> .F.\n? Empty( \"smile\" )          // --> .F.\n? Empty( Date() )           // --> .F.",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "Len()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 1999 Jose Lalin <dezac@corevia.com>",
    "TEMPLATE": "Function",
    "NAME": "Descend()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Conversion",
    "ONELINER": "Inverts an expression of string, logical, date or numeric type.",
    "SYNTAX": "Descend( <xExp> ) --> xExpInverted",
    "ARGUMENTS": "<xExp> is any valid expression.",
    "RETURNS": "Inverted value of the same type as passed.",
    "DESCRIPTION": "This function converts an expression in his inverted form. It is\nuseful to build descending indexes.",
    "EXAMPLES": "// FIXME\n// Seek for Smith in a descending index\ndbSeek( Descend( \"SMITH\" ) )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "INDEX, SEEK"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "TEMPLATE": "Function",
    "NAME": "Lower()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Universally lowercases a character string expression.",
    "SYNTAX": "Lower( <cString> ) --> cLowerString",
    "ARGUMENTS": "<cString> Any character expression.",
    "RETURNS": "<cLowerString> Lowercased value of <cString>",
    "DESCRIPTION": "This function converts any character expression passes as <cString>\nto its lowercased representation. Any non alphabetic character withing\n<cString> will remain unchanged.",
    "EXAMPLES": "? Lower( \"HARBOUR\" )    // --> \"harbour\"\n? Lower( \"Hello All\" )  // --> \"hello all\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Upper(), IsLower(), IsUpper()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Upper()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Converts a character expression to uppercase format",
    "SYNTAX": "Upper( <cString> ) --> cUpperString",
    "ARGUMENTS": "<cString> Any character expression.",
    "RETURNS": "<cUpperString> Uppercased value of <cString>",
    "DESCRIPTION": "This function converts all alpha characters in <cString> to upper\ncase values and returns that formatted character expression.",
    "EXAMPLES": "? Upper( \"harbour\" )  // --> \"HARBOUR\"\n? Upper( \"Harbour\" )  // --> \"HARBOUR\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Lower(), IsUpper(), IsLower()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Chr()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Converts an ASCII value to it character value",
    "SYNTAX": "Chr( <nAsciiNum> ) --> cReturn",
    "ARGUMENTS": "<nAsciiNum> Any ASCII character code.",
    "RETURNS": "<cReturn> Character expression of that ASCII value",
    "DESCRIPTION": "This function returns the ASCII character code for <nAsciiNum>. The\nnumber expressed must be an integer value within the range of 0 to\n255 inclusive. The Chr() function will send the character returned\nto whatever device is presently set.\n\nThe Chr() function may be used for printing special codes as well\nas normal and graphics character codes.",
    "EXAMPLES": "? Chr( 32 )\n? Chr( 65 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Asc(), Inkey()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Asc()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Returns the ASCII value of a character",
    "SYNTAX": "Asc( <cCharacter> ) --> nAscNumber",
    "ARGUMENTS": "<cCharacter> Any character expression",
    "RETURNS": "<nAscNumber> ASCII value",
    "DESCRIPTION": "This function return the ASCII value of the leftmost character of\nany character expression passed as <cCharacter>.",
    "EXAMPLES": "? Asc( \"A\" )\n? Asc( \"ą\" )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Chr()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "PadC()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Centers an expression for a given width",
    "SYNTAX": "PadC( <xVal>, <nWidth>, <cFill> ) --> cString",
    "ARGUMENTS": "<xVal> A Number, Character or Date value to pad\n\n<nWidth> Width of output string\n\n<cFill> Character to fill in the string",
    "RETURNS": "<cString> The Center string of <xVal>",
    "DESCRIPTION": "This function takes an date, number or character expression <xVal>\nand attempt to center the expression within a string of a given width\nexpressed as <nWidth>. The default character used to pad either side\nof <xVal> will be a blank space. This character may be explicitly\nspecified the value of <cFill>.\n\nIf the length of <xVal> is longer then <nWidth>, this function will\ntruncate the string <xVal> from the leftmost side to the length of\n<nWidth>.",
    "EXAMPLES": "? PadC( \"Harbour\", 20 )\n? PadC( 34.5142, 20 )\n? PadC( Date(), 35 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "AllTrim(), PadL(), PadR()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "PadL()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Left-justifies an expression for a given width",
    "SYNTAX": "PadL( <xVal>, <nWidth>, <cFill> ) --> cString",
    "ARGUMENTS": "<xVal> An number, Character or date to pad\n\n<nWidth> Width of output string\n\n<cFill> Character to fill in the string",
    "RETURNS": "<cString> The left-justifies string of <xVal>",
    "DESCRIPTION": "This function takes an date, number, or character expression <xVal>\nand attempt to left-justify it within a string of a given width\nexpressed as <nWidth>. The default character used to pad left side\nof <xVal> will be an blank space; however, this character may be\nexplicitly specified the value of <cFill>.\n\nIf the length of <xVal> is longer then <nWidth>, this function will\ntruncate the string <xVal> from the leftmost side to the length of\n<nWidth>.",
    "EXAMPLES": "? PadL( \"Harbour\", 20 )\n? PadL( 34.5142, 20 )\n? PadL( Date(), 35 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "AllTrim(), PadC(), PadR()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "PadR()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Right-justifies an expression for a given width",
    "SYNTAX": "PadR( <xVal>, <nWidth>, <cFill> ) --> cString",
    "ARGUMENTS": "<xVal> A Number, Character or Date value to pad\n\n<nWidth> Width of output string\n\n<cFill> Character to fill in the string",
    "RETURNS": "<cString> The right-justifies string of <xVal>",
    "DESCRIPTION": "This function takes an date, number, or character expression <xVal>\nand attempt to right-justify it within a string of a given width\nexpressed as <nWidth>. The default character used to pad right side\nof <xVal> will be an blank space; however, this character may be\nexplicitly specified the value of <cFill>.\n\nIf the length of <xVal> is longer then <nWidth>, this function will\ntruncate the string <xVal> from the leftmost side to the length of\n<nWidth>.",
    "EXAMPLES": "? PadR( \"Harbour\", 20 )\n? PadR( 34.5142, 20 )\n? PadR( Date(), 35 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "AllTrim(), PadC(), PadL()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "AllTrim()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Removes leading and trailing blank spaces from a string",
    "SYNTAX": "AllTrim( <cString> ) --> cExpression",
    "ARGUMENTS": "<cString> Any character string",
    "RETURNS": "<cExpression> An string will all blank spaces removed from <cString>",
    "DESCRIPTION": "This function returns the string <cExpression> will all leading and\ntrailing blank spaces removed.",
    "EXAMPLES": "? AllTrim( \"Hello Harbour\" )\n? AllTrim( \"     Hello Harbour\" )\n? AllTrim( \"Hello Harbour     \" )\n? AllTrim( \"     hello Harbour     \" )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "LTrim(), RTrim(), Trim()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "RTrim()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Remove trailing spaces from a string.",
    "SYNTAX": "RTrim( <cExpression> ) --> cString",
    "ARGUMENTS": "<cExpression> Any character expression",
    "RETURNS": "<cString> A formatted string with out any blank spaced.",
    "DESCRIPTION": "This function returns the value of <cString> with any trailing blank\nremoved.\n\nThis function is identical to RTrim() and the opposite of LTrim().\nTogether with LTrim(), this function equated to the AllTrim()\nfunction.",
    "EXAMPLES": "? RTrim( \"Hello\" )   // --> \"Hello\"\n? RTrim( \"\" )        // --> \"\"\n? RTrim( \"UA   \" )   // --> \"UA\"\n? RTrim( \"   UA\" )   // --> \"   UA\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "AllTrim(), LTrim(), Trim()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Trim()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Remove trailing spaces from a string.",
    "SYNTAX": "Trim( <cExpression> ) --> cString",
    "ARGUMENTS": "<cExpression> Any character expression",
    "RETURNS": "<cString> A formatted string with out any blank spaced.",
    "DESCRIPTION": "This function returns the value of <cString> with any trailing blank\nremoved.\n\nThis function is identical to RTrim() and the opposite of LTrim().\nTogether with LTrim(), this function equated to the AllTrim()\nfunction.",
    "EXAMPLES": "? Trim( \"Hello\" )    // --> \"Hello\"\n? Trim( \"\" )         // --> \"\"\n? Trim( \"UA   \" )    // --> \"UA\"\n? Trim( \"   UA\" )    // --> \"   UA\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "RTrim(), LTrim(), AllTrim()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Replicate()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Repeats a single character expression",
    "SYNTAX": "Replicate( <cString>, <nSize> ) --> cReplicateString",
    "ARGUMENTS": "<cString> Character string to be replicated\n\n<nSize> Number of times to replicate <cString>",
    "RETURNS": "<cReplicateString> A character expression contain the <cString>\nfill character.",
    "DESCRIPTION": "This function returns a string composed of <nSize> repetitions of\n<cString>. The length of the character string returned by this\nfunction is limited to the memory available.\n\nA value of 0 for <nSize> will return a null string.",
    "EXAMPLES": "? Replicate( \"a\", 10 )      // --> \"aaaaaaaaaa\"\n? Replicate( \"b\", 100000 )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Space(), PadC(), PadL(), PadR()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Space()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Returns a string of blank spaces",
    "SYNTAX": "Space( <nSize> ) --> cString",
    "ARGUMENTS": "<nSize> The length of the string",
    "RETURNS": "<cString> A string containing blank spaces",
    "DESCRIPTION": "This function returns a string consisting of <nSize> blank spaces.\nIf the value of <nSize> is 0, a null string (\"\") will be returned.\n\nThis function is useful to declare the length of a character memory\nvariable.",
    "EXAMPLES": "#include \"dbstruct.ch\"\n\nPROCEDURE Main()\n\n   LOCAL cBigString\n   LOCAL cFirst\n   LOCAL cString := Space( 20 )   // Create an character memory variable\n                                  // with length 20\n   ? Len( cString )  // --> 20\n   cBigString := Space( 100000 )  // Create a memory variable with 100000\n                                  // blank spaces\n   ? Len( cBigString )\n   USE test NEW\n   cFirst := MakeEmpty( 1 )\n   ? Len( cFirst )\n\n   RETURN\n\nSTATIC FUNCTION MakeEmpty( xField )\n\n   LOCAL nRecord\n   LOCAL xRetValue\n\n   IF ! Alias() == \"\"\n      nRecord := RecNo()\n      dbGoto( 0 )\n      IF HB_ISSTRING( xField )\n         xField := AScan( dbStruct(), {| aFields | aFields[ DBS_NAME ] == Upper( xField ) } )\n      ELSE\n         hb_default( @xField, 0 )\n         IF xField < 1 .OR. xField > FCount()\n            xField := 0\n         ENDIF\n      ENDIF\n      IF xField != 0\n         xRetValue := FieldGet( xField )\n      ENDIF\n      dbGoto( nRecord )\n   ENDIF\n\n   RETURN xRetValue",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "PadC(), PadL(), PadR(), Replicate()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Val()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Convert a number from a character type to numeric",
    "SYNTAX": "Val( <cNumber> ) --> nNumber",
    "ARGUMENTS": "<cNumber> Any valid character string of numbers.",
    "RETURNS": "<nNumber> The numeric value of <cNumber>",
    "DESCRIPTION": "This function converts any number previously defined as an character\nexpression <cNumber> into a numeric expression.\n\nThis functions is the oppose of the Str() function.",
    "EXAMPLES": "? Val( \"31421\" )  // --> 31421",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Str(), Transform()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "2017 Pete D. <pete_westg@yahoo.gr>",
    "TEMPLATE": "Function",
    "NAME": "hb_ntoc()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Converts a numeric value to string",
    "SYNTAX": "hb_ntoc( <nValue>, [<nDecs>] ) --> cValue",
    "ARGUMENTS": "<nValue> is the numeric value to convert.\n\n<nDecs> decimal digits to retain (if any).",
    "RETURNS": "<cValue> A string representation of <nValue>",
    "DESCRIPTION": "This function converts the given <nValue> numeric value\nto a string value, while (trying to) keep all or at least `nDecs`\nsignificant digits in double numbers, unless `<nDecs>` is lesser\nthan actual decimal digits of <nValue>, in which case the result\nwill be rounded.\n\nSET DECIMAL setting has no effect on the returned value (ignored),\nwhich means that, unlike e.g. Str(), all non-significant digits\n(e.g.: trailing decimal zeros) will be removed. Likewise, all\nleading empty spaces will be trimmed.\n\nReturns stringified value of `<nValue>`, preserving all (or at least\n`<nDecs>`) significant digits, if any.\nInterestingly, if `<nValue>` is NIL or not numeric, this function\nwill return a null string and, unlike Str(), will NOT cause an RTE.\nNOTE: new function, available after 2016-06-20 21:59 UTC+0200 commit,\n      (it is not available in earlier versions).",
    "EXAMPLES": "LOCAL n := ( 5 / 2 ) + 0.009\n\n? hb_ntoc( n )     // --> 2.509\n? Str( n )         // -->          2.51\n? hb_ntoc( n, 2 )  // --> 2.51\n? Str( n, 5, 2 )   // -->  2.51\n? hb_ntos( n )     // --> 2.51\n? \"--- decimals set to 7 ----\"\nSET DECIMALS TO 7\n? Str( n )         // -->          2.51\n? hb_ntoc( n )     // --> 2.509\n? Str( n, 10, 7 )  // -->  2.5090000\n? hb_ntoc( n, 7 )  // --> 2.509\n? \"--- pass non numeric / NIL value ----\"\n? Str( \"42\" )      // --> RTE",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "Str(), hb_ntos()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/string.txt",
    "AUTHOR": "2017 Pete D. <pete_westg@yahoo.gr>",
    "TEMPLATE": "Function",
    "NAME": "hb_ntos()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Converts a numeric value to string.",
    "SYNTAX": "hb_ntos( <nValue> ) --> cValue",
    "ARGUMENTS": "<nValue> is the numeric value to convert.",
    "RETURNS": "<cValue> A string representation of <nValue>",
    "DESCRIPTION": "This function converts any numeric value to a string,\ntrimming all the leading empty spaces. If `<nValue>` is NIL\nor not numeric, this function will return a null string.\n\nEssentially, `hb_ntos()` function is equivalent to\n`LTrim( Str( <nValue> ) )` but quite simpler and faster.",
    "EXAMPLES": "LOCAL n := ( 5 / 2 ) + 0.009\n\n? Str( n )      // -->          2.51\n? hb_ntos( n )  // --> 2.51",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "Str(), hb_ntoc(), LTrim()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/strtran.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "StrTran()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Translate substring value with a main string",
    "SYNTAX": "StrTran( <cString>, <cLocString>, [<cRepString>], [<nPos>],\n         [<nOccurrences>] ) --> cReturn",
    "ARGUMENTS": "<cString>     The main string to search\n\n<cLocString>  The string to locate in the main string\n\n<cRepString>  The string to replace the <cLocString>\n\n<nPos>        The first occurrence to be replaced\n\n<nOccurrences> Number of occurrence to replace",
    "RETURNS": "<cReturn>  Formatted string",
    "DESCRIPTION": "This function searches for any occurrence of <cLocString> in <cString>\nand replaces it with <cRepString>. If <cRepString> is not specified, a\nNULL byte will replace <cLocString>.\n\nIf <nPos> is used, its value defines the first occurrence to be\nreplaced. The default value is 1. Additionally, if used, the value of\n<nOccurrences> tell the function how many occurrences of <cLocString>\nin <cString> are to the replaced. The default of <nOccurrences> is\nall occurrences.",
    "EXAMPLES": "? StrTran( \"Harbour  Power\", \"  \", \" \" )  // --> \"Harbour Power\"\n? StrTran( \"Harbour  Power  The Future  of  xBase\", \"  \", \" \" , , 2 )\n  // --> \"Harbour Power The future  of  xBase\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Libraty is rtl",
    "SEEALSO": "SubStr(), At()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1003",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Attempt to access non-existing or hidden variable",
    "DESCRIPTION": "The specified variable was not found.\n\nIf it is a database field ensure that the required database is open.\n\nIf it is a private or public variable then it must be first created\nusing PRIVATE or PUBLIC statement.",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1068",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Bound error in array access",
    "DESCRIPTION": "The attempt to retrieve data from non-array value.",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1069",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Bound error in array access",
    "DESCRIPTION": "The attempt to set data to non-array value.",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1070",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid type of arguments",
    "DESCRIPTION": "The type of compared arguments do not match.",
    "EXAMPLES": "? \"a\" == 0",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1072",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid type of arguments",
    "DESCRIPTION": "The type of compared arguments do not match.",
    "EXAMPLES": "? \"a\" != 0",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1073",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid type of arguments",
    "DESCRIPTION": "The type of compared argument do not match.",
    "EXAMPLES": "? \"a\" < 0",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1074",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid type of arguments",
    "DESCRIPTION": "The type of compared arguments do not match.",
    "EXAMPLES": "? \"a\" <= 0",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1075",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid type of arguments",
    "DESCRIPTION": "The type of compared arguments do not match.",
    "EXAMPLES": "? \"a\" > 0",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1076",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid type of arguments",
    "DESCRIPTION": "The type of compared arguments do not match.",
    "EXAMPLES": "? \"a\" >= 0",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1077",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid type of arguments",
    "DESCRIPTION": "Operation is not allowed for passed argument. The argument is not\na logical value.",
    "EXAMPLES": "? ! \"a\"",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1078",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid type of arguments",
    "DESCRIPTION": "The type of one or both arguments is not a logical.",
    "EXAMPLES": "// FIXME\n.AND.",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1079",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid type of arguments",
    "DESCRIPTION": "The type of one or both arguments is not a logical.",
    "EXAMPLES": "// FIXME\n.OR.",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1081",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid type of arguments",
    "DESCRIPTION": "The plus operation is not allowed for used arguments.",
    "EXAMPLES": "+",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1082",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid type of arguments",
    "DESCRIPTION": "The minus operation is not allowed for used arguments.",
    "EXAMPLES": "? \"a\" - 1",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1086",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid type of arguments",
    "DESCRIPTION": "The value of argument cannot be incremented.",
    "EXAMPLES": "LOCAL cVar := \"a\"\ncVar++",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1085",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function is not an numeric\nvalue",
    "EXAMPLES": "Mod()",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1089",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function is not an numeric\nvalue",
    "EXAMPLES": "Abs( \"a\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1090",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function is not an numeric\nvalue",
    "EXAMPLES": "Int( \"a\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1092",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function is not an numeric\nvalue",
    "EXAMPLES": "Min( \"a\", \"b\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1093",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function is not an numeric\nvalue",
    "EXAMPLES": "Max( \"a\", \"b\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1094",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function is not an numeric\nvalue",
    "EXAMPLES": "Round( \"a\", 0 )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1095",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function is not an numeric\nvalue",
    "EXAMPLES": "Log( \"a\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1096",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function is not an numeric\nvalue",
    "EXAMPLES": "Exp( \"a\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1097",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function is not an numeric\nvalue",
    "EXAMPLES": "Sqrt( \"a\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1098",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function is not a string\nvalue",
    "EXAMPLES": "Val( 1 )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1099",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function is not a numeric\nvalue",
    "EXAMPLES": "Str( \"a\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1100",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Incorrect type of argument",
    "DESCRIPTION": "The specified argument is not a string.",
    "EXAMPLES": "RTrim( 1 )\nTrim( 1 )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1101",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Incorrect type of argument",
    "DESCRIPTION": "The specified argument is not a string.",
    "EXAMPLES": "LTrim( 1 )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1102",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The first argument passed to a function is not a string.",
    "EXAMPLES": "Upper( 1 )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1103",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The first argument passed to a function is not a string.",
    "EXAMPLES": "Lower( 1 )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1104",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Incorrect type of argument",
    "DESCRIPTION": "The specified argument is not a numeric value.",
    "EXAMPLES": "Chr( \"a\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1105",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The arguments passed to a function are of incorrect type.",
    "EXAMPLES": "Space( \"a\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1106",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The arguments passed to a function are of incorrect type.",
    "EXAMPLES": "Replicate( 1, \"a\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1107",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Incorrect type of argument",
    "DESCRIPTION": "The specified argument is not a string.",
    "EXAMPLES": "Asc( 1 )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1108",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Incorrect type of argument",
    "DESCRIPTION": "The specified argument is not a string.",
    "EXAMPLES": "At( 1, \"a\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1109",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid type of arguments",
    "DESCRIPTION": "The arguments of '$' operator are not a strings.",
    "EXAMPLES": "? 1 $ \"a\"",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1110",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The first argument passed to a function is not a string.",
    "EXAMPLES": "SubStr( 1, 1 )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1111",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The passed argument is neither a string nor an array.",
    "EXAMPLES": "Len( 1 )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1112",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function are of incorrect\ntype",
    "EXAMPLES": "Year( \"a\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1113",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function are of incorrect\ntype",
    "EXAMPLES": "Month( \"a\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1114",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function are of incorrect\ntype",
    "EXAMPLES": "Day( \"a\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1115",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function are of incorrect\ntype",
    "EXAMPLES": "DoW( \"a\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1116",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function are of incorrect\ntype",
    "EXAMPLES": "CMonth( \"a\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1117",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function is of incorrect\ntype",
    "EXAMPLES": "CDoW( \"a\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1120",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The argument (or arguments) passed to a function is of incorrect\ntype",
    "EXAMPLES": "DToS( 1 )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1122",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Incorrect type of argument",
    "DESCRIPTION": "The argument (or arguments) passed to a function is of incorrect\ntype",
    "EXAMPLES": "Transform( \"a\", 1 )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1124",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Incorrect type of argument",
    "DESCRIPTION": "The first argument is not a string.",
    "EXAMPLES": "Left( 1, 1 )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1126",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The first arguments passed to a function is not a string.",
    "EXAMPLES": "StrTran( 1 )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1132",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Bound error in array access",
    "DESCRIPTION": "The specified index into an array was greater then the number of\nelements in the array.",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/1133",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Bound error in array element assignment",
    "DESCRIPTION": "The specified index into an array was greater then the number of\nelements in the array.",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/2010",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Incorrect arguments type",
    "DESCRIPTION": "Passed Runtime errors was not strings with file names to copy.",
    "EXAMPLES": "__CopyFile( 1, 2 )",
    "COMPLIANCE": "H",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/2012",
    "CATEGORY": "Runtime errors",
    "ONELINER": "File error",
    "DESCRIPTION": "An error has occurred during the attempt to open, create or write\nduring copy operation",
    "EXAMPLES": "__CopyFile( \"<nothere>\", \"test.txt\" )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/2017",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to a function",
    "DESCRIPTION": "The first argument is not an array or/and the second argument\nis not a code block",
    "EXAMPLES": "AEval( 1 )",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/2020",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to function",
    "DESCRIPTION": "The passed value is negative. Only values > 0 are allowed.",
    "EXAMPLES": "// SET DECIMALS\n// SET EPOCH\n// SET MARGIN\n// SET MESSAGE",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/3001",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Incorrect argument type",
    "DESCRIPTION": "The passed argument is not an object. Only data of type OBJECT\ncan be cloned by this function",
    "EXAMPLES": "__objClone( 1 )",
    "COMPLIANCE": "H",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/3002",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Super class does not return an object",
    "DESCRIPTION": "Passed argument is not a name of defined class or specified class\ndoesn't have a super class",
    "EXAMPLES": "// FIXME\n__clsInstSuper()",
    "COMPLIANCE": "H",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/3003",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Cannot find super class",
    "DESCRIPTION": "Passed argument is not a name of defined class",
    "EXAMPLES": "__clsInstSuper()",
    "COMPLIANCE": "H",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/3004",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Cannot modify a DATA item in a class",
    "DESCRIPTION": "The attempt to modify a data member of a class was made.\nOnly INLINE and METHOD can be modified",
    "EXAMPLES": "// FIXME\n__clsModMsg()",
    "COMPLIANCE": "H",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/3005",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Incorrect arguments type",
    "DESCRIPTION": "Either the first argument was not an object or the second argument\nwasn't a string.",
    "EXAMPLES": "__clsAssocType( 1, 1 )",
    "COMPLIANCE": "H",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/3007",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid type of argument",
    "DESCRIPTION": "The passed arguments are causing conflict in handling of the request.\nThere is no point in waiting forever for no input events!",
    "EXAMPLES": "// FIXME\nInkey()",
    "COMPLIANCE": "H",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/3008",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid type of argument",
    "DESCRIPTION": "The passed argument(s) is not a string. It should be a string with\na variable name or an one-dimensional array of strings.",
    "EXAMPLES": "__mvPrivate( 1 )\n__mvPublic( 1 )",
    "COMPLIANCE": "H",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/3009",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Incorrect argument passed to __mvGet() function",
    "DESCRIPTION": "__mvGet() function expects only one argument: a string with a name\nof variable. The value of this variable will be returned.",
    "EXAMPLES": "__mvGet( 1 )",
    "COMPLIANCE": "H",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/3010",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Incorrect argument passed to __mvPut() function",
    "DESCRIPTION": "__mvPut() function expects at least one argument: a string with a name\nof variable. The value of this variable will be set.",
    "EXAMPLES": "__mvPut( 1 )",
    "COMPLIANCE": "H",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/3012",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to a function",
    "DESCRIPTION": "The first argument is not a string with function/procedure name\nthat should be called.",
    "EXAMPLES": "Do( 1 )",
    "COMPLIANCE": "H",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/3101",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Invalid argument passed to an object/class function",
    "DESCRIPTION": "One passed argument is not of the required type.",
    "EXAMPLES": "// __obj*()",
    "COMPLIANCE": "H",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/3102",
    "CATEGORY": "Runtime errors",
    "ONELINER": "A symbol should be modified or deleted from a class, but the symbol\ndoesn't exist.",
    "DESCRIPTION": "A symbol should be modified or deleted from a class, but the symbol\ndoesn't exist.",
    "EXAMPLES": "// __obj*()",
    "COMPLIANCE": "H",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "BASE/3103",
    "CATEGORY": "Runtime errors",
    "ONELINER": "A symbol should be added to a class, but the symbol already exists.",
    "DESCRIPTION": "A symbol should be added to a class, but the symbol already exists.",
    "EXAMPLES": "// __obj*()",
    "COMPLIANCE": "H",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/subcodes.txt",
    "TEMPLATE": "Runtime error",
    "NAME": "TERM/2013",
    "CATEGORY": "Runtime errors",
    "ONELINER": "Create error",
    "DESCRIPTION": "The specified file cannot be created due some OS error.",
    "EXAMPLES": "// Set()\n// SET ALTERNATE TO",
    "COMPLIANCE": "C",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/tbrowse.txt",
    "TEMPLATE": "Class",
    "NAME": "TBrowseNew()",
    "CATEGORY": "TBrowse class",
    "ONELINER": "Create a Browse Object",
    "SYNTAX": "TBrowseNew( <nTop>, <nLeft>, <nBottom>, <nRight> ) --> oBrowse",
    "ARGUMENTS": "<nTop>    Top Row\n\n<nLeft>   Top Left Column\n\n<nBottom> Bottom Row\n\n<nRight>  Bottom Right Column",
    "RETURNS": "<oBrowse>  An new Browse Object",
    "DESCRIPTION": "This function set up a browsing window at top-left coordinates of\n<nTop>, <nLeft> to bottom-right coordinates of <nBottom>, <nRight>.\nTo browse Database files use TBrowseDB() function instead.",
    "DATANOLINK": "`:aColumns`       Array to hold all browse columns\n\n`:autoLite`       Logical value to control highlighting\n\n`:cargo`          User-definable variable\n\n`:colorSpec`      Color table for the TBrowse display\n\n`:colPos`         Current cursor column position\n\n`:colSep`         Column separator character\n\n`:footSep`        Footing separator character\n\n`:freeze`         Number of columns to freeze\n\n`:goBottomBlock`  Code block executed by `TBrowse:goBottom()`\n\n`:goTopBlock`     Code block executed by `TBrowse:goTop()`\n\n`:headSep`        Heading separator character\n\n`:hitBottom`      Indicates the end of available data\n\n`:hitTop`         Indicates the beginning of available data\n\n`:leftVisible`    Indicates position of leftmost unfrozen column\nin display\n\n`:nBottom`        Bottom row number for the TBrowse display\n\n`:nLeft`          Leftmost column for the TBrowse display\n\n`:nRight`         Rightmost column for the TBrowse display\n\n`:nTop`           Top row number for the TBrowse display\n\n`:rightVisible`   Indicates position of rightmost unfrozen column\nin display\n\n`:rowCount`       Number of visible data rows in the TBrowse\ndisplay\n\n`:rowPos`         Current cursor row position\n\n`:skipBlock`      Code block used to reposition data source\n\n`:stable`         Indicates if the TBrowse object is stable\n\n`:aRedraw`        Array of logical items indicating, is appropriate\nrow need to be redraw\n\n`:RelativePos`    Indicates record position relatively position of\nfirst record on the screen\n\n`:lHeaders`       Internal variable which indicates whether there\nare column footers to paint\n\n`:lFooters`       Internal variable which indicates whether there\nare column footers to paint\n\n`:aRect`          The rectangle specified with `:ColorRect()`\n\n`:aRectColor`     The color positions to use in the rectangle\nspecified with `:ColorRect()`\n\n`:aKeys`        Holds the Default movement keys",
    "METHODSLINK": "`:AddColumn()` Adds an new TBColumn object to the current Browse\n\n`:Applykey()`  Perform the Browse Key movement\n\n`:SetKey()`    Add an New key to the Keyboard dictionary",
    "METHODSNOLINK": "`:New( nTop, nLeft, nBottom, nRight )`  Create an new Browse class and set the\ndefault values\n\n`:Down()`       Moves the cursor down one row\n\n`:End()`        Moves the cursor to the rightmost visible data column\n\n`:GoBottom()`   Repositions the data source to the bottom of file\n\n`:GoTop()`      Repositions the data source to the top of file\n\n`:Home()`       Moves the cursor to the leftmost visible data column\n\n`:Left()`       Moves the cursor left one column\n\n`:PageDown()`   Repositions the data source downward\n\n`:PageUp()`     Repositions the data source upward\n\n`:PanEnd()`     Moves the cursor to the rightmost data column\n\n`:PanHome()`    Moves the cursor to the leftmost visible data column\n\n`:PanLeft()`    Pans left without changing the cursor position\n\n`:PanRight()`   Pans right without changing the cursor position\n\n`:Right()`      Moves the cursor right one column\n\n`:Up()`         Moves the cursor up one row\n\n`:ColCount()`    Return the Current number of Columns\n\n`:ColorRect()`   Alters the color of a rectangular group of cells\n\n`:ColWidth( nColumn )`  Returns the display width of a particular column\n\n`:Configure( nMode )`   Reconfigures the internal settings of the TBrowse()\nobject <nMode> is an undocumented parameter in CA-Cl*pper\n\n`:LeftDetermine()`      Determine leftmost unfrozen column in display\n\n`:DeHilite()`           Dehighlights the current cell\n\n`:DelColumn( nPos )`    Delete a column object from a browse\n\n`:ForceStable()`        Performs a full stabilization\n\n`:GetColumn( nColumn )` Gets a specific TBColumn() object\n\n`:Hilite()`             Highlights the current cell\n\n`:InsColumn( nPos, oCol )`   Insert a column object in a browse\n\n`:Invalidate()`        Forces entire redraw during next stabilization\n\n`:RefreshAll()`        Causes all data to be recalculated during the next\nstabilize\n\n`:RefreshCurrent()`    Causes the current row to be refilled and repainted\non next stabilize\n\n`:SetColumn( nColumn, oCol )`   Replaces one TBColumn() object with another\n\n`:Stabilize()`          Performs incremental stabilization\n\n`:DispCell( nColumn, cColor )`  Displays a single cell",
    "EXAMPLES": "// See tests/tbrowse.prg",
    "STATUS": "S",
    "COMPLIANCE": "This functions is Compatible with CA-Cl*pper 5.2. The `:applykey()` and\n`:SetKey()` methods are only visible if HB_COMPAT_C53 is defined.",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "TBrowseNew(), TBColumnNew()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/tbrowse.txt",
    "TEMPLATE": "Class",
    "NAME": "TBrowse():SetKey()",
    "CATEGORY": "TBrowse Method",
    "ONELINER": "Get an optionally Set an new Code block associated to a inkey value",
    "SYNTAX": ":SetKey( <nKey>[, <bBlock>] ) --> bOldBlock",
    "ARGUMENTS": "<nKey> An valid inkey Code\n\n<bBlock>  An optional action to associate to the inkey value.",
    "RETURNS": "<bOldBlock>  If a key-press has it code block changes, it will return\nthe previous one; otherwise, it will return the current one",
    "DESCRIPTION": "This method Get an optionally set an code block that is associated to\nan inkey value.\nThe table below show the default key-press/Code Block definitions\n\n<table>\n Inkey Value    Code Block\n\n K_DOWN         {| oB, nKey | oB:Down(), 0 }\n K_END          {| oB, nKey | oB:End(), 0 }\n K_CTRL_PGDN    {| oB, nKey | oB:GoBottom(), 0 }\n K_CTRL_PGUP    {| oB, nKey | oB:GoTop(), 0 }\n K_HOME         {| oB, nKey | oB:Home(), 0 }\n K_LEFT         {| oB, nKey | oB:Left(), 0 }\n K_PGDN         {| oB, nKey | oB:PageDown(), 0 }\n K_PGUP         {| oB, nKey | oB:PageUp(), 0 }\n K_CTRL_END     {| oB, nKey | oB:PanEnd(), 0 }\n K_CTRL_HOME    {| oB, nKey | oB:PanHome(), 0 }\n K_CTRL_LEFT    {| oB, nKey | oB:PanLeft(), 0 }\n K_CTRL_RIGHT   {| oB, nKey | oB:PanRight(), 0 }\n K_RIGHT        {| oB, nKey | oB:Right(), 0 }\n K_UP           {| oB, nKey | oB:Up(), 0 }\n K_ESC          {| oB, nKey | -1 }\n</table>\n\nThe keys handlers can be queried, added and replace an removed from\nthe internal keyboard dictionary. See the example.\n```\noTb:SetKey( K_TAB, {| oTb, nKey | -1 } )\n```\nAn default key handler can be declared by specifying a value of 0\nfor <nKey>. It associate code block will be evaluated each time\nTBrowse:Applykey() is called  with an key value that is not contained\nin the dictionary. For example\n```\noTb:SetKey( 0, {| oTb, nKey | DefKeyHandler( oTb, nkey } )\n```\nThis call the a function named DefKeyHandler() when <nKey> is not\ncontained in the dictionary.\n\nTo remove an key-press/code block definition, specify NIL for <bBlock>\n```\noTb:SetKey( K_ESC, NIL )\n```",
    "EXAMPLES": "#include \"inkey.ch\"\nLOCAL oTb := TBrowseNew( 0, 0, 10, 20 )\noTb:SetKey( K_F10, {| oTb, nkey | ShowListByname( oTb ) } )"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/tbrowse.txt",
    "TEMPLATE": "Class",
    "NAME": "TBrowse():ApplyKey()",
    "CATEGORY": "TBrowse Method",
    "ONELINER": "Evaluates an code block associated with an specific key",
    "SYNTAX": ":ApplyKey( <nKey> ) --> nResult",
    "ARGUMENTS": "<nKey>      An valid Inkey code",
    "RETURNS": "<nResult>   Value returned from the evaluated Code Block\nSee Table Below\n\n<table>\n Value    Meaning\n -1       User request for the browse lost input focus\n 0        Code block associated with <nkey> was evaluated\n 1        Unable to locate <nKey> in the dictionary, Key was not processed\n</table>",
    "DESCRIPTION": "This method evaluate an code block associated with <nkey> that is\ncontained in the TBrowse:SetKey() dictionary.",
    "EXAMPLES": "LOCAL oTb := TBrowseNew( 0, 0, 10, 20 )\nDO WHILE .T.\n   oTb:forceStable()\n   IF oTb:applykey( Inkey( 0 ) ) == -1\n      EXIT\n   ENDIF\nENDDO"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/tbrowse.txt",
    "TEMPLATE": "Class",
    "NAME": "TBrowse():AddColumn()",
    "CATEGORY": "TBrowse Method",
    "ONELINER": "Add an New Column to an TBrowse Object",
    "SYNTAX": ":AddColumn( <oCol> ) --> Self",
    "ARGUMENTS": "<oCol>  Is an TbColumn object",
    "RETURNS": "<Self>  The Current object",
    "DESCRIPTION": "This method add an new column object specified as <oCol> to the\nassigned browsing object."
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/tclass.txt",
    "AUTHOR": "Copyright 2000 Brian Hays <bhays@abacuslaw.com>",
    "TEMPLATE": "Function",
    "NAME": "HBClass()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Classes",
    "ONELINER": "HBClass() is used in the creation of all classes",
    "SYNTAX": "oClass := HBClass():New( \"TMyClass\" )\n\n  -or-\n\nHBClass() is usually accessed by defining a class with the commands\ndefined in hbclass.ch:\n\nCREATE CLASS HBGetList  // Calls HBClass() to create the HBGetList class\n   ...\nENDCLASS",
    "ARGUMENTS": "",
    "RETURNS": "An instance of the HBClass() Class. This special object's `:New()`\nmethod can then create the classes you define.",
    "DESCRIPTION": "HBClass() is a class that ...\nThe class methods are as follows:\n\n`:New()`              Create a new instance of the class",
    "EXAMPLES": "LOCAL oObject := HBClass():New( \"TMyClass\" )\n\noObject:End()",
    "STATUS": "R",
    "COMPLIANCE": "Object Oriented syntax in Harbour is compatible with CA-Cl*pper.\n\nHowever CA-Cl*pper only allowed creation of objects from a few standard\nclasses, and did not let the programmer create new classes.\n\nIn Harbour, you can create your own classes--complete with\nMethods, Instance Variables, Class Variables and Inheritance.\nEntire applications can be designed and coded in Object Oriented\nstyle.",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "__objHasData(), CLASS"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Procedure",
    "NAME": "__XSaveScreen()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Save whole screen image and coordinate to an internal buffer",
    "SYNTAX": "__XSaveScreen()",
    "ARGUMENTS": "none.",
    "DESCRIPTION": "__XSaveScreen() saves the image of the whole screen into an internal\nbuffer, it also save current cursor position. The information could\nlater be restored by __XRestScreen(). Each call to __XSaveScreen()\noverwrite the internal buffer.\n\n`SAVE SCREEN` command is preprocessed into __XSaveScreen() function\nduring compile time. Note that `SAVE SCREEN TO` is preprocessed into\nSaveScreen() function.\n\n__XSaveScreen() is a compatibility function, it is superseded by\nSaveScreen() which allow you to save part or all the screen into a\nvariable.",
    "EXAMPLES": "// save the screen, display list of files than restore the screen\nSAVE SCREEN\nDIR *.*\nRESTORE SCREEN",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "RESTORE SCREEN, RestScreen(), SaveScreen()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Command",
    "NAME": "SAVE SCREEN",
    "CATEGORY": "API",
    "SUBCATEGORY": "Terminal",
    "ONELINER": "Save whole screen image and coordinate to an internal buffer",
    "SYNTAX": "SAVE SCREEN",
    "ARGUMENTS": "none.",
    "DESCRIPTION": "`SAVE SCREEN` saves the image of the whole screen into an internal\nbuffer, it also save current cursor position. The information could\nlater be restored by `RESTORE SCREEN`. Each call to `SAVE SCREEN`\noverwrite the internal buffer.\n\n`SAVE SCREEN` command is preprocessed into __XSaveScreen() function\nduring compile time. Note that `SAVE SCREEN TO` is preprocessed into\nSaveScreen() function.",
    "EXAMPLES": "// save the screen, display list of files than restore the screen\nSAVE SCREEN\nDIR *.*\nRESTORE SCREEN",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "SEEALSO": "RESTORE SCREEN, __XRestScreen(), __XSaveScreen()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Procedure",
    "NAME": "__XRestScreen()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Restore screen image and coordinate from an internal buffer",
    "SYNTAX": "__XRestScreen()",
    "ARGUMENTS": "none.",
    "DESCRIPTION": "__XRestScreen() restores saved image of the whole screen from an\ninternal buffer that was saved by __XSaveScreen(), it also restore\ncursor position. After a call to __XRestScreen() the internal buffer\nis cleared.\n\n`RESTORE SCREEN` command is preprocessed into __XRestScreen() function\nduring compile time. Note that `RESTORE SCREEN FROM` is preprocessed\ninto RestScreen() function.\n\n__XRestScreen() is a compatibility function, it is superseded by\nRestScreen() which allow you to restore the screen from a variable.",
    "EXAMPLES": "// save the screen, display list of files than restore the screen\nSAVE SCREEN\nDIR *.*\nRESTORE SCREEN",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "__XRestScreen(), SAVE SCREEN, __XSaveScreen()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Command",
    "NAME": "RESTORE SCREEN",
    "CATEGORY": "API",
    "SUBCATEGORY": "Terminal",
    "ONELINER": "Restore screen image and coordinate from an internal buffer",
    "SYNTAX": "RESTORE SCREEN",
    "ARGUMENTS": "none.",
    "DESCRIPTION": "`RESTORE SCREEN` restores saved image of the whole screen from an\ninternal buffer that was saved by `SAVE SCREEN`, it also restore\ncursor position. After a call to 'RESTORE SCREEN` the internal\nbuffer is cleared.\n\n`RESTORE SCREEN` command is preprocessed into __XRestScreen() function\nduring compile time. Note that `RESTORE SCREEN FROM` is preprocessed\ninto RestScreen() function.",
    "EXAMPLES": "// save the screen, display list of files than restore the screen\nSAVE SCREEN\nDIR *.*\nRESTORE SCREEN",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "SEEALSO": "__XRestScreen(), SAVE SCREEN, __XSaveScreen()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "Alert()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Display a dialog box with a message",
    "SYNTAX": "Alert( <xMessage>, [<aOptions>], [<cColorNorm>], [<nDelay>] ) --> nChoice or NIL",
    "ARGUMENTS": "<xMessage> Message to display in the dialog box. <xMessage> can be\nof any Harbour type.\nIf <xMessage> is an array of Character strings, each element would\nbe displayed in a new line. If <xMessage> is a Character\nstring, you could split the message to several lines by placing\na semicolon `;` in the desired places.\n\n<aOptions> Array with available response. Each element should be\nCharacter string. If omitted, default is `{ \"Ok\" }`.\n\n<cColorNorm> Color string to paint the dialog box with.\nIf omitted, default color is `\"W+/R\"`.\n\n<nDelay> Number of seconds to wait to user response before abort.\nDefault value is 0, that wait forever.",
    "RETURNS": "Alert() return Numeric value representing option number chosen.\n\nIf <Esc> was pressed, return value is zero.\n\nThe return value is NIL\nif Alert() is called with no parameters, or if <xMessage> type is\nnot Character and HB_CLP_STRICT option was used. If <nDelay> seconds\nhad passed without user response, the return value is 1.",
    "DESCRIPTION": "Alert() display simple dialog box on screen and let the user select\none option. The user can move the highlight bar using arrow keys or\n<Tab> key. To select an option the user can press <Enter>, <Space> or the\nfirst letter of the option.\n\nIf the program is executed with the `//NOALERT` command-line switch,\nnothing is displayed and it simply returns NIL. This switch could\nbe overridden with __NoNoAlert().\n\nIf the GT system is linked in, Alert() display the message using\nthe full screen I/O system, if not, the information is printed to\nthe standard output using OutStd().",
    "EXAMPLES": "LOCAL cMessage, aOptions, nChoice\n\n// harmless message\ncMessage := \"Major Database Corruption Detected!;\" + ;\n            \"(deadline in few hours);;\" + ;\n            \"where DO you want to go today?\"\n\n// define response option\naOptions := { \"Ok\", \"www.example.org\", \"Oops\" }\n\n// show message and let end user select panic level\nnChoice := Alert( cMessage, aOptions )\nDO CASE\nCASE nChoice == 0\n   // do nothing, blame it on some one else\nCASE nChoice == 1\n   ? \"Please call home and tell them you're going to be late\"\nCASE nChoice == 2\n   // make sure your resume is up to date\nCASE nChoice == 3\n   ? \"Oops mode is not working in this version\"\nENDCASE",
    "STATUS": "R",
    "COMPLIANCE": "This function is sensitive to HB_CLP_STRICT settings during the\ncompilation of src/rtl/alert.prg\n\n<b>defined</b>: <xMessage> accept Character values only and return\nNIL if other types are passed.\n\n<b>undefined</b>: <xMessage> could be any type, and internally\nconverted to Character string. If type is Array, multi-line message\nis displayed.\n\n<b>defined</b>: Only the first four valid <aOptions> are taken.\n\n<b>undefined</b>: <aOptions> could contain as many as needed options.\n\nIf HB_COMPAT_C53 was define during compilation of\nsrc/rtl/alert.prg the Left-Mouse button could be used to select\nan option.\n\nThe interpretation of the `//NOALERT` command-line switch is done only\nif HB_CLP_UNDOC was define during compilation of src/rtl/alert.prg\n\n<cColorNorm> is a Harbour extension, or at least undocumented\nin Clipper 5.2 NG.\n\n<nDelay> is a Harbour extension.",
    "FILES": "Library is core",
    "SEEALSO": "@...PROMPT, MENU TO, OutStd(), __NoNoAlert()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Procedure",
    "NAME": "__NoNoAlert()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Override `//NOALERT` command-line switch",
    "SYNTAX": "__NoNoAlert()",
    "ARGUMENTS": "This function takes no arguments.",
    "DESCRIPTION": "The `//NOALERT` command-line switch cause Cl*pper to ignore calls to\nthe Alert() function, this function override this behavior\nand always display Alert() dialog box.",
    "EXAMPLES": "// make sure alert are been displayed\n__NoNoAlert()",
    "STATUS": "R",
    "FILES": "Library is core",
    "COMPLIANCE": "C52U"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "TEMPLATE": "Function",
    "NAME": "hb_eol()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Environment",
    "ONELINER": "Returns the newline character(s) to use with the current OS",
    "SYNTAX": "hb_eol() --> cString",
    "RETURNS": "<cString> A character string containing the character or characters\nrequired to move the screen cursor or print head to the start of a\nnew line.",
    "DESCRIPTION": "Returns a character string containing the character or characters\nrequired to move the screen cursor or print head to the start of a\nnew line for the operating system that the program is running on\n(or thinks it is running on, if an OS emulator is being used).\n\nUnder HB_OS_UNIX operating system the return value is the\nLine-Feed character (0x0a, `Chr( 10 )` ); with other operating systems\n(like DOS) the return value is the Carriage-Return plus Line-Feed\ncharacters (0x0d 0x0a, `Chr( 13 ) + Chr( 10 )`).",
    "EXAMPLES": "// Get the newline character(s) for the current OS.\nOutStd( \"Hello World!\" + hb_eol() )\n? HB_ISSTRING( hb_eol() )\n? Len( hb_eol() ) <= 2",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "OS(), OutStd(), OutErr()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 1999-2001 Viktor Szakats (vszakats.net/harbour)",
    "TEMPLATE": "Function",
    "NAME": "hb_ColorIndex()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Terminal",
    "ONELINER": "Extract one color from a full color-spec string.",
    "SYNTAX": "hb_ColorIndex( <cColorSpec>, <nIndex> ) --> cColor",
    "ARGUMENTS": "<cColorSpec> is a color list\n\n<nIndex> is the position of the color item to be extracted, the\nfirst position is the zero.",
    "RETURNS": "The selected color string, or if anything goes wrong, an empty\nstring.",
    "DESCRIPTION": "CA-Cl*pper has a color spec string, which has more than one\ncolor in it, separated with commas.\n\nThis function will extract\na given item from this list. You may use the manifest constants\ndefined in color.ch to identify and extract common colors.",
    "EXAMPLES": "#include \"color.ch\"\n? hb_ColorIndex( \"W/N, N/W\", CLR_ENHANCED )  // --> \"N/W\"",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "ColorSelect()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 1999 David G. Holm <dholm@jsd-llc.com>",
    "TEMPLATE": "Procedure",
    "NAME": "DevOutPict()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Terminal",
    "ONELINER": "Displays a value to a device using a picture template",
    "SYNTAX": "DevOutPict( <xExp>, <cPicture>, [<cColorString>] )",
    "ARGUMENTS": "<xExp> is any valid expression.\n\n<cPicture> is any picture transformation that Transform() can use.\n\n<cColorString> is an optional string that specifies a screen color to\nuse in place of the default color when the output goes to the screen.",
    "DESCRIPTION": "Outputs any expression using a picture transformation instead of\nusing the default transformation for the type of expression.",
    "EXAMPLES": "// Output a negative dollar amount using debit notation.\nDevOutPict( -1.25, \"@D$ 99,999.99 )  // --> $(     1.25)",
    "STATUS": "R",
    "COMPLIANCE": "DevOutPict() is mostly CA-Cl*pper compliant. Any differences are due\nto enhancements in the Harbour Transform() over CA-Cl*pper.",
    "FILES": "Library is core",
    "SEEALSO": "DevOut(), Transform()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 1999 Jose Lalin <dezac@corevia.com>",
    "TEMPLATE": "Function",
    "NAME": "__Input()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Stops application",
    "SYNTAX": "__Input( <cMessage> ) --> cString",
    "ARGUMENTS": "<cMessage> is any valid expression.",
    "RETURNS": "<cString> input value macroed",
    "DESCRIPTION": "This function waits for a console input and returns macroed\nexpression entered.",
    "STATUS": "S",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "__Wait(), __Accept()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Procedure",
    "NAME": "__TextSave()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Internal",
    "ONELINER": "Redirect console output to printer or file and save old settings",
    "SYNTAX": "__TextSave( <cFile> )",
    "ARGUMENTS": "<cFile> is either \"PRINTER\" (note the uppercase) in which console\noutput is SET to PRINTER, or a name of a text file with a default\n`.txt` extension, that is used to redirect console output.",
    "DESCRIPTION": "__TextSave() is used in the preprocessing of the `TEXT TO` command to\nredirect the console output while saving old settings that can be\nrestored later by __TextRestore().",
    "STATUS": "R",
    "COMPLIANCE": "C52U",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Set(), SET ALTERNATE, SET PRINTER, TEXT, __TextRestore()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Procedure",
    "NAME": "__TextRestore()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Internal",
    "ONELINER": "Restore console output settings as saved by __TextSave()",
    "SYNTAX": "__TextRestore()",
    "ARGUMENTS": "none.",
    "DESCRIPTION": "__TextRestore() is used in the preprocessing of the TEXT TO command\nto restore console output settings that were previously saved by\n__TextSave().",
    "STATUS": "R",
    "COMPLIANCE": "C52U",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Set(), SET ALTERNATE, SET PRINTER, TEXT, __TextSave()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 1999 Jose Lalin <dezac@corevia.com>",
    "TEMPLATE": "Function",
    "NAME": "__Wait()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Events",
    "ONELINER": "Stops the application until a key is pressed.",
    "SYNTAX": "__Wait( <cMessage> ) --> cKey",
    "ARGUMENTS": "<cMessage> is a string.",
    "RETURNS": "Pressed key.",
    "DESCRIPTION": "This function stops the application until a key is pressed. The key\nmust be in the range 32..255. Control keys are not processed.",
    "EXAMPLES": "LOCAL cKey\n// Wait for a key stroke\n__Wait( \"Press a key to continue\" )\n\nDO WHILE ! cKey == \"Q\"\n   cKey := __Wait( \"Press 'Q' to continue\" )\nENDDO",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "__Accept(), __Input()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Procedure",
    "NAME": "OutStd()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Write a list of values to the standard output device",
    "SYNTAX": "OutStd( <xExp,...> )",
    "ARGUMENTS": "<xExp,...> is a list of expressions to display. Expressions are any\nmixture of Harbour data types.",
    "DESCRIPTION": "OutStd() write one or more values into the standard output device.\nCharacter and Memo values are printed as is, Dates are printed\naccording to the `SET DATE FORMAT`, Numeric values are converted to\nstrings, Logical values are printed as .T. or .F., NIL are printed\nas NIL, values of any other kind are printed as empty string. There\nis one space separating each two values. Note that Numeric value can\ntake varying length when converted into string depending on its\nsource (see Str() for detail).\n\nOutStd() is similar to QQOut() with the different that QQOut() send\nits output to the Harbour console stream, which can or cannot be\nredirected according with the screen driver, and OutStd() send its\noutput to the standard output device (STDOUT) and can be redirected.",
    "EXAMPLES": "OutStd( \"Hello\" )           // --> Hello\n\nOutStd( 1, .T., NIL, \"A\" )\nOutStd( \"B\" )               // -->          1 .T. NIL AB",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "",
    "FILES": "Library is core",
    "SEEALSO": "?|??, DevOut(), DevOutPict(), DispOut(), DispOutAt(), OutErr(), QOut(), QQOut(), Str()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 1999-2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Procedure",
    "NAME": "OutErr()",
    "CATEGORY": "API",
    "SUBCATEGORY": "User interface",
    "ONELINER": "Write a list of values to the standard error device",
    "SYNTAX": "OutErr( <xExp,...> )",
    "ARGUMENTS": "<xExp,...> is a list of expressions to display. Expressions are any\nmixture of Harbour data types.",
    "DESCRIPTION": "OutErr() write one or more values into the standard error device.\nCharacter and Memo values are printed as is, Dates are printed\naccording to the `SET DATE FORMAT`, Numeric values are converted to\nstrings, Logical values are printed as .T. or .F., NIL are printed\nas NIL, values of any other kind are printed as empty string. There\nis one space separating each two values. Note that Numeric value can\ntake varying length when converted into string depending on its\nsource (see Str() for detail).\n\nThere is an undocumented CA-Cl*pper command-line switch `//STDERR`\nwhich can set the file handle to write output from OutErr(). If not\nspecified the default STDERR is used, `//STDERR` or `//STDERR:0` set\nOutErr() to output to the same file handle as OutStd(), `//STDERR:n`\nset output to file handle n. Like other undocumented features this\nswitch is available only if src/rtl/console.c was compiled with\nthe HB_CLP_UNDOC flag.",
    "EXAMPLES": "// write error log information\nOutErr( hb_DateTime(), \"Core meltdown detected\" )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "",
    "FILES": "Library is core",
    "SEEALSO": "?|??, DevOut(), DevOutPict(), DispOut(), DispOutAt(), OutStd(), QOut(), QQOut(), Str()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Procedure",
    "NAME": "EJECT",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Printer",
    "ONELINER": "Issue an command to advance the printer to the top of the form",
    "SYNTAX": "EJECT",
    "ARGUMENTS": "None",
    "DESCRIPTION": "This command issue an form-feed command to the printer. If the printer\nis not properly hooked up to the computer, an error will not be\ngenerated and the command will be ignored.\n\nOnce completed, the values of PRow() and PCol(), the row and column\nindicators to the printer, will be set to 0. Their values, however, may\nbe manipulated before or after issuing an EJECT by using the DevPos()\nfunction.\n\nOn compile time this command is translated into __Eject() function.",
    "EXAMPLES": "LOCAL Curpos\nUSE test NEW\nSET DEVICE TO PRINTER\nCurpos := 0\nDO WHILE ! Eof()\n   ? test->first, test->last\n   Curpos++\n   IF Curpos > 59\n      Curpos := 0\n      EJECT\n   ENDIF\nENDDO\nSET DEVICE TO SCREEN",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "SEEALSO": "DevPos(), SET PRINTER, PRow(), PCol()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Col()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Terminal",
    "ONELINER": "Returns the current screen column position",
    "SYNTAX": "Col() --> nPosition",
    "ARGUMENTS": "None.",
    "RETURNS": "<nPosition>  Current column position",
    "DESCRIPTION": "This function returns the current cursor column position. The value\nfor this function can range between 0 and MaxCol().",
    "EXAMPLES": "? Col()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Row(), MaxRow(), MaxCol()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Row()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Terminal",
    "ONELINER": "Returns the current screen row position",
    "SYNTAX": "Row() --> nPosition",
    "ARGUMENTS": "None.",
    "RETURNS": "<nPosition>  Current screen row position",
    "DESCRIPTION": "This function returns the current cursor row location. The value\nfor this function can range between 0 and MaxCol().",
    "EXAMPLES": "? Row()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Col(), MaxRow(), MaxCol()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "MaxCol()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Terminal",
    "ONELINER": "Returns the maximum number of columns in the current video mode",
    "SYNTAX": "MaxCol() --> nPosition",
    "ARGUMENTS": "None.",
    "RETURNS": "<nPosition>  The maximum number of columns possible in current video\nmode",
    "DESCRIPTION": "This function returns the current cursor column position. The value\nfor this function can range between 0 and MaxCol().",
    "EXAMPLES": "? MaxCol()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Row(), MaxRow(), Col()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/terminal.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "MaxRow()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Terminal",
    "ONELINER": "Returns the current screen row position",
    "SYNTAX": "MaxRow() --> nPosition",
    "ARGUMENTS": "None.",
    "RETURNS": "<nPosition>  The maximum number of rows possible in current video\nmode",
    "DESCRIPTION": "This function returns the current cursor row location. The value\nfor this function can range between 0 and MaxCol().",
    "EXAMPLES": "? MaxRow()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "Col(), Row(), MaxCol()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/tlabel.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "LABEL FORM",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Legacy",
    "ONELINER": "Displays labels to the screen or an alternate device",
    "SYNTAX": "LABEL FORM <cLabelName> [TO PRINTER] [TO FILE <cFile>] [<cScope>]\n           [WHILE <bWhile> ] [FOR <bFor> ] [SAMPLE] [NOCONSOLE]",
    "ARGUMENTS": "<cLabelName>   Name of label file\n<cFile>        Name of an alternate file\n<cScope>       Expression of a scoping condition\n<bWhile>       WHILE condition\n<bFor>         FOR condition",
    "DESCRIPTION": "This command allows labels to be printed based on the format\noutlined in LBL file specified as <cLabelName>. By default, output\nwill go to the screen however this output may be rerouted with\neither the `TO PRINTER` or the `TO FILE` clause.\n\nIf the `TO FILE` clause is specified, the name of the ASCII text file\ncontaining the generated labels will be <cFile>.\n\nIf no file extension is specified a .txt extension is added.\n<cScope> is the scope condition for this command. Valid scopes\ninclude `NEXT <expN>` (number of records to be displayed, where <expN>\nis the number of records), `RECORD <expN>` (a specific record to be\nprinted), REST (all records starting from the current record\nposition, and ALL (all records). The default is ALL.\n\nBoth logical expression may work ill conjunction with one another\nwhere <bFor> is the logical expression for the FOR condition (for\nrecords to be displayed within a given value range) and <bWhile> for\nthe WHILE condition (for records to be displayed until they fail to\nmeet the condition).\n\nIf the SAMPLE clause is specified, test labels will be generated.\n\nIf the NOCONSOLE clause is specified, the console will be turned off\nwhile this command is being executed.\n\nThis command follows the search criteria outlined in the `SET PATH TO`\ncommand. The path may be specified, along, with (the drive letter,\nin <cLabelName>",
    "EXAMPLES": "USE test NEW\nLABEL FORM test.lbl",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "REPORT FORM"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/transfrm.txt",
    "AUTHOR": "Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Function",
    "NAME": "Transform()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Strings",
    "ONELINER": "Formats a value based on a specific picture template.",
    "SYNTAX": "Transform( <xExpression>, <cTemplate> ) --> cFormatted",
    "ARGUMENTS": "<xExpression> Any expression to be formatted.\n\n<cTemplate> Character string with picture template",
    "RETURNS": "<cFormatted> Formatted expression in character format",
    "DESCRIPTION": "This function returns <xExpression> in the format of the picture\nexpression passed to the function as <cTemplate>.\n\nTheir are two components that can make up <cTemplate> : a function\nstring and a template string. Function strings are those functions\nthat globally tell what the format of <xExpression> should be. These\nfunctions are represented by a single character precede by the\n@ symbol.\n\nThere are a couple of rules to follow when using function strings\nand template strings:\n\n - First, a single space must fall between the function template\n   and the template string if they are used in conjunction with\n   one another.\n\n - Second, if both components make up the value of <cTemplate>, the\n   function string must precede the template string. Otherwise, the\n   function string may appear with out the template string and\n   vice versa.\n\nThe table below shows the possible function strings available with\nthe Transform() function.\n\n<table-noheader>\n @B   Left justify the string within the format.\n @C   Issue a CR after format is numbers are positive.\n @D   Put dates in SET DATE format.\n @E   Put dates in BRITISH format.\n @L   Make a zero padded string out of the number.\n @R   Insert non template characters.\n @X   Issue a DB after format is numbers are negative.\n @Z   Display any zero as blank spaces.\n @(   Quotes around negative numbers\n @!   Convert alpha characters to uppercased format.\n</table>\n\nThe second part of <cTemplate> consists of the format string. Each\ncharacter in the string may be formatted based on using the follow\ncharacters as template markers for the string.\n\n<table-noheader>\n A,N,X,9,#   Any data type\n L           Shows logical as \"T\" or \"F\"\n Y           Shows logical as \"Y\" or \"N\"\n !           Convert to uppercase\n $           Dollar sing in place of leading spaces in numeric expression\n *           Asterisks in place of leading spaces in numeric expression\n ,           Commas position\n .           Decimal point position\n</table>",
    "EXAMPLES": "LOCAL cString := \"This is harbour\"\nLOCAL nNumber := 9923.34\nLOCAL nNumber1 := -95842.00\nLOCAL lValue := .T.\nLOCAL dDate := Date()\n? \"working with String\"\n? \"Current String is\", cString\n? \"All uppercased\", Transform( cString, \"@!\" )\n? \"Date is\", dDate\n? \"Date is\", Transform( dDate, \"@D\" )\n? Transform( nNumber, \"@L 99999999\" )  // --> \"009923.34\"\n? Transform( 0      , \"@L 9999\"     )  // --> \"0000\"",
    "STATUS": "R",
    "COMPLIANCE": "The @L function template is a FoxPro/Xbase++ Extension",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "@...SAY, DevOutPict()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/treport.txt",
    "AUTHOR": "Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>",
    "TEMPLATE": "Command",
    "NAME": "REPORT FORM",
    "CATEGORY": "Command",
    "SUBCATEGORY": "Legacy",
    "ONELINER": "Display a report",
    "SYNTAX": "REPORT FORM <cReportName> [TO PRINTER] [TO FILE <cFile>] [<cScope>]\n            [WHILE <bWhile> ] [FOR <bFor> ]\n            [PLAIN |HEADING <cHeading>] [NOEJECT] [SUMMARY]\n            [NOCONSOLE]",
    "ARGUMENTS": "<cReportName> Name of report file\n\n<cFile>       Name of alternate file\n\n<cScope>      Scope.\n\n<bWhile>      Logical expression of WHILE condition .\n\n<bFor>        Logical expression of FOR condition.\n\n<cHeading>    Report heading",
    "DESCRIPTION": "This command prints out the report named <cReportName>, which is a\nstandard FRM file. The file extension is not required because `.frm`\nwill be assumed. The `SET PATH TO` and `SET DEFAULT TO` commands affect\nthe search for the file <cReportName>; unless a drive and path are\nspecified in <cReportName>, REPORT will search the path specified in\nthe `SET PATH` command if it cannot find the report form in the\ncurrent directory.\n\nThe output of the report will be offset based on the setting of the\n`SET MARGIN TO` value.\n\nBy default, output will go to the console; however, it may be\ncontrolled via either the `TO PRINTER` or `TO FILE` clause. If the\noutput is to go to the file, the name of the alternate file is\nspecified in <cFile>. Unless specified in <cFile>, the default file\nextension will be `.txt`.\n\n<cScope> is the scope for this command. Valid scopes include\n`NEXT <expN>` (where <expN> is the number of records), `RECORD <expN>`\n(a specific record to be displayed), REST (all records from the\ncurrent record position), and ALL (all records). The default is ALL.\n\nBoth logical expressions may work in conjunction with one another,\nwhere <bFor> is the logical expression for the FOR condition (for\nrecords to be displayed within a given range) and <bWhile> for the\nWHILE condition (for records to be displayed until the condition\nfails).\n\nIf the PLAIN clause is specified, date and page numbers are\nsuppressed. In addition, there is no  automatic page breaking, and\nthe report title and column headings appear only once at the top of\nthe form.\n\nIf the HEADING clause is used, <cHeading> is displayed on the first\ntitle of each report page. The value of <cHeading> is evaluated only\nonce before executing the report; varying the values of <cHeading>\nis not allowed. The PLAIN clause will take precedence over the\nHEADING clause if both are included.\n\nIf the NOEJECT clause is used, the initial page eject on the report\nwill not be issued when the output clause `TO PRINTER` is specified.\nOtherwise, this clause has no effect.\n\nIf the SUMMARY Clause is specified, the report will contain only\ngroups, subgroups, and grand total information. The detailed title\nitem information will be ignored.\n\nIf the NOCONSOLE clause is specified, output to the console will be\nturned off while this command is being executed.",
    "EXAMPLES": "USE test NEW\nREPORT FORM test.frm",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is core",
    "SEEALSO": "LABEL FORM"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/typefile.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__TypeFile()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Terminal",
    "ONELINER": "Show the content of a file on the console and/or printer",
    "SYNTAX": "__TypeFile( <cFile>, [<lPrint>] ) --> NIL",
    "ARGUMENTS": "<cFile> is a name of the file to display. If the file have an\nextension, it must be specified (there is no default value).\n\n<lPrint> is an optional logical value that specifies whether the\noutput should go only to the screen (.F.) or to both the screen and\nprinter (.T.), the default is (.F.).",
    "RETURNS": "__TypeFile() always return NIL.",
    "DESCRIPTION": "__TypeFile() function type the content of a text file on the screen\nwith an option to send this information also to the printer. The\nfile is displayed as is without any headings or formatting.\n\nIf <cFile> contain no path, __TypeFile() try to find the file first\nin the `SET DEFAULT` directory and then in search all of the `SET PATH`\ndirectories. If <cFile> cannot be found a run-time error occur.\n\nUse `SET CONSOLE OFF` to suppress screen output.\nYou can pause the output using <Ctrl-S>, press any key to resume.\n\n__TypeFile() function is used in the preprocessing of the TYPE\ncommand.",
    "EXAMPLES": "// The following examples assume a file name `test.txt` exist in all\n// specified paths, a run-time error would displayed if it does not\n\n// display test.txt file on screen\n__TypeFile( \"test.txt\" )\n\n// display test.txt file on screen and printer\n__TypeFile( \"test.txt\", .T. )\n\n// display test.txt file on printer only\nSET CONSOLE OFF\n__TypeFile( \"test.txt\", .T. )\nSET CONSOLE ON",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "FILES": "Library is core",
    "SEEALSO": "COPY FILE, SET DEFAULT, SET PATH, SET PRINTER, TYPE"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/typefile.txt",
    "AUTHOR": "Copyright 2000 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Command",
    "NAME": "TYPE",
    "CATEGORY": "Command",
    "SUBCATEGORY": "FileSys",
    "ONELINER": "Show the content of a file on the console, printer or file",
    "SYNTAX": "TYPE <xcFile> [TO PRINTER] [TO FILE <xcDestFile>]",
    "ARGUMENTS": "<xcFile> is a name of the file to display. If the file have an\nextension, it must be specified (there is no default value).\nIt can be specified as literal file name or as a character\nexpression enclosed in parentheses.\n\n`TO PRINTER` is an optional keyword that specifies that the output\nshould go to both the screen and printer.\n\n`TO FILE` <xcDestFile> copy the source <xcFile> also to a file. If no\nextension is given `.txt` is added to the output file name.\n<xcDestFile> can be specified as literal file name or as a character\nexpression enclosed in parentheses.",
    "DESCRIPTION": "TYPE command type the content of a text file on the screen\nwith an option to send this information also to the printer or to\nan alternate file. The file is displayed as is without any headings\nor formatting.\n\nIf <xcFile> contain no path, TYPE try to find the file first in the\n`SET DEFAULT` directory and then in search all of the `SET PATH`\ndirectories. If <xcFile> cannot be found a run-time error occur.\n\nIf <xcDestFile> contain no path it is created in the `SET DEFAULT`\ndirectory.\n\nUse `SET CONSOLE OFF` to suppress screen output.\nYou can pause the output using <Ctrl-S>, press any key to resume.",
    "EXAMPLES": "// The following examples assume a file name `test.txt` exist in all\n// specified paths, a run-time error would displayed if it does not\n\n// display test.txt file on screen\nTYPE test.txt\n\n// display test.txt file on screen and printer\nTYPE test.txt TO PRINTER\n\n// display test.txt file on printer only\nSET CONSOLE OFF\nTYPE test.txt TO PRINTER\nSET CONSOLE ON\n\n// display test.txt file on screen and into a file myreport.txt\nTYPE test.txt TO FILE myreport",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "COPY FILE, SET DEFAULT, SET PATH, SET PRINTER, __TypeFile()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/var.txt",
    "AUTHOR": "Copyright 1999 Ryszard Glab <rglab@imid.med.pl>",
    "TEMPLATE": "Function",
    "NAME": "__mvPublic()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "This function creates a PUBLIC variable",
    "SYNTAX": "__mvPublic( <variable_name> )",
    "ARGUMENTS": "<variable_name> = either a string that contains the variable's name or\nan one-dimensional array of strings with variable names\nNo skeleton are allowed here.",
    "RETURNS": "Nothing",
    "DESCRIPTION": "This function can be called either by the Harbour compiler or by user.\nThe compiler always passes the item of HB_IT_SYMBOL type that stores the\nname of variable.\nIf a variable with the same name exists already then the new\nvariable is not created - the previous value remains unchanged.\nIf it is first variable with this name then the  variable is\ninitialized with .T. value.",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/var.txt",
    "AUTHOR": "Copyright 1999 Ryszard Glab <rglab@imid.med.pl>",
    "TEMPLATE": "Function",
    "NAME": "__mvPrivate()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "This function creates a PRIVATE variable",
    "SYNTAX": "__mvPrivate( <variable_name> )",
    "ARGUMENTS": "<variable_name> = either a string that contains the variable's name or\nan one-dimensional array of strings with variable names\nNo skeleton are allowed here.",
    "RETURNS": "Nothing",
    "DESCRIPTION": "This function can be called either by the Harbour compiler or by user.\nThe compiler always passes the item of HB_IT_SYMBOL type that stores the\nname of variable.\nIf a variable with the same name exists already then the value of old\nvariable is hidden until the new variable is  released. The new variable\nis always initialized to NIL value.",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/var.txt",
    "AUTHOR": "Copyright 1999 Ryszard Glab <rglab@imid.med.pl>",
    "TEMPLATE": "Function",
    "NAME": "__mvXRelease()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "This function releases value stored in PRIVATE or PUBLIC variable",
    "SYNTAX": "__mvXRelease( <variable_name> )",
    "ARGUMENTS": "<variable_name> = either a string that contains the variable's name or\nan one-dimensional array of strings with variable names\nNo skeleton are allowed here.",
    "RETURNS": "Nothing",
    "DESCRIPTION": "This function releases values stored in memory variable. It shouldn't\nbe called directly, rather it should be placed into RELEASE command.\nIf the released variable is a PRIVATE variable then previously hidden\nvariable with the same name becomes visible after exit from the\nprocedure where released variable was created. If you access\nthe released variable in the same function/procedure where it\nwas created the the NIL value is returned. You can however assign\na new value to released variable without any side effects.\n\nIt releases variable even if this variable was created in different\nprocedure.",
    "EXAMPLES": "MEMVAR mPrivate\n\nPROCEDURE Main()\n\n   PRIVATE mPrivate := \"PRIVATE from Main()\"\n\n   ? mPrivate     // --> PRIVATE from Main()\n   Test()\n   ? mPrivate     // --> PRIVATE from Main()\n\n   RETURN\n\nSTATIC PROCEDURE Test()\n\n   PRIVATE mPrivate := \"PRIVATE from Test()\"\n\n   ? mPrivate           // --> PRIVATE from Test()\n   RELEASE mPrivate\n   ? mPrivate           // --> NIL\n   mPrivate := \"Again in Main()\"\n\n   RETURN",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/var.txt",
    "AUTHOR": "Copyright 1999 Ryszard Glab <rglab@imid.med.pl>",
    "TEMPLATE": "Function",
    "NAME": "__mvRelease()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "This function releases PRIVATE variables",
    "SYNTAX": "__mvRelease( <skeleton>, <include_exclude_flag> )",
    "ARGUMENTS": "<skeleton> = string that contains the wildcard mask for variables' names\nthat will be released. Supported wildcards: '*' and '?'\n<include_exclude_flag> = logical value that specifies if variables\nthat match passed skeleton should be either included in deletion\n(if .T.) or excluded from deletion (if .F.)",
    "RETURNS": "Nothing",
    "DESCRIPTION": "This function releases values stored in memory variables. It shouldn't\nbe called directly, it should be placed into `RELEASE ALL` command.\nIf the released variable is a PRIVATE variable then previously hidden\nvariable with the same name becomes visible after exit from the\nprocedure where released variable was created. If you access\nthe released variable in the same function/procedure where it\nwas created the the NIL value is returned. You can however assign\na new value to released variable without any side effects.\nPUBLIC variables are not changed by this function.",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/var.txt",
    "AUTHOR": "Copyright 1999 Ryszard Glab <rglab@imid.med.pl>",
    "TEMPLATE": "Function",
    "NAME": "__mvScope()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "If variable exists then returns its scope.",
    "SYNTAX": "__mvScope( <cVarName> )",
    "ARGUMENTS": "<cVarName> = a string with a variable name to check",
    "RETURNS": "The symbolic values are defined in hbmemvar.ch\n<table-noheader>\n HB_MV_NOT_FOUND      variable is not declared (not found in symbol table)\n HB_MV_UNKNOWN        if variable doesn't exist (but found in symbol table)\n HB_MV_ERROR          if information cannot be obtained (memory error or argument error)\n HB_MV_PUBLIC         for public variables\n HB_MV_PRIVATE_GLOBAL for private variables declared outside of current function/procedure\n HB_MV_PRIVATE_LOCAL  for private variables declared in current function/procedure\n</table>",
    "EXAMPLES": "#include \"hbmemvar.ch\"\n\nMEMVAR pPublic\nMEMVAR mPrivateGlobal\nMEMVAR mPrivateLocal\n\nPROCEDURE Main()\n\n   PUBLIC pPublic\n   PRIVATE mPrivateGlobal\n\n   CallProc()\n   ? __mvScope( \"mPrivateLocal\" )   // --> HB_MV_UNKNOWN\n\n   RETURN\n\nSTATIC PROCEDURE CallProc()\n\n   PRIVATE mPrivateLocal\n\n   ? __mvScope( \"pPublic\" )         // --> HB_MV_PUBLIC\n   ? __mvScope( \"mPrivateGlobal\" )  // --> HB_MV_PRIVATE_GLOBAL\n   ? __mvScope( \"mPrivateLocal\" )   // --> HB_MV_PRIVATE_LOCAL\n   ? __mvScope( \"mFindMe\" )         // --> HB_MV_NOT_FOUND\n\n   IF __mvScope( \"pPublic\" ) > HB_MV_ERROR\n      ? \"Variable exists\"\n   ELSE\n      ? \"Variable not created yet\"\n   ENDIF\n\n   RETURN",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/var.txt",
    "AUTHOR": "Copyright 1999 Ryszard Glab <rglab@imid.med.pl>",
    "TEMPLATE": "Function",
    "NAME": "__mvClear()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "This function releases all PRIVATE and PUBLIC variables",
    "SYNTAX": "__mvClear()",
    "ARGUMENTS": "None",
    "RETURNS": "Nothing",
    "DESCRIPTION": "This function releases all PRIVATE and PUBLIC variables.\nIt is used to implement `CLEAR MEMORY` statement.\nThe memory occupied by all visible variables are released - any\nattempt to access the variable will result in a runtime error.\nYou have to reuse PRIVATE or PUBLIC statement to create again\nthe variable that was cleared by this function.",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "__mvPublic()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/var.txt",
    "AUTHOR": "Copyright 1999 Ryszard Glab <rglab@imid.med.pl>",
    "TEMPLATE": "Function",
    "NAME": "__mvDbgInfo()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Internal",
    "ONELINER": "This function returns the information about the variables for debugger",
    "SYNTAX": "__mvDbgInfo( <nScope> [, <nPosition> [, @<cVarName>] ] )",
    "ARGUMENTS": "<nScope> = the scope of variables for which an information is asked\n\nSupported values (defined in hbmemvar.ch)\n<table-noheader>\n HB_MV_PUBLIC\n HB_MV_PRIVATE (or any other value)\n</table>\n\n<nPosition> = the position of asked variable on the list of variables\nwith specified scope - it should start from position 1\n<cVarName> = the value is filled with a variable name if passed by\nreference and <nPosition> is specified",
    "RETURNS": "The return value depends on the number of arguments passed",
    "DESCRIPTION": "This function retrieves the information about memvar variables.\nIt returns either the number of variables with given scope (when the\nfirst argument is passed only) or a value of variable identified by its\nposition in the variables' list (when second argument is passed).\nIt also returns the name of a variable if optional third argument\nis passed by reference.\n\nIf requested variable doesn't exist (requested position is\ngreater then the number of defined variables) then NIL value is\nreturned and variable name is set to `?`.\n\nThe dynamic symbols table is used to find a PUBLIC variable then\nthe PUBLIC variables are always sorted alphabetically. The PRIVATE\nvariables are sorted in the creation order.\n\nNote:\n\nDue to dynamic nature of memvar variables there is no guarantee that\nsuccessive calls to retrieve the value of Nth PUBLIC variable will\nreturn the value of the same variable.",
    "EXAMPLES": "#include \"hbmemvar.ch\"\n\nMEMVAR cPublic\nMEMVAR cPrivate\nMEMVAR ccPublic\nMEMVAR ccPrivate\n\nPROCEDURE Main()\n\n   LOCAL nCount, tmp, xValue, cName\n\n   nCount := __mvDbgInfo( HB_MV_PUBLIC )\n   FOR tmp := 1 TO nCount\n      xValue := __mvDbgInfo( HB_MV_PUBLIC, tmp, @cName )\n      ? tmp, cName, xValue\n   NEXT\n\n   ? \"PUBLIC=\", __mvDbgInfo( HB_MV_PUBLIC )\n   ? \"PRIVATE=\", __mvDbgInfo( HB_MV_PRIVATE )\n\n   PUBLIC cPublic := \"cPublic in MAIN\"\n\n   ? \"PUBLIC=\", __mvDbgInfo( HB_MV_PUBLIC )\n   ? \"PRIVATE=\", __mvDbgInfo( HB_MV_PRIVATE )\n\n   PRIVATE cPrivate := \"cPrivate in MAIN\"\n\n   ? \"PUBLIC=\", __mvDbgInfo( HB_MV_PUBLIC )\n   ? \"PRIVATE=\", __mvDbgInfo( HB_MV_PRIVATE )\n\n   CountMemvars()\n\n   ? \"Back in Main\"\n   ? \"PUBLIC=\", __mvDbgInfo( HB_MV_PUBLIC )\n   ? \"PRIVATE=\", __mvDbgInfo( HB_MV_PRIVATE )\n\n   RETURN\n\nSTATIC PROCEDURE CountMemvars()\n\n   LOCAL nCount, tmp, xValue, cName\n\n   PUBLIC ccPublic := \"ccPublic\"\n   PRIVATE ccPrivate := \"ccPrivate\"\n\n   ? \"In CountMemvars\"\n   ? \"PUBLIC=\", __mvDbgInfo( HB_MV_PUBLIC )\n   ? \"PRIVATE=\", __mvDbgInfo( HB_MV_PRIVATE )\n\n   PRIVATE cPublic := \"cPublic\"\n\n   ? \"PUBLIC=\", __mvDbgInfo( HB_MV_PUBLIC )\n   ? \"PRIVATE=\", __mvDbgInfo( HB_MV_PRIVATE )\n\n   nCount := __mvDbgInfo( HB_MV_PRIVATE ) + 1\n   FOR tmp := 1 TO nCount\n      xValue := __mvDbgInfo( HB_MV_PRIVATE, tmp, @cName )\n      ? tmp, \"=\", cName, xValue\n   NEXT\n\n   nCount := __mvDbgInfo( HB_MV_PUBLIC ) + 1\n   FOR tmp := 1 TO nCount\n      xValue := __mvDbgInfo( HB_MV_PUBLIC, tmp, @cName )\n      ? tmp, \"=\", cName, xValue\n   NEXT\n\n   RETURN",
    "STATUS": "R",
    "COMPLIANCE": "This function should be called from the debugger only.",
    "FILES": "Library is core"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/var.txt",
    "AUTHOR": "Copyright 1999-2001 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "__mvExist()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "Determine if a given name is a PUBLIC or PRIVATE memory variable",
    "SYNTAX": "__mvExist( <cVarName> ) --> lVariableExist",
    "ARGUMENTS": "<cVarName> - string that specifies the name of variable to check",
    "RETURNS": "__mvExist() return TRUE (.T.) if a MEMVAR named <cVarName> exist.",
    "DESCRIPTION": "This function determine if a PUBLIC or PRIVATE variable with the\nname <cVarName> exist or not.",
    "EXAMPLES": "LOCAL   TheLocal\nSTATIC  TheStatic\nPUBLIC  ThePublic\nPRIVATE ThePrivate\n? __mvExist( \"NotExist\"   )  // --> .F.\n? __mvExist( \"TheLocal\"   )  // --> .F.\n? __mvExist( \"TheStatic\"  )  // --> .F.\n? __mvExist( \"ThePublic\"  )  // --> .T.\n? __mvExist( \"ThePrivate\" )  // --> .T.",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "SEEALSO": "MEMVAR, PRIVATE, PUBLIC",
    "FILES": "Library is core"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/var.txt",
    "AUTHOR": "Copyright 1999 Ryszard Glab <rglab@imid.med.pl>",
    "TEMPLATE": "Function",
    "NAME": "__mvGet()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "This function returns value of memory variable",
    "SYNTAX": "__mvGet( <cVarName> ) --> xVar",
    "ARGUMENTS": "<cVarName> - string that specifies the name of variable",
    "RETURNS": "<xVar> The value of variable",
    "DESCRIPTION": "This function returns the value of PRIVATE or PUBLIC variable if\nthis variable exists otherwise it generates a runtime error.\nThe variable is specified by its name passed as the function parameter.",
    "EXAMPLES": "? ValType( MemVarBlock( \"myvar\" ) )\nSTATIC FUNCTION MemVarBlock( cMemvar )\n   RETURN {| x | ;\n      iif( PCount() == 0, ;\n         __mvGet( cMemvar ), ;\n         __mvPut( cMemvar, x ) ) }",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "SEEALSO": "__mvPut()",
    "FILES": "Library is core"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/var.txt",
    "AUTHOR": "Copyright 1999 Ryszard Glab <rglab@imid.med.pl>",
    "TEMPLATE": "Function",
    "NAME": "__mvPut()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "This function set the value of memory variable",
    "SYNTAX": "__mvPut( <cVarName> [, <xValue>] ) --> xValue",
    "ARGUMENTS": "<cVarName> - string that specifies the name of variable\n<xValue>   - a value of any type that will be set - if it is not\nspecified then NIL is assumed",
    "RETURNS": "<xValue> A value assigned to the given variable.",
    "DESCRIPTION": "This function sets the value of PRIVATE or PUBLIC variable if\nthis variable exists otherwise it generates a runtime error.\nThe variable is specified by its name passed as the function\nparameter.\nIf a value is not specified then the NIL is assumed",
    "EXAMPLES": "? ValType( MemVarBlock( \"myvar\" ) )\nSTATIC FUNCTION MemVarBlock( cMemvar )\n   RETURN {| x | ;\n      iif( PCount() == 0, ;\n         __mvGet( cMemvar ), ;\n         __mvPut( cMemvar, x ) ) }",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "__mvPut()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/var.txt",
    "AUTHOR": "Copyright 1999 Ryszard Glab <rglab@imid.med.pl>",
    "TEMPLATE": "Function",
    "NAME": "MemVarBlock()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "Returns a codeblock that sets/gets a value of memvar variable",
    "SYNTAX": "MemVarBlock( <cMemvarName> ) --> bBlock",
    "ARGUMENTS": "<cMemvarName> - a string that contains the name of variable",
    "RETURNS": "<bBlock> a codeblock that sets/get the value of variable",
    "DESCRIPTION": "This function returns a codeblock that sets/gets the value of\nPRIVATE or PUBLIC variable. When this codeblock is evaluated\nwithout any parameters passed then it returns the current value\nof given variable. If the second parameter is passed for\nthe codeblock evaluation then its value is used to set the new\nvalue of given variable - the passed value is also returned\nas a value of the codeblock evaluation.",
    "EXAMPLES": "LOCAL cbSetGet\nPUBLIC xPublic\n\ncbSetGet := MemVarBlock( \"xPublic\" )\nEval( cbSetGet, \"new value\" )\n? \"Value of xPublic variable\", Eval( cbSetGet )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "SEEALSO": "__mvGet(), __mvPut()",
    "FILES": "Library is core"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/var.txt",
    "AUTHOR": "Copyright 1999-2001 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "FieldBlock()",
    "CATEGORY": "API",
    "SUBCATEGORY": "RDD",
    "ONELINER": "Return a code block that sets/gets a value for a given field",
    "SYNTAX": "FieldBlock( <cFieldName> ) --> bFieldBlock",
    "ARGUMENTS": "<cFieldName> is a string that contain the field name.",
    "RETURNS": "FieldBlock() return a code block that when evaluate could retrieve\na field value or assigning a new value to the field. If <cFieldName>\nis not specified or from type other than character, FieldBlock()\nreturn NIL.",
    "DESCRIPTION": "FieldBlock() return a code block that sets/gets the value of field.\nWhen this code block is evaluated without any parameters passed then\nit returns the current value of the given field. If the code block\nis evaluated with a parameter, than its value is used to set a new\nvalue to the field, this value is also return by the block. If the\nblock is evaluate and there is no field with the name <cFieldName>\nin the current work area, the code block return NIL.\n\nNote that FieldBlock() works on the current work area, if you need\na specific work area code block use FieldWBlock() instead.",
    "EXAMPLES": "// open a file named test.dbf that have a field named \"first\"\nLOCAL bField\nUSE test\nbField := FieldBlock( \"first\" )\n? \"Original value of field 'first':\", Eval( bField )\nEval( bField, \"Mr X new name\" )\n? \"New value for the field 'first':\", Eval( bField )",
    "STATUS": "R",
    "COMPLIANCE": "If the block is evaluate and there is no field with the name\n<cFieldName> in the current work area, the code block return NIL.\n\nCA-Cl*pper would raise `BASE/1003` error if the field does not exist.",
    "FILES": "Library is core",
    "SEEALSO": "Eval(), FieldWBlock(), MemVarBlock()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/var.txt",
    "AUTHOR": "Copyright 1999-2001 Chen Kedem <niki@actcom.co.il>",
    "TEMPLATE": "Function",
    "NAME": "FieldWBlock()",
    "CATEGORY": "API",
    "SUBCATEGORY": "RDD",
    "ONELINER": "Return a sets/gets code block for field in a given work area",
    "SYNTAX": "FieldWBlock( <cFieldName>, <nWorkArea> ) --> bFieldBlock",
    "ARGUMENTS": "<cFieldName> is a string that contain the field name.\n\n<nWorkArea> is the work area number in which <cFieldName> exist.",
    "RETURNS": "FieldWBlock() return a code block that when evaluate could retrieve\nfield value or assigning a new value for a field in a given work\narea. If <cFieldName> is not specified or from type other than\ncharacter, or if <nWorkArea> is not specified or is not numeric\nFieldWBlock() return NIL.",
    "DESCRIPTION": "FieldWBlock() return a code block that sets/gets the value of field\nfrom a given work area. When this code block is evaluated without\nany parameters passed then it returns the current value of the given\nfield. If the code block is evaluated with a parameter, than its\nvalue is used to set a new value to the field, this value is also\nreturn by the block. If the block is evaluate and there is no field\nwith the name <cFieldName> in work area number <nWorkArea>, the code\nblock return NIL.",
    "EXAMPLES": "LOCAL bField\n// open a file named 'one' in work area 1 that has a field named \"first\"\nSELECT 1\nUSE one\n// open a file named 'two' in work area 2 that also has a field named \"first\"\nSELECT 2\nUSE two\nSELECT 1\n// this block works on the field \"first\" that exists on work area 2\nbField := FieldWBlock( \"first\", 2 )\n? \"Original 'first' values:\", one->first, two->first\n? \"'first' value for file 'two':\", Eval( bField )\nEval( bField, \"'two' has updated 'first'\" )\n? \"and now:\", one->first, two->first",
    "STATUS": "R",
    "COMPLIANCE": "If the block is evaluate and there is no field with the name\n<cFieldName> in the given work area, the code block return NIL.\n\nCA-Cl*pper would raise BASE/1003 error if the field does not exist.",
    "FILES": "Library is core",
    "SEEALSO": "Eval(), FieldBlock(), MemVarBlock()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/var.txt",
    "AUTHOR": "Copyright 1999 Ryszard Glab <rglab@imid.med.pl>",
    "TEMPLATE": "Function",
    "NAME": "Type()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "Retrieves the type of an expression",
    "SYNTAX": "Type( <cExp> ) --> cRetType",
    "ARGUMENTS": "<cExp> must be a character expression.",
    "RETURNS": "<cRetType> a string indicating the type of the passed expression.\n\n<table>\n <cRetType>   Meaning\n\n \"A\"          Array\n \"B\"          Block\n \"C\"          Character (string)\n \"D\"          Date\n \"L\"          Logical\n \"M\"          Memo\n \"N\"          Numeric\n \"O\"          Object\n \"P\"          Pointer\n \"S\"          Symbol\n \"U\"          NIL, local or static variable, or not linked-in function\n \"UE\"         syntax error in the expression or invalid arguments\n \"UI\"         function with non-reserved name was requested\n</table>",
    "DESCRIPTION": "This function returns a string which represents the data type\nof the argument. The argument can be any valid Harbour expression.\nIf there is a syntax error in passed expression then \"UE\" is returned.\nIf there is a call for any non-reserved Harbour function then \"UI\"\nis returned (in other words there is no call for passed UDF function\nduring a data type determination - this is CA-Cl*pper compatible\nbehavior). Additionally if requested user defined function is not\nlinked into executable then \"U\" is returned.\n\nThe data type of expression is checked by invoking a macro compiler\nand by evaluation of generated code (if there is no syntax errors).\nThis causes that Type() cannot determine a type of local or static\nvariables - only symbols visible at runtime can be checked.\n\nNotice the subtle difference between Type() and ValType() functions.\nValType() function doesn't call a macro compiler - it simply checks\nthe type of passed argument of any type. Type() requires a string\nargument with a valid Harbour expression - the data type of this\nexpression is returned.",
    "EXAMPLES": "LOCAL c, cFilter\nMEMVAR a, b\n\n? Type( \"{ 1, 2 }\" )                                 // --> \"A\"\n? Type( 'iif( .T., SubStr( \"TYPE\", 2, 1 ), .F. )' )  // --> \"C\"\n? Type( 'At( \"OK\", MyUDF() ) > 0' )                  // --> \"UI\"\n? Type( \"{ 1, 2 }[ 5 ]\" )                            // --> \"UE\"\n\nPRIVATE a := \"A\", b := \"B\"\n? Type( \"a + b + c\" )     // --> \"U\" ('c' variable is a local one)\n\ncFilter := Space( 60 )\nACCEPT \"Enter filter expression:\" TO cFilter\nIF Type( cFilter ) $ \"CDLMN\"\n   // this is a valid expression\n   SET FILTER TO &cFilter\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "- Incompatibility with CA-Cl*pper:\n  In the following code:\n\n    ```\n    PRIVATE lCond := 0\n    ? Type( \"iof( lCond, 'true', MyUDF() )\" )\n    ```\n  CA-Cl*pper will print \"UE\" - in Harbour the output will be \"UI\"\n\n- If \"UI\" is returned then the syntax of the expression is\n  correct. However invalid arguments can be passed to\n  function/procedure that will cause runtime errors during\n  evaluation of expression.\n\n- Harbour supports two new types (Pointer and Symbol) which does\n  not exists in CA-Cl*pper.",
    "FILES": "Library is core",
    "SEEALSO": "ValType()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/var.txt",
    "TEMPLATE": "Function",
    "NAME": "ValType()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "Retrieves the data type of an expression",
    "SYNTAX": "ValType( <xExp> ) --> cRetType",
    "ARGUMENTS": "<xExp> is any valid expression.",
    "RETURNS": "<cRetType> a character indicating the type of the passed expression.\n\n<table>\n <cRetType>   Meaning\n\n \"A\"          Array\n \"B\"          Block\n \"C\"          Character (string)\n \"D\"          Date\n \"L\"          Logical\n \"M\"          Memo\n \"N\"          Numeric\n \"O\"          Object\n \"P\"          Pointer\n \"S\"          Symbol\n \"U\"          NIL\n</table>",
    "DESCRIPTION": "This function returns one character which represents the data type\nof the argument.",
    "EXAMPLES": "? ValType( Array( 1 ) )    // --> \"A\"\n? ValType( {|| 1 + 1 } )   // --> \"B\"\n? ValType( \"Harbour\" )     // --> \"C\"\n? ValType( Date() )        // --> \"D\"\n? ValType( .T. )           // --> \"L\"\n? ValType( 1 )             // --> \"N\"\n? ValType( TBrowse() )     // --> \"O\"\n? ValType( hb_idleAdd() )  // --> \"P\" Harbour extension\n? ValType( @QOut() )       // --> \"S\" Harbour extension\n? ValType( NIL )           // --> \"U\"",
    "STATUS": "R",
    "COMPLIANCE": "ValType() is CA-Cl*pper compliant, with the addition of the new\nHarbour types: Pointer and Symbol.",
    "FILES": "Library is core",
    "SEEALSO": "Type()"
  },
  {
    "_COMPONENT": "harbour",
    "_LANG": "en",
    "_DOCSOURCE": "./doc/en/var.txt",
    "AUTHOR": "Copyright 2002 Walter Negro <anegro@overnet.com.ar>",
    "TEMPLATE": "Function",
    "NAME": "hb_PIsByRef()",
    "CATEGORY": "API",
    "SUBCATEGORY": "Variable management",
    "ONELINER": "Determine if a parameter is passed by reference.",
    "SYNTAX": "hb_PIsByRef( nParam ) --> lParamIsByRef",
    "ARGUMENTS": "<nParam> is the parameter number to test.",
    "RETURNS": "<lVarIsByRef> a logical value indicating if the parameter is\npassed by reference to actual function or procedure.",
    "DESCRIPTION": "This function return a logical value indicating if the parameter\nis passed by reference to actual function or procedure.\n\nThis function is based on the form that Harbour manages to the\nvariables for reference. When a variable is passed by reference,\nwhat receives the function or procedure is, a pointer to the\nprevious variable, be this the container variable of the data or\na pointer to another variable. The function observes if the\nvariable passed points to a common variable or to a variable\npassed by reference.",
    "EXAMPLES": "PROCEDURE Main()\n\n   LOCAL cVar := \"Test local\"\n\n   MEMVAR m_nVar\n   PRIVATE m_nVar := 0\n\n   Test( @cVar, @m_nVar, cVar, m_nVar )\n\n   RETURN\n\nSTATIC PROCEDURE Test( Arg1, Arg2, Arg3, Arg4 )\n   ? hb_PIsByRef( 1 )  // --> .T.\n   ? hb_PIsByRef( 2 )  // --> .T.\n   ? hb_PIsByRef( 3 )  // --> .F.\n   ? hb_PIsByRef( 4 )  // --> .F.\n   RETURN",
    "STATUS": "S",
    "COMPLIANCE": "H",
    "FILES": "Library is core",
    "SEEALSO": "ValType()"
  }
]
