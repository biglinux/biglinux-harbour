[
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/addascii.txt",
    "NAME": "AddAscii()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Add an integer value to an ASCII value of a string",
    "SYNTAX": "AddAscii( <[@]cString>, <nValue>, [<nPosition>], [<lCarryOver>] ) --> cString",
    "ARGUMENTS": "<[@]cString>   is the string that should be edited\n<nValue>       is a integer value that should be added to the\n               ASCII value of the character at the <nPosition>th position\n[<nPosition>]  is the position of the character that should be edited.\n               If not supplied, the last character of <[@]cString> is\n               edited.\n[<lCarryOver>] NEW: is set to .T. if the substring from position 1 to\n               position <nPosition> should be treated as an integer\n               written to the base 256. Thus, the addition of <nValue>\n               can affect to whole substring (see EXAMPLES).\n               Default is .F., the original behaviour of this function.",
    "RETURNS": "The edited string is returned. The return value can be suppressed by\nusing the CSetRef() function. The string must then be passed by\nreference [@].",
    "DESCRIPTION": "AddAscii() can be used to add or subtract integer values from\nASCII values in a string. The new <lCarryOver> parameter allows\nto treat a string as an integer written to the base 256. Since\n<nValue> is limited to a signed long, only substrings 4 characters\nlong can be affected by one AddAscii() call.\nIf the length of <[@]cString> is smaller than <nPosition>, the\nstring remains unchanged. The same happens, if uninterpretable\nparameters are passed to this function.",
    "EXAMPLES": "// Add 32 to the ASCII value of the character at the last position\n// in the string\n\n? AddAscii( \"SmitH\", 32 )  // --> \"Smith\"",
    "STATUS": "R",
    "COMPLIANCE": "AddAscii() is compatible with CT3's AddAscii().\nA new, 4th, parameter has been added who defaults to the original\nbehaviour if omitted.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/asciisum.txt",
    "NAME": "AsciiSum()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "calculate the sum of the ASCII values of the characters in a string",
    "SYNTAX": "AsciiSum( <cString> ) --> nAsciiSum",
    "ARGUMENTS": "<cString>      the string to be processed",
    "RETURNS": "<nAsciiSum>    sum of the ASCII values in <cString>",
    "DESCRIPTION": "The AsciiSum() function sums up the ASCII values of the characters\nin <cString>. Be aware that the function is not position sensitive,\ni.e. a change of position of a certain character in the string does\nnot change the ASCII sum.",
    "EXAMPLES": "? AsciiSum( \"ABC\" )  // -->  197\n? AsciiSum( \"ACB\" )  // -->  197",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Checksum()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ascpos.txt",
    "NAME": "AscPos()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "ASCII value of a character at a certain position",
    "SYNTAX": "AscPos( <cString>, [<nPosition>] ) --> nAsciiValue",
    "ARGUMENTS": "<cString>      is the processed string\n[<nPosition>]  is an optional position within <cString>\n               Default: last position in <cString>",
    "RETURNS": "<nAsciiValue>  the ASCII value of the character at the specified\n               position",
    "DESCRIPTION": "The AscPos() function returns the ASCII value of the character that\ncan be found at the position <nPosition> in <cString>. If <nPosition>\nis larger than the length of <cString>, 0 is returned.",
    "EXAMPLES": "? AscPos( \"0123456789\" )     // --> 57\n? AscPos( \"0123456789\", 1 )  // --> 48",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "ValPos()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ascpos.txt",
    "NAME": "ValPos()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Numerical value of a character at a certain position",
    "SYNTAX": "ValPos( <cString>, [<nPosition>] ) --> nDigitValue",
    "ARGUMENTS": "<cString>      is the processed string\n[<nPosition>]  is an optional position within <cString>\n               Default: last position in <cString>",
    "RETURNS": "<nDigitValue>  the numerical value of the character at the specified\n               position",
    "DESCRIPTION": "The ValPos() function returns the numerical value of the character that\ncan be found at the position <nPosition> in <cString>. If no digit\ncan be found at this position or if <nPosition>\nis larger than the length of <cString>, 0 is returned.",
    "EXAMPLES": "? ValPos( \"1234x56789\" ) // --> 9\n? ValPos( \"1234x56789\", 1 ) // --> 1",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "AscPos()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/atadjust.txt",
    "NAME": "AtAdjust()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Adjusts a sequence within a string to a specified position",
    "SYNTAX": "AtAdjust( <cStringToMatch>, <cString>, <nAdjustPosition>,\n          [<nCounter>], [<nIgnore>],\n          [<nFillChar|cFillChar>] ) --> cString",
    "ARGUMENTS": "<cStringToMatch>        is the sequence to be adjusted within <cString>\n<cString>               is the string that contains <cStringToMatch>\n<nAdjustPosition>       specifies the position to that <cStringToMatch>\n                        will be adjusted\n[<nCounter>]            specifies which occurrence of <cStringToMatch>\n                        in <cString> is to be adjusted\n                        Default: last occurrence\n[<nIgnore>]             specifies how many characters should be omitted\n                        in the scan\n[<nFillChar|cFillChar>] specifies the character that is used for the\n                        adjustment",
    "RETURNS": "<cString>               the changed string",
    "DESCRIPTION": "<TODO: add a description, some examples and tests here>",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "AtAdjust() works like CT3's AtAdjust()",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "SetAtLike(), CSetAtMupa()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/atnum.txt",
    "NAME": "AfterAtNum()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Returns string portion after nth occurrence of substring",
    "SYNTAX": "AfterAtNum( <cStringToMatch>, <cString>, [<nCounter>],\n            [<nIgnore>] ) --> cRestString",
    "ARGUMENTS": "<cStringToMatch>    is the substring scanned for\n<cString>           is the scanned string\n[<nCounter>]        determines how many occurrences are of\n                    <cStringToMatch> in <cString> are searched\n                    Default: search last occurrence\n[<nIgnore>]         determines how many character from the start\n                    should be ignored in the search\n                    Default: 0",
    "RETURNS": "<cRestString>       the portion of <cString> after the <nCounter>th\n                    occurrence of <cStringToMatch> in <cString>\n                    If such a rest does not exist, an empty string\n                    is returned.",
    "DESCRIPTION": "This function scans <cString> for <cStringToMatch>. After the\n<nCounter>th match (or the last one, depending on the value of\n<nCounter>) has been found, the portion of\n<cString> after that match will be returned. If there aren't enough\nmatches or the last match is identical to the end of <cString>, an\nempty string will be returned.\nAfter a match has been found, the function continues to scan after\nthat match if the CSetAtMupa() switch is turned off, with the\nsecond character of the matched substring otherwise.\nThe function will also consider the settings of SetAtLike().",
    "EXAMPLES": "? AfterAtNum( \"!\", \"What is the answer ? 4 ! 5 !\" )  // --> \"\"\n? AfterAtNum( \"!\", \"What is the answer ? 4 ! 5 ?\" )  // --> \" 5 ?\"\n// TODO: add some examples here with CSetAtMupa() and SetAtLike()",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "AtNum(), BeforAtNum(), CSetAtMupa(), SetAtLike()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/atnum.txt",
    "NAME": "BeforAtNum()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Returns string portion before nth occurrence of substring",
    "SYNTAX": "BeforAtNum( <cStringToMatch>, <cString>, [<nCounter>],\n            [<nIgnore>] ) --> cRestString",
    "ARGUMENTS": "<cStringToMatch>    is the substring scanned for\n<cString>           is the scanned string\n[<nCounter>]        determines how many occurrences are of\n                    <cStringToMatch> in <cString> are searched\n                    Default: search last occurrence\n[<nIgnore>]         determines how many character from the start\n                    should be ignored in the search\n                    Default: 0",
    "RETURNS": "<cRestString>       the portion of <cString> before the <nCounter>th\n                    occurrence of <cStringToMatch> in <cString>\n                    If such a string does not exist, an empty string\n                    is returned.",
    "DESCRIPTION": "This function scans <cString> for <cStringToMatch>. After the\n<nCounter>th match (or the last one, depending on the value of\n<nCounter>) has been found, the portion of\n<cString> before that match will be returned. If there aren't enough\nmatches or the last match is identical to the start of <cString>\n(i.e. the last match is the first match), an empty string will be returned.\nAfter a match has been found, the function continues to scan after\nthat match if the CSetAtMupa() switch is turned off, with the\nsecond character of the matched substring otherwise.\nThe function will also consider the settings of SetAtLike().",
    "EXAMPLES": "? BeforAtNum( \"!\", \"What is the answer ? 4 ! 5 !\" )  // --> \"What is the answer ? 4 ! 5 \"\n? BeforAtNum( \"!\", \"What is the answer ? 4 ! 5 ?\" )  // --> \"What is the answer ? 4 \"\n<TODO: add some examples here with CSetAtMupa() and SetAtLike()>",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "AtNum(), AfterAtNum(), CSetAtMupa(), SetAtLike()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/atnum.txt",
    "NAME": "AtNum()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Returns the start position of the nth occurrence of a substring in a string",
    "SYNTAX": "AtNum( <cStringToMatch>, <cString>, [<nCounter>],\n       [<nIgnore>] ) --> nPosition",
    "ARGUMENTS": "<cStringToMatch>    is the substring scanned for\n<cString>           is the scanned string\n[<nCounter>]        determines how many occurrences are of\n                    <cStringToMatch> in <cString> are searched\n                    Default: search last occurrence\n[<nIgnore>]         determines how many character from the start\n                    should be ignored in the search\n                    Default: 0",
    "RETURNS": "<nPosition>         the position of the <nCounter>th\n                    occurrence of <cStringToMatch> in <cString>.\n                    If such an occurrence does not exist, 0\n                    is returned.",
    "DESCRIPTION": "This function scans <cString> for <cStringToMatch>. After the\n<nCounter>th match (or the last one, depending on the value of\n<nCounter>) has been found, the position of\nthat match will be returned. If there aren't enough\nmatches or there is no last match, 0 will be returned.\nAfter a match has been found, the function continues to scan after\nthat match if the CSetAtMupa() switch is turned off, with the\nsecond character of the matched substring otherwise.\nThe function will also consider the settings of SetAtLike().",
    "EXAMPLES": "? AtNum( \"!\", \"What is the answer ? 4 ! 5 !\" )  // --> 28\n? AtNum( \"!\", \"What is the answer ? 4 ! 5 ?\" )  // --> 24\n<TODO: add some examples here with CSetAtMupa() and SetAtLike()>",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "AtNum(), AfterAtNum(), CSetAtMupa(), SetAtLike()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/atrepl.txt",
    "NAME": "AtRepl()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Search and replace sequences in a string",
    "SYNTAX": "AtRepl( <cStringToMatch>, <cString>, <cReplacement>, [<nCounter>],\n        [<lMode>], [<nIgnore>] ) --> cString",
    "ARGUMENTS": "<cStringToMatch>   is the substring searched for in <cString>\n<cString>          is the processed string\n<cReplacement>     is the replacement for sequences found\n[<nCounter>]       specifies the number of replacements\n                   Default: last occurrence\n[<lMode>]          if set to .T., only the <nCounter>th sequence\n                   of <cStringToMatch> will be replaced, else\n                   all sequences will be replaced.\n                   Default: .F.\n[<nIgnore>])       specifies how many characters in <cString> from\n                   the beginning should be ignored by the function\n                   Default: 0",
    "RETURNS": "<cString>",
    "DESCRIPTION": "The AtRepl() function searches and replaces sequences in a string.\nFirst, the function ignores the first <nIgnore> characters of <cString>.\nThen, if <lMode> is set to .T., it searches for the <nCounter>th\noccurrence of <cStringToMatch> in <cString>. If successful, the\nsequence will be replaced with <cReplacement>.\nIf <lMode> is set to .F., the same search is performed, but EVERY\noccurrence of <cStringToMatch> till the <nCounter>th (inclusive) will\nbe replaced with <cReplacement>. Note that, in this case,\nthe replacements are performed even if the <nCounter>th occurrence\ndoes not exist.\nBy using the CSetAtMupa() switch you can decide whether the\nfunction restarts searching after a found sequence of after\nthe first character of that sequence.\nThe function allows the use of wildcards in <cStringToMatch>\nand looks for the settings of SetAtLike().",
    "EXAMPLES": "? AtRepl( \"ABC\", \"ABCDABCDABC\", \"xx\" )          // --> \"xxDxxDxx\"\n? AtRepl( \"ABC\", \"ABCDABC\", \"ZYXW\" )            // --> \"ZYXWDZYXW\"\n? AtRepl( \"ABC\", \"ABCDABCDABC\", \"xx\", 2 )       // --> \"xxDxxDABC\"\n? AtRepl( \"ABC\", \"ABCDABCDABC\", \"xx\", 2, .T. )  // --> \"ABCDxxDABC\"",
    "STATUS": "R",
    "COMPLIANCE": "AtRepl() is compatible with CT3's AtRepl().\nNote the new, 6th parameter !",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CSetAtMupa(), SetAtLike()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charevod.txt",
    "NAME": "CharEven()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Returns the characters on the even positions in a string",
    "SYNTAX": "CharEven( <cString> ) --> cEvenString",
    "ARGUMENTS": "<cString>      processed string",
    "RETURNS": "<cEvenString>  a string containing all character from even positions\n               in <cString>",
    "DESCRIPTION": "The CharEven() function looks for the characters on the even positions\nin a given string, collects them and returns them as a string.",
    "EXAMPLES": "? CharEven( \" H E L L O !\" )  // --> \"HELLO!\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharOdd(), CharMix()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charevod.txt",
    "NAME": "CharOdd()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Returns the characters on the odd positions in a string",
    "SYNTAX": "CharOdd( <cString> ) --> cOddString",
    "ARGUMENTS": "<cString>      processed string",
    "RETURNS": "<cOddString>  a string containing all character from odd positions\n              in <cString>",
    "DESCRIPTION": "The CharOdd() function looks for the characters on the odd positions\nin a given string, collects them and returns them as a string.",
    "EXAMPLES": "? CharOdd( \"H E L L O ! \" )  // --> \"HELLO!\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharEven(), CharMix()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charlihb.txt",
    "NAME": "CharSList()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Generates a sorted list of all characters in a string",
    "SYNTAX": "CharSList( [<cString>] ) --> cSortedCharacterList",
    "ARGUMENTS": "[<cString>]       is the string for whom the function generates a\n                  sorted list of all characters\n                  Default: \"\" (empty string)",
    "RETURNS": "<cSortedCharacterList>  a sorted list of the characters in <cString>",
    "DESCRIPTION": "The CharList() function generates a sorted list of those characters that\nare contained in <cString>. This list can contain each character\nonly once, so that its maximum length is 256. The function\ngives the same result as `CharSort( CharList( cString ) )`",
    "EXAMPLES": "? CharSList( \"Hello World !\" )  // --> \" !HWdelor\"",
    "STATUS": "R",
    "COMPLIANCE": "CharSList() is only available in Harbour's CT3 library.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharNoList(), CharList(), CharHist()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charlihb.txt",
    "NAME": "CharHist()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Generates a character histogram of a string",
    "SYNTAX": "CharHist( [<cString>] ) --> aCharacterCount",
    "ARGUMENTS": "[<cString>]       is the string for whom the function generates a\n                  character histogram\n                  Default: \"\" (empty string)",
    "RETURNS": "<aCharacterCount> an array with 256 elements where the nth element\n                  contains the count of character #(n-1) in <cString>",
    "DESCRIPTION": "The CharHist() function generates a character histogram of those\ncharacters that are contained in <cString>. This histogram is stored\nin an 256-element array where the nth element contains the count\nof ASCII character #(n-1) in <cString>.",
    "EXAMPLES": "? CharHist( \"Hello World !\" )[ 109 ] // --> 3  // Chr( 108 ) == \"l\"",
    "STATUS": "R",
    "COMPLIANCE": "CharHist() is only available in Harbour's CT3 library.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharList(), CharNoList(), CharSList()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charlist.txt",
    "NAME": "CharList()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Generates a list of all characters in a string",
    "SYNTAX": "CharList( [<cString>] ) --> cCharacterList",
    "ARGUMENTS": "[<cString>]       is the string for whom the function generates a list\n                  of all characters\n                  Default: \"\" (empty string)",
    "RETURNS": "<cCharacterList>  a list of the characters in <cString>",
    "DESCRIPTION": "The CharList() function generates a list of those characters that\nare contained in <cString>. This list can contain each character\nonly once, so that its maximum length is 256. The list lists those\ncharacters first that are occurring in <cString> first.",
    "EXAMPLES": "? CharList( \"Hello World !\" )  // --> \"Helo Wrd!\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharNoList(), CharSList(), CharHist()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charlist.txt",
    "NAME": "CharNoList()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Generates a list of all characters not contained in a string",
    "SYNTAX": "CharNoList( [<cString>] ) --> cCharacterList",
    "ARGUMENTS": "[<cString>]       is the string for whom the function generates a list\n                  of all characters not contained in that string\n                  Default: \"\" (empty string)",
    "RETURNS": "<cCharacterList>  a list of the characters that are not contained in <cString>",
    "DESCRIPTION": "The CharNoList() function generates a list of those characters that\nare not contained in <cString>. This list can contain each character\nonly once, so that its maximum length is 256. The list is alphabetically\nsorted.",
    "EXAMPLES": "? CharNoList( CharNoList( \"Hello World !\" ) ) // --> \" !HWdelor\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharList(), CharSList(), CharHist()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charmirr.txt",
    "NAME": "CharMirr()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Mirror a string",
    "SYNTAX": "CharMirr( <[@]cString>, [<lDontMirrorSpaces>] ) --> cMirroredString",
    "ARGUMENTS": "<[@]cString>            is the string that should be mirrored\n[<lDontMirrorSpaces>]   if set to .T., spaces at the end of\n                        <cString> will not be mirrored but kept at the end\n                        Default: .F., mirror the whole string",
    "RETURNS": "<cMirroredString>       the mirrored string",
    "DESCRIPTION": "The CharMirr() function mirrors a string, i.e. the first character\nwill be put at the end, the second at the last but one position etc..\nOne can use this function for index searches, but then, the spaces\nat the end of the string should not be mirrored.\nOne can omit the return value of the function by setting the CSetRef()\nswitch to .T., but <cString> must then be passed by reference to get\na result.",
    "EXAMPLES": "? CharMirr( \"racecar\" )         // \"racecar\"\n? CharMirr( \"racecar  \", .T. )  // \"racecar  \"\n? CharMirr( \"racecar  \", .F. )  // \"  racecar\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charmix.txt",
    "NAME": "CharMix()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Mix two strings",
    "SYNTAX": "CharMix( <cString1>[, <cString2>] ) --> cMixedString",
    "ARGUMENTS": "<cString1>     String that will be mixed with the characters from <cString2>\n[<cString2>]   String whose characters will be mixed with the one from\n               <cString1>.\n               Default: \" \" (string with one space char)",
    "RETURNS": "<cMixedString> Mixed string",
    "DESCRIPTION": "The CharMix() function mixes the strings <cString1> and <cString2>. To\ndo this it takes one character after the other alternatively from\n<cString1> and <cString2> and puts them in the output string.\nThis procedure is stopped when the end of <cString1> is reached. If\n<cString2> is shorter than <cString1>, the function will start at\nthe begin of <cString2> again. If on the other hand <cString2> is\nlonger than <cString1>, the surplus characters will be omitted.",
    "EXAMPLES": "? CharMix( \"ABC\", \"123\" )   // \"A1B2C3\"\n? CharMix( \"ABCDE\", \"12\" )  // \"A1B2C1D2E1\"\n? CharMix( \"AB\", \"12345\" )  // \"A1B2\"\n? CharMix( \"HELLO\", \" \" )   // \"H E L L O \"\n? CharMix( \"HELLO\", \"\" )    // \"HELLO\"",
    "STATUS": "R",
    "COMPLIANCE": "CharMix() is compatible with CT3's CharMix().\nNOTE: CA-Tools version of CharMix() will hang\n      if the second parameter is an empty string, this version will not.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharEven(), CharOdd()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charone.txt",
    "NAME": "CharOne()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Reduce multiple occurrences of a character to one",
    "SYNTAX": "CharOne( [<cCharactersToReduce>,] <cString> ) --> cReducedString",
    "ARGUMENTS": "[<cCharactersToReduce>]    specifies the characters the multiple\n                           occurrences of which should be reduced to one\n                           Default: All characters.\n<cString>                  specifies the processed string",
    "RETURNS": "<cReducedString>           the string with the reduced occurrences",
    "DESCRIPTION": "The CharOne() function reduces multiple occurrences of characters in\n<cString> to a single one. It is important to note that the multiple\noccurrences must occur directly one behind the other. This behaviour is\nis in contrast to the CharList() function.",
    "EXAMPLES": "? CharOne( \"122333a123\" )       // \"123a123\"\n? CharOne( \"A  B  CCCD\" )       // \"A B CD\"\n? CharOne( \" \", \"A  B  A  B\" )  // \"A B A B\"\n? CharOne( \"o\", \"122oooB12o\" )  // \"122oB12o\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharRem(), WordOne()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charone.txt",
    "NAME": "WordOne()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Reduce multiple occurrences of a double character to one",
    "SYNTAX": "WordOne( [<cDoubleCharactersToReduce>,] <cString> ) --> cReducedString",
    "ARGUMENTS": "[<cDoubleCharactersToReduce>]  specifies the double characters the multiple\n                               occurrences of which should be reduced to one\n                               Default: All characters.\n<cString>                      specifies the processed string",
    "RETURNS": "<cReducedString>               the string with the reduced occurrences",
    "DESCRIPTION": "The WordOne() function reduces multiple occurrences of double characters in\n<cString> to a single one. It is important to note that the multiple\noccurrences must occur directly one behind the other.",
    "EXAMPLES": "? WordOne( \"12ABAB12\" )       // \"12AB12\"\n? WordOne( \"1AAAA2\" )         // \"1AAAA2\"\n? WordOne( \"12\", \"1212ABAB\" ) // \"12ABAB\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharOne(), CharRem()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charonly.txt",
    "NAME": "CharOnly()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Intersectional set of two strings based on characters",
    "SYNTAX": "CharOnly( <cThisCharactersOnly>, <cString> ) --> cReducedString",
    "ARGUMENTS": "<cThisCharactersOnly>   specifies the characters that must not be\n                        deleted in <cString>.\n<cString>               is the string that should be processed",
    "RETURNS": "<cReducedString>        A string with all characters deleted but those\n                        specified in <cThisCharactersOnly>.",
    "DESCRIPTION": "The CharOnly() function calculates the intersectional set of two\nstrings. To do this, it deletes all characters from <cString> that\ndo not appear in <cThisCharacterOnly>.",
    "EXAMPLES": "? CharOnly( \"0123456789\", \"0211 - 38 99 77\" )  // \"0211389977\"\n? CharOnly( \"0123456789\", \"0211/ 389 977\" )    // \"0211389977\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharRem(),  WordOnly(),  WordRem()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charonly.txt",
    "NAME": "WordOnly()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Intersectional set of two strings based on double characters",
    "SYNTAX": "WordOnly( <cThisDoubleCharactersOnly>, <cString> ) --> cReducedString",
    "ARGUMENTS": "<cThisDoubleCharactersOnly> specifies the double characters that must\n                            not be deleted in <cString>.\n<cString>                   is the string that should be processed",
    "RETURNS": "<cReducedString>        A string with all double characters deleted\n                        but those specified in <cThisCharactersOnly>.",
    "DESCRIPTION": "The WordOnly() function calculates the intersectional set of two\nstrings based on double characters. To do this, it deletes all double\ncharacters from <cString> that do not appear in <cThisDoubleCharacterOnly>.",
    "EXAMPLES": "? WordOnly( \"AABBCCDD\", \"XXAAYYBBZZ\" )  // \"AABB\"\n? WordOnly( \"AABBCCDD\", \"XAAYYYBBZZ\" )  // \"BB\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharOnly(),  CharRem(),  WordRem()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charonly.txt",
    "NAME": "CharRem()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Removes characters from a string",
    "SYNTAX": "CharRem( <cDeleteThisCharacters>, <cString> ) --> cReducedString",
    "ARGUMENTS": "<cDeleteThisCharacters>   specifies the characters that should\n                          be deleted in <cString>\n<cString>)                is the string that should be processed",
    "RETURNS": "<cReducedString>          is a string where the characters specified\n                          in <cDeleteThisCharacters> are deleted",
    "DESCRIPTION": "The CharRem() function deletes the characters specified in\n<cDeleteThisCharacters> from <cString>.",
    "EXAMPLES": "? CharRem( \" \", \" 1  2  \" )   // \"12\"\n? CharRem( \"3y\", \"xyz123\" )   // \"xz12\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharOnly(),  WordOnly(),  WordRem()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charonly.txt",
    "NAME": "WordRem()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Removes characters from a string",
    "SYNTAX": "WordRem( <cDeleteThisDoubleCharacters>, <cString> ) --> cReducedString",
    "ARGUMENTS": "<cDeleteThisDoubleCharacters>   specifies the double characters that\n                                should be deleted in <cString>\n<cString>)                      is the string that should be processed",
    "RETURNS": "<cReducedString>          is a string where the double characters\n                          specified in <cDeleteThisDoubleCharacters>\n                          are deleted",
    "DESCRIPTION": "The WordRem() function deletes the double characters specified in\n<cDeleteThisDoubleCharacters> from <cString>.",
    "EXAMPLES": "? WordRem( \"abcd\", \"0ab1cd\" )   // \"0ab1\"\n? WordRem( \"abcd\", \"ab0cd1\" )   // \"0cd1\"",
    "STATUS": "R",
    "COMPLIANCE": "WordRem() is a new function available only in Harbour's CT3.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharOnly(),  CharRem(),  WordRem()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charop.txt",
    "NAME": "CharAdd()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Adds corresponding ASCII value of two strings",
    "SYNTAX": "CharAdd( <[@]cString1>, <cString2> ) --> cAddString",
    "ARGUMENTS": "<[@]cString1>   first string\n<cString2>      second string",
    "RETURNS": "<cAddString>    string with added ASCII values",
    "DESCRIPTION": "The CharAdd() function constructs a new string from the two strings\npassed as parameters. To do this, it adds the ASCII values of the\ncorresponding characters of both strings and places a character in\nthe resulting string whose ASCII value equals to that sum (modulo 256).\nIf the first string is passed by reference, the resulting string is\nstored in <cString1>, too. By setting the CSetRef()-switch to .T.,\nthe return value can be omitted.\nIf <cString2> is shorter than <cString1> and the last character of\n<cString2> has been processed, the function restarts with the first\ncharacter of <cString2>.",
    "EXAMPLES": "? CharAdd( \"012345678\", hb_BChar( 1 ) )    // --> \"123456789\"\n? CharAdd( \"123456789\", hb_BChar( 255 ) )  // --> \"012345678\"\n? CharAdd( \"0000\", hb_BChar( 0 ) + hb_BChar( 1 ) + hb_BChar( 2 ) + hb_BChar( 3 ) )  // --> \"0123\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharSub(),  CharAnd(),  CharNot(),\nCharOr(),   CharXor(),  CharShl(),\nCharShr(),  CharRll(),  CharRlr(),\nCSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charop.txt",
    "NAME": "CharAnd()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Combine corresponding ASCII value of two strings with bitwise AND",
    "SYNTAX": "CharAnd( <[@]cString1>, <cString2> ) --> cAndString",
    "ARGUMENTS": "<[@]cString1>   first string\n<cString2>      second string",
    "RETURNS": "<cAndString>    string with bitwise AND combined ASCII values",
    "DESCRIPTION": "The CharAnd() function constructs a new string from the two strings\npassed as parameters. To do this, it combines the ASCII values of the\ncorresponding characters of both strings with a bitwise AND-operation\nand places a character in the resulting string whose ASCII value\nequals to the result of that operation.\nIf the first string is passed by reference, the resulting string is\nstored in <cString1>, too. By setting the CSetRef()-switch to .T.,\nthe return value can be omitted.\nIf <cString2> is shorter than <cString1> and the last character of\n<cString2> has been processed, the function restarts with the first\ncharacter of <cString2>.",
    "EXAMPLES": "// clear the LSB\n? CharAnd( \"012345678\", hb_BChar( 254 ) ) // --> \"002244668\"\n? CharAnd( \"012345678\", hb_BChar( 254 ) + hb_BChar( 252 ) ) // --> \"002044648\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharAdd(),  CharSub(),  CharNot(),\nCharOr(),   CharXor(),  CharShl(),\nCharShr(),  CharRll(),  CharRlr(),\nCSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charop.txt",
    "NAME": "CharNot()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Process each character in a string with bitwise NOT operation",
    "SYNTAX": "CharNot( <[@]cString> ) --> cNotString",
    "ARGUMENTS": "<[@]cString>    string to be processed",
    "RETURNS": "<cNotString>    string with bitwise negated characters",
    "DESCRIPTION": "The CharNot() function constructs a new string from the string\npassed as parameter. To do this, it performs a bitwise NOT operation\nto the characters of the string and places a character in\nthe resulting string whose ASCII value equals to the result of that\noperation. It can be easily seen that the resulting ASCII-value equals\n255 minus input ASCII value.\nIf the string is passed by reference, the resulting string is\nstored in <cString>, too. By setting the CSetRef()-switch to .T.,\nthe return value can be omitted.",
    "EXAMPLES": "? CharNot( hb_BChar(  85 ) + hb_BChar( 128 ) + hb_BChar( 170 ) + hb_BChar(   1 ) )\n// -->     hb_BChar( 170 ) + hb_BChar( 127 ) + hb_BChar(  85 ) + hb_BChar( 254 )\n? CharNot( CharNot( \"This is a test!\" ) ) // --> \"This is a test!\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharAdd(),  CharSub(),  CharAnd(),\nCharOr(),   CharXor(),  CharShl(),\nCharShr(),  CharRll(),  CharRlr(),\nCSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charop.txt",
    "NAME": "CharOr()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Combine corresponding ASCII value of two strings with bitwise OR",
    "SYNTAX": "CharOr( <[@]cString1>, <cString2> ) --> cOrString",
    "ARGUMENTS": "<[@]cString1>   first string\n<cString2>      second string",
    "RETURNS": "<cOrString>     string with bitwise OR combined ASCII values",
    "DESCRIPTION": "The CharOr() function constructs a new string from the two strings\npassed as parameters. To do this, it combines the ASCII values of the\ncorresponding characters of both strings with a bitwise OR-operation\nand places a character in the resulting string whose ASCII value\nequals to the result of that operation.\nIf the first string is passed by reference, the resulting string is\nstored in <cString1>, too. By setting the CSetRef()-switch to .T.,\nthe return value can be omitted.\nIf <cString2> is shorter than <cString1> and the last character of\n<cString2> has been processed, the function restarts with the first\ncharacter of <cString2>.",
    "EXAMPLES": "// set the LSB\n? CharOr( \"012345678\", hb_BChar( 1 ) ) // --> \"113355779\"\n? CharOr( \"012345678\", hb_BChar( 1 ) + hb_BChar( 3 ) ) // --> \"133357779\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharAdd(),  CharSub(),  CharNot(),\nCharAnd(),  CharXor(),  CharShl(),\nCharShr(),  CharRll(),  CharRlr(),\nCSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charop.txt",
    "NAME": "CharXor()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Combine corresponding ASCII value of two strings with bitwise XOR",
    "SYNTAX": "CharXor( <[@]cString1>, <cString2> ) --> cXOrString",
    "ARGUMENTS": "<[@]cString1>   first string\n<cString2>      second string",
    "RETURNS": "<cXOrString>    string with bitwise XOR combined ASCII values",
    "DESCRIPTION": "The CharXor() function constructs a new string from the two strings\npassed as parameters. To do this, it combines the ASCII values of the\ncorresponding characters of both strings with a bitwise XOR-operation\nand places a character in the resulting string whose ASCII value\nequals to the result of that operation.\nIf the first string is passed by reference, the resulting string is\nstored in <cString1>, too. By setting the CSetRef()-switch to .T.,\nthe return value can be omitted.\nIf <cString2> is shorter than <cString1> and the last character of\n<cString2> has been processed, the function restarts with the first\ncharacter of <cString2>.",
    "EXAMPLES": "// easy encryption\n? CharXor( \"This is top secret !\", \"My Password\" ) // --> <encrypted sentence>",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharAdd(),  CharSub(),  CharNot(),\nCharAnd(),  CharOr(),   CharShl(),\nCharShr(),  CharRll(),  CharRlr(),\nCSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charophb.txt",
    "NAME": "CharSub()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Subtracts corresponding ASCII value of two strings",
    "SYNTAX": "CharSub( <[@]cString1>, <cString2>) --> cSubString",
    "ARGUMENTS": "<[@]cString1>   first string\n<cString2>      second string",
    "RETURNS": "<cSubString>    string with subtracted ASCII values",
    "DESCRIPTION": "The CharSub() function constructs a new string from the two strings\npassed as parameters. To do this, it subtracts the ASCII values of the\ncorresponding characters of both strings and places a character in\nthe resulting string whose ASCII value equals to that difference (modulo 256).\nIf the first string is passed by reference, the resulting string is\nstored in <cString1>, too. By setting the CSetRef()-switch to .T.,\nthe return value can be omitted.\nIf <cString2> is shorter than <cString1> and the last character of\n<cString2> has been processed, the function restarts with the first\ncharacter of <cString2>.",
    "EXAMPLES": "? CharSub( \"012345678\", hb_BChar( 1 ) )    // --> \"/01234567\"\n? CharSub( \"123456789\", hb_BChar( 255 ) )  // --> \"23456789:\"\n? CharSub( \"9999\", hb_BChar( 0 ) + hb_BChar( 1 ) + hb_BChar( 2 ) + hb_BChar( 3 ) )  // --> \"9876\"",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharAdd(),  CharAnd(),  CharNot(),\nCharOr(),   CharXor(),  CharShl(),\nCharShr(),  CharRll(),  CharRlr(),\nCSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charophb.txt",
    "NAME": "CharShl()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Process each character in a string with bitwise SHIFT LEFT operation",
    "SYNTAX": "CharShl( <[@]cString>, <nBitsToSHL> ) --> cSHLString",
    "ARGUMENTS": "<[@]cString>    string to be processed\n<nBitsToSHL>    number of bit positions to be shifted to the left",
    "RETURNS": "<cSHLString>    string with bitwise shifted left characters",
    "DESCRIPTION": "The CharShl() function constructs a new string from the string\npassed as parameter. To do this, it performs a bitwise SHIFT LEFT\n(SHL) operation to the characters of the string and places a character in\nthe resulting string whose ASCII value equals to the result of that\noperation.\nBe aware that bits shifted out of the byte are lost. If you need\na bit rotation, use the CharRll() function instead.\nIf the string is passed by reference, the resulting string is\nstored in <cString>, too. By setting the CSetRef()-switch to .T.,\nthe return value can be omitted.",
    "EXAMPLES": "? CharShl( hb_BChar(   1 ) + hb_BChar(  2 ) + hb_BChar(  4 ) + hb_BChar(   8 ) + ;\n           hb_BChar(  16 ) + hb_BChar( 32 ) + hb_BChar( 64 ) + hb_BChar( 128 ), 3 )\n// -->     hb_BChar(   8 ) + hb_BChar( 16 ) + hb_BChar( 32 ) + hb_BChar(  64 ) + ;\n//         hb_BChar( 128 ) + hb_BChar(  0 ) + hb_BChar(  0 ) + hb_BChar(   0 )",
    "STATUS": "R",
    "COMPLIANCE": "CharShl() is a new function that is only available in Harbour's CT3 lib.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharAdd(),  CharSub(),  CharAnd(),\nCharOr(),   CharXor(),  CharNot(),\nCharShr(),  CharRll(),  CharRlr(),\nCSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charophb.txt",
    "NAME": "CharShr()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Process each character in a string with bitwise SHIFT RIGHT operation",
    "SYNTAX": "CharShr( <[@]cString>, <nBitsToSHR> ) --> cSHRString",
    "ARGUMENTS": "<[@]cString>    string to be processed\n<nBitsToSHR>    number of bit positions to be shifted to the right",
    "RETURNS": "<cSHRString>    string with bitwise shifted right characters",
    "DESCRIPTION": "The CharShr() function constructs a new string from the string\npassed as parameter. To do this, it performs a bitwise SHIFT RIGHT\n(SHR) operation to the characters of the string and places a character in\nthe resulting string whose ASCII value equals to the result of that\noperation.\nBe aware that bits shifted out of the byte are lost. If you need\na bit rotation, use the CharRlr() function instead.\nIf the string is passed by reference, the resulting string is\nstored in <cString>, too. By setting the CSetRef()-switch to .T.,\nthe return value can be omitted.",
    "EXAMPLES": "? CharShr( hb_BChar(  1 ) + hb_BChar(  2 ) + hb_BChar(  4 ) + hb_BChar(   8 ) + ;\n           hb_BChar( 16 ) + hb_BChar( 32 ) + hb_BChar( 64 ) + hb_BChar( 128 ), 3 )\n// -->     hb_BChar(  0 ) + hb_BChar(  0 ) + hb_BChar(  0 ) + hb_BChar(   1 ) + ;\n//         hb_BChar(  2 ) + hb_BChar(  4 ) + hb_BChar(  8 ) + hb_BChar(  16 )",
    "STATUS": "R",
    "COMPLIANCE": "CharShr() is a new function that is only available in Harbour's CT3 lib.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharAdd(),  CharSub(),  CharAnd(),\nCharOr(),   CharXor(),  CharNot(),\nCharShl(),  CharRll(),  CharRlr(),\nCSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charophb.txt",
    "NAME": "CharRll()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Process each character in a string with bitwise ROLL LEFT operation",
    "SYNTAX": "CharRll( <[@]cString>, <nBitsToRLL> ) --> cRLLString",
    "ARGUMENTS": "<[@]cString>    string to be processed\n<nBitsToRLL>    number of bit positions to be rolled to the left",
    "RETURNS": "<cRLLString>    string with bitwise rolled left characters",
    "DESCRIPTION": "The CharRll() function constructs a new string from the string\npassed as parameter. To do this, it performs a bitwise ROLL LEFT\n(RLL) operation to the characters of the string and places a character in\nthe resulting string whose ASCII value equals to the result of that\noperation.\nBe aware that, in contrast to CharShl(), bits rolled out on\nthe left are put in again on the right.\nIf the string is passed by reference, the resulting string is\nstored in <cString>, too. By setting the CSetRef()-switch to .T.,\nthe return value can be omitted.",
    "EXAMPLES": "? CharRll( hb_BChar(   1 ) + hb_BChar(  2 ) + hb_BChar(  4 ) + hb_BChar(   8 ) + ;\n           hb_BChar(  16 ) + hb_BChar( 32 ) + hb_BChar( 64 ) + hb_BChar( 128 ), 3 )\n// -->     hb_BChar(   8 ) + hb_BChar( 16 ) + hb_BChar( 32 ) + hb_BChar(  64 ) + ;\n//         hb_BChar( 128 ) + hb_BChar(  1 ) + hb_BChar(  2 ) + hb_BChar(   4 )",
    "STATUS": "R",
    "COMPLIANCE": "CharRll() is a new function that is only available in Harbour's CT3 lib.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharAdd(),  CharSub(),  CharAnd(),\nCharOr(),   CharXor(),  CharNot(),\nCharShl(),  CharShr(),  CharRlr(),\nCSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charophb.txt",
    "NAME": "CharRlr()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Process each character in a string with bitwise ROLL RIGHT operation",
    "SYNTAX": "CharRlr( <[@]cString>, <nBitsToRLR> ) --> cRLRString",
    "ARGUMENTS": "<[@]cString>    string to be processed\n<nBitsToRLR>    number of bit positions to be rolled to the right",
    "RETURNS": "<cRLRString>    string with bitwise rolled right characters",
    "DESCRIPTION": "The CharRlr() function constructs a new string from the string\npassed as parameter. To do this, it performs a bitwise ROLL RIGHT\n(RLR) operation to the characters of the string and places a character in\nthe resulting string whose ASCII value equals to the result of that\noperation.\nBe aware that, in contrast to CharShr(), bits rolled out on\nthe right are put in again on the left.\nIf the string is passed by reference, the resulting string is\nstored in <cString>, too. By setting the CSetRef()-switch to .T.,\nthe return value can be omitted.",
    "EXAMPLES": "? CharRlr( hb_BChar(  1 ) + hb_BChar(  2 ) + hb_BChar(   4 ) + hb_BChar(   8 ) + ;\n           hb_BChar( 16 ) + hb_BChar( 32 ) + hb_BChar(  64 ) + hb_BChar( 128 ), 3 )\n// -->     hb_BChar( 32 ) + hb_BChar( 64 ) + hb_BChar( 128 ) + hb_BChar(   1 ) + ;\n//         hb_BChar(  2 ) + hb_BChar(  4 ) + hb_BChar(   8 ) + hb_BChar(  16 )",
    "STATUS": "R",
    "COMPLIANCE": "CharRlr() is a new function that is only available in Harbour's CT3 lib.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharAdd(),  CharSub(),  CharAnd(),\nCharOr(),   CharXor(),  CharNot(),\nCharShl(),  CharShr(),  CharRll(),\nCSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charrepl.txt",
    "NAME": "CharRepl()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Replacement of characters",
    "SYNTAX": "CharRepl( <cSearchString>, <[@]cString>,\n          <cReplaceString>, [<lMode>] ) --> cString",
    "ARGUMENTS": "<cSearchString>    is a string of characters that should be replaced\n<[@]cString>       is the processed string\n<cReplaceString>   is a string of characters that replace the one\n                   of <cSearchString>\n[<lMode>]          sets the replacement method (see description)\n                   Default: .F.",
    "RETURNS": "<cString>          the processed string",
    "DESCRIPTION": "The CharRepl() function replaces certain characters in <cString>\nwith others depending on the setting of <lMode>.\nIf <lMode> is set to .F., the function takes the characters of\n<cSearchString> one after the other, searches for them in <cString>\nand, if successful, replaces them with the corresponding character\nof <cReplaceString>. Be aware that if the same characters occur\nin both <cSearchString> and <cReplaceString>, the character on a\ncertain position in <cString> can be replaced multiple times.\nif <lMode> is set to .T., the function takes the characters in <cString>\none after the other, searches for them in <cSearchString> and, if\nsuccessful, replaces them with the corresponding character of\n<cReplaceString>. Note that no multiple replacements are possible\nin this mode.\nIf <cReplaceString> is shorter than <cSearchString>, the last\ncharacter of <cReplaceString> is used as corresponding character\nfor the the \"rest\" of <cSearchString>.\nOne can omit the return value by setting the CSetRef() switch to .T.,\nbut then one must pass <cString> by reference to get the result.",
    "EXAMPLES": "? CharRepl( \"1234\", \"1x2y3z\", \"abcd\" )             // \"axbycz\"\n? CharRepl( \"abcdefghij\", \"jhfdb\", \"1234567890\" )  // \"08642\"\n? CharRepl( \"abcdefghij\", \"jhfdb\", \"12345\" )       // \"55542\"\n? CharRepl( \"1234\", \"1234\", \"234A\" )               // \"AAAA\"\n? CharRepl( \"1234\", \"1234\", \"234A\", .T. )          // \"234A\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "WordRepl(),  PosRepl(),  RangeRepl(), CSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charsort.txt",
    "NAME": "CharSort()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Sort sequences within a string.",
    "SYNTAX": "CharSort( <[@]cString>, [<nElementLength>], [<nCompareLength>],\n          [<nIgnoreCharacters>], [<nElemenOffset>], [<nSortLength>],\n          [<lDescending>] ) --> cSortedString",
    "ARGUMENTS": "<[@]cString>             is the string that should be processed\n[<nElementLength>]       specifies the length of the elements that\n                         should be sorted\n                         Default: 1\n[<nCompareLength>]       specifies how many characters within one\n                         element should be used for comparison\n                         Default: <nElementLength>\n[<nIgnoreCharacters>]    specifies the number of characters at the\n                         beginning of <cString> that should be ignored\n                         in the sort process\n                         Default: 0\n[<nElementOffset>]       specifies the offset of the comparison string\n                         within a element\n                         Default: 0\n[<nSortLength>]          specifies how many characters in <cString>,\n                         starting from the <nIgnoreCharacters> position,\n                         should be sorted\n                         Default: `hb_BLen( cString ) - nIgnoreCharacters`\n[<lDescending>])         specifies whether the process should\n                         sort descending or not",
    "RETURNS": "<cSortedString>          the string resulting from the sort process",
    "DESCRIPTION": "The CharSort() function sorts the characters within a string <cString>.\nWith the parameters <nIgnoreCharacters> and <nSortLength>, you can\ndetermine that only the substring from position <nIgnoreCharacters>+1\nto position <nIgnoreCharacters>+<nSortLength> within <cString> should\nbe sorted.\nThe sorting algorithm is determined with the other parameters.\n<nElementLength> specifies the length of one element, i.e. there are\n<nSortLength>/<nElementLength> elements that are sorted. Note that\nsurplus characters are not sorted but stay at their position.\nTo do the sorting, the function uses the Quicksort algorithm implemented\nin the C-lib qsort() function. This algorithm needs to know how to compare\nand order two elements. This is done by comparing the ASCII values of\na substring within each element. This substring is determined by the\nparameters <nElementOffset> and <nCompareLength> and the order\nby <lDescending>.\nBy setting the CSetRef() switch to .T., one can omit the return value\nof the function, but one must then pass <cString> by reference.",
    "EXAMPLES": "? CharSort( \"qwert\" )                     // \"eqrtw\"\n? CharSort( \"qwert\", 2 )                  // \"erqwt\"\n? CharSort( \"b1a4a3a2a1\", 2, 1 )          // \"a2a1a3a4b1\"\n? CharSort( \"XXXqwert\", 1, 1, 3 )         // \"XXXeqrtw\"\n? CharSort( \"b1a4a3a2a1\", 2, 1, 0, 1 )    // \"a1b1a2a3a4\"\n? CharSort( \"384172852\", 1, 1, 0, 0, 4 )  // \"134872852\"\n? CharSort( \"qwert\", .T. )                // \"wtrqe\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charswap.txt",
    "NAME": "CharSwap()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Swap neighbouring characters in a string",
    "SYNTAX": "CharSwap( <[@]cString> ) --> cSwappedString",
    "ARGUMENTS": "<[@]cString>      is the string that should be processed",
    "RETURNS": "<cSwappedString>  a string where neighbour characters are swapped",
    "DESCRIPTION": "The CharSwap() function loops through <cString> in steps of two\ncharacters and exchanges the characters from the odd and the even\npositions.\nBy setting the CSetRef() switch to .T., one can omit the return value\nof this function, but one must then pass <cString> by reference.",
    "EXAMPLES": "? CharSwap( \"0123456789\" )   // \"1032547698\"\n? CharSwap( \"ABCDEFGHIJK\" )  // \"BADCFEHGJIK\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "WordSwap(), CSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/charswap.txt",
    "NAME": "WordSwap()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Swap neighbouring double characters in a string",
    "SYNTAX": "WordSwap( <[@]cString> [, <lSwapCharacters>] ) --> cSwappedString",
    "ARGUMENTS": "<[@]cString>         is the string that should be processed\n[<lSwapCharacters>]  specifies whether an additional swap should be\n                     done within the double characters\n                     Default: .F., no additional swap",
    "RETURNS": "<cSwappedString>  a string where neighbouring double characters are\n                  swapped",
    "DESCRIPTION": "The WordSwap() function loops through <cString> in steps of four\ncharacters and exchanges the double characters from the first and\nsecond position with the one from the third and forth position.\nAdditionally the function can perform a swap of the both char of\neach double character.\nBy setting the CSetRef() switch to .T., one can omit the return value\nof this function, but one must then pass <cString> by reference.",
    "EXAMPLES": "? WordSwap( \"1234567890\" )       // \"3412785690\"\n? WordSwap( \"1234567890\", .T. )  // \"4321876590\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharSwap(), CSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/color.txt",
    "NAME": "InvertAttr()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "",
    "SYNTAX": "",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/color.txt",
    "NAME": "ColorToN()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "",
    "SYNTAX": "ColorToN( <cAttr> ) --> nAttr",
    "ARGUMENTS": "<cAttr>    Designates the alphanumeric color attribute that is\n           converted in NN/NN or CC/CC form.\n",
    "RETURNS": "ColorToN() returns a number that corresponds to the combined numeric\ncolor attribute.\n",
    "DESCRIPTION": "COLOR TO (N)umeric\nThe function changes an alphanumeric color attribute from NN/NN or\nCC/CC into a combined numeric attribute.  These combined attribute\nvalues are useful with the CA-Cl*pper Tools functions StrScreen(),\nScreenMix(), ScreenAttr(), and the CA-Cl*pper commands\nSAVE/RESTORE SCREEN.\n\nTODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/color.txt",
    "NAME": "NToColor()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "",
    "SYNTAX": "NToColor( <nAttr>, [<lColorCode>] ) --> cAttr",
    "ARGUMENTS": "<nAttr>    Designates the value for the combined numeric color\n           attributes.\n\n<lColorCode>  If designated as .F. or if the parameter is omitted,\n              NToColor() returns a string with a numeric color code.\n              When designated as .T., NToColor() returns a string with\n              the CA-Cl*pper alpha color coding.\n",
    "RETURNS": "NToColor() returns the designated color attribute in the NN/NN\nor CC/CC form.\n",
    "DESCRIPTION": "NToColor() converts a color attribute returned from another function\nin numeric form, into the alphanumeric data format.  Use this\nattribute in conjunction with the CA-Cl*pper SET COLOR TO command.\n\nTODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/color.txt",
    "NAME": "Enhanced()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "Select the \"ENHANCED\" color value for output",
    "SYNTAX": "Enhanced() --> cEmptyString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Standard(), Unselected()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/color.txt",
    "NAME": "Standard()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "Select the \"STANDARD\" color value for output",
    "SYNTAX": "Standard() --> cEmptyString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Enhanced(), Unselected()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/color.txt",
    "NAME": "Unselected()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "Select the \"UNSELECTED\" color value for output",
    "SYNTAX": "Unselected() --> cEmptyString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Enhanced(), Standard()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/count.txt",
    "NAME": "CountLeft()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Count a certain character at the beginning of a string",
    "SYNTAX": "CountLeft( <cString>, [<cSearch|nSearch>] ) --> nCount",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CountRight()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/count.txt",
    "NAME": "CountRight()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Count a certain character at the end of a string",
    "SYNTAX": "CountRight( <cString>, [<cSearch|nSearch>] ) --> nCount",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CountLeft()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ctc.txt",
    "NAME": "CSetArgErr()",
    "CATEGORY": "CT3 general functions",
    "ONELINER": "Sets argument error behaviour",
    "SYNTAX": "CSetArgErr( [<nNewMode>] ) --> nOldMode",
    "ARGUMENTS": "[<nNewMode>]   New argument error throwing mode",
    "RETURNS": "<nOldMode>     The current or old argument error throwing mode.",
    "DESCRIPTION": "All CT3 functions are very compliant in their reaction to wrong\nparameters. By using the CSetArgErr() function, you can make the\nlibrary throw an error with the severity <nNewMode>. It is then\nup to the error handler to substitute the return value.\n<nNewMode> can be one of the severity modes defined in ct.ch:\n<table-noheader>\n CT_ARGERR_WHOCARES      corresponds to ES_WHOCARES\n CT_ARGERR_WARNING       corresponds to ES_WARNING\n CT_ARGERR_ERROR         corresponds to ES_ERROR\n CT_ARGERR_CATASTROPHIC  corresponds to ES_CATASTROPHIC\n CT_ARGERR_IGNORE\n</table>\nThe last is the default behaviour and switches any argument error\nthrowing off.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ctmath.txt",
    "NAME": "SetPrec()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Set precision of math functions",
    "SYNTAX": "SetPrec( <nPrecision> ) --> cEmptyString",
    "ARGUMENTS": "<nPrecision>    digit count between 1 and 16, defaults to 16",
    "RETURNS": "<cEmptyString>  this function always returns an empty string",
    "DESCRIPTION": "Be aware that calls to this functions do _not_ affect the\ncalculation precision of the math functions at the moment.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ctmath.txt",
    "NAME": "GetPrec()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Get precision of math functions",
    "SYNTAX": "GetPrec() --> nDigits",
    "ARGUMENTS": "",
    "RETURNS": "<nDigits>        digit count between 1 and 16",
    "DESCRIPTION": "Be aware that calls to this functions do _NOT_ affect the\ncalculation precision of the math functions at the moment.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ctmath2.txt",
    "NAME": "Floor()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Rounds down a number to the next integer",
    "SYNTAX": "Floor( <nNumber> ) --> nDownRoundedNumber",
    "ARGUMENTS": "<nNumber>             number to round down",
    "RETURNS": "<nDownRoundedNumber>  the rounded number",
    "DESCRIPTION": "The function Floor() determines the biggest integer that is smaller\nthan <nNumber>.",
    "EXAMPLES": "? Floor( 1.1 )   // --> 1.0\n? Floor( -1.1 )  // --> -2.0",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Ceiling()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ctmath2.txt",
    "NAME": "Ceiling()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Rounds up a number to the next integer",
    "SYNTAX": "Ceiling( <nNumber> ) --> nUpRoundedNumber",
    "ARGUMENTS": "<nNumber>             number to round up",
    "RETURNS": "<nUpRoundedNumber>    the rounded number",
    "DESCRIPTION": "The function Ceiling() determines the smallest integer that is bigger\nthan <nNumber>.",
    "EXAMPLES": "? Ceiling( 1.1 )   // --> 2.0\n? Ceiling( -1.1 )  // --> -1.0",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Floor()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ctmath2.txt",
    "NAME": "Sign()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Sign of a number",
    "SYNTAX": "Sign( <nNumber> ) --> nSign",
    "ARGUMENTS": "<nNumber>             a number",
    "RETURNS": "<nSign>               sign of <nNumber>",
    "DESCRIPTION": "The function Sign() determines the sign of <nNumber>.\nIf <nNumber> is > 0, then Sign(<nNumber>) returns 1\nIf <nNumber> is < 0, then Sign(<nNumber>) returns -1\nIf <nNumber> is == 0, then Sign(<nNumber>) returns 0",
    "EXAMPLES": "? Sign( 1.1 )   // --> 1\n? Sign( -1.1 )  // --> -1\n? Sign( 0.0 )   // --> 0",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ctmath2.txt",
    "NAME": "Log10()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Decadic logarithm of a number",
    "SYNTAX": "Log10( <nNumber> ) --> nLogarithm",
    "ARGUMENTS": "<nNumber>             number to logarithm",
    "RETURNS": "<nLogarithm>          decadic logarithm of <nNumber>",
    "DESCRIPTION": "The function Log10() calculates the decadic logarithm of <nNumber>,\ni.e. 10^<nLogarithm> == <nNumber>.",
    "EXAMPLES": "? Log10( 10.0 )          // --> 1.0\n? Log10( Sqrt( 10.0 ) )  // --> 0.5",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ctmath2.txt",
    "NAME": "Fact()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Calculates faculty",
    "SYNTAX": "Fact( <nNumber> ) --> nFaculty",
    "ARGUMENTS": "<nNumber>          number between 0 and 21",
    "RETURNS": "<nFaculty>         the faculty of <nNumber>",
    "DESCRIPTION": "The function Fact() calculates the faculty to the integer given in\n<nNumber>. The faculty is defined as n! = 1*2*...*n and is often\nused in statistics. Note, that faculties above 21 are too big\nso that the function must return a -1.",
    "EXAMPLES": "? Fact( 0 )  // --> 1\n? Fact( 1 )  // --> 1\n? Fact( 4 )  // --> 24",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ctpad.txt",
    "NAME": "PadLeft()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Fills string to a certain length on the left",
    "SYNTAX": "PadLeft( <cString>, <nLength>, [<cChar|nChar>] ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "PadRight()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ctpad.txt",
    "NAME": "PadRight()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Fills string to a certain length on the right",
    "SYNTAX": "PadRight( <cString>, <nLength>, [<cChar|nChar>] ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "PadLeft()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ctstr.txt",
    "NAME": "CSetRef()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Determine return value of reference sensitive CT3 string functions",
    "SYNTAX": "CSetRef( [<lNewSwitch>] ) --> lOldSwitch",
    "ARGUMENTS": "[<lNewSwitch>]  .T. - suppress return value\n                .F. - do not suppress return value",
    "RETURNS": "<lOldSwitch>      old (if <lNewSwitch> is a logical value) or\n                  current state of the switch",
    "DESCRIPTION": "Within the CT3 functions, the following functions do not\nchange the length of a string passed as parameter while\ntransforming this string:\n\nAddAscii()   Blank()       CharAdd()\nCharAnd()    CharMirr()    CharNot()\nCharOr()     CharRelRep()  CharRepl()\nCharSort()   CharSwap()    CharXor()\nCrypt()      JustLeft()    JustRight()\nPosChar()    PosRepl()     RangeRepl()\nReplAll()    ReplLeft()    ReplRight()\nTokenLower() TokenUpper()  WordRepl()\nWordSwap()\n\nThus, these functions allow to pass the string by reference `@` to\nthe function so that it may not be necessary to return the transformed\nstring. By calling `CSetRef( .T. )`, the above mentioned functions return\nthe value .F. instead of the transformed string if the string is\npassed by reference to the function.\nThe switch is turned off (.F.) by default.\n",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "AddAscii(),   Blank(),       CharAdd(),\nCharAnd(),    CharMirr(),    CharNot(),\nCharOr(),     CharRelRep(),  CharRepl(),\nCharSort(),   CharSwap(),    CharXor(),\nCrypt(),      JustLeft(),    JustRight(),\nPosChar(),    PosRepl(),     RangeRepl(),\nReplAll(),    ReplLeft(),    ReplRight(),\nTokenLower(), TokenUpper(),  WordRepl(),\nWordSwap()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ctstr.txt",
    "NAME": "CSetAtMupa()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Determine \"multi-pass\" behaviour in some string functions",
    "SYNTAX": "CSetAtMupa( [<lNewSwitch>] ) --> lOldSwitch",
    "ARGUMENTS": "[<lNewSwitch>]  .T. - turn \"multi-pass\" on\n                .F. - turn \"multi-pass\" off",
    "RETURNS": "<lOldSwitch>    old (if <lNewSwitch> is a logical value) or\n                current state of the switch",
    "DESCRIPTION": "CSetAtMupa() determines how the following CT3 string functions\n\nAtNum()       AfterAtNum()  BeforAtNum()\nAtRepl()      NumAt()       AtAdjust()\nWordToChar()  WordRepl()\n\nperform their work. See the respective function documentation for a\nfurther description how the switch influences these functions.\n",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "AtNum(),      AfterAtNum(),  BeforAtNum(),\nAtRepl(),     NumAt(),       AtAdjust(),\nWordToChar(), WordRepl()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ctstr.txt",
    "NAME": "SetAtLike()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Determine scan behaviour in some string functions",
    "SYNTAX": "SetAtLike( [<nMode>] [, <[@]cWildcard>] ) --> nOldMode",
    "ARGUMENTS": "[<nMode>]   CT_SETATLIKE_EXACT    - characters are compared exactly\n            CT_SETATLIKE_WILDCARD - characters are compared using\n                                    a wildcard character\n            The default value is CT_SETATLIKE_EXACT.\n[<[@]cWildcard>]  determines the character that is subsequently used\n                  as a wildcard character for substring scanning.\n                  The default value is \"?\".\n                  NEW: If this parameter is passed by reference `@`,\n                  the current wildcard character is stored in\n                  <cWildcard>.",
    "RETURNS": "<nOldMode>        old (if <nMode> is a numeric value) or\n                  current state of the switch",
    "DESCRIPTION": "In the following CT3 functions, strings are compared on a character\nbase:\n\nAtAdjust()    AtNum()    AfterAtNum()\nBeforAtNum()  AtRepl()   NumAt()\nStrDiff()\n\nWith the SetAtLike() function, one can determine when characters are\nconsidered to match within these functions. If CT_SETATLIKE_WILDCARD\nis set (e.g. \"?\"), then \"?\" matches every other character.\n\n<nMode> can be one of the following values that are defined\nin ct.ch:\n\nCT_SETATLIKE_EXACT\nCT_SETATLIKE_WILDCARD\n",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "This function is fully CT3 compatible, but allows to pass the\nsecond parameter by reference so that the current wildcard character\ncan be determined.",
    "PLATFORMS": "All",
    "FILES": "Header is ct.ch, library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/datetime.txt",
    "NAME": "BoM()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "Begin of Month",
    "SYNTAX": "BoM( [<dDate>] ) --> dDateBeginOfMonth",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "EoM(), BoQ(), EoQ(), BoY(), EoY()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/datetime.txt",
    "NAME": "EoM()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "End of Month",
    "SYNTAX": "EoM( [<dDate>] ) --> dDateEndOfMonth",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "BoM(), BoQ(), EoQ(), BoY(), EoY()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/datetime.txt",
    "NAME": "BoQ()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "Begin of Quarter",
    "SYNTAX": "BoQ( [<dDate>] ) --> dDateBeginOfQuarter",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "BoM(), EoM(), EoQ(), BoY(), EoY()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/datetime.txt",
    "NAME": "EoQ()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "End of Quarter",
    "SYNTAX": "EoQ( [<dDate>] ) --> dDateEndOfQuarter",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "BoM(), EoM(), BoQ(), BoY(), EoY()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/datetime.txt",
    "NAME": "BoY()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "Begin of Year",
    "SYNTAX": "BoY( [<dDate>] ) --> dDateBeginOfYear",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "BoM(), EoM(), BoQ(), EoQ(), EoY()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/datetime.txt",
    "NAME": "EoY()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "End of Year",
    "SYNTAX": "EoY( [<dDate>] ) --> dDateEndOfYear",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "BoM(), EoM(), BoQ(), EoQ(), BoY()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/dattime2.txt",
    "NAME": "CToDoW()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "convert name of day of the week to its ordinal number",
    "SYNTAX": "CToDoW( <cName> ) --> nOrdinal",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "NToCDoW()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/dattime2.txt",
    "NAME": "CToMonth()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "convert name of month to its ordinal number",
    "SYNTAX": "CToMonth( <cName> ) --> nOrdinal",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "NToCMonth()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/dattime2.txt",
    "NAME": "DMY()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "Returns the date as a string in `DD Month YY` format",
    "SYNTAX": "DMY( [<dDate>][, <lMode>] ) --> cDateString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "Returns the date as a string in `DD Month YY` format. If <lMode>\nis TRUE, a \".\" is inserted after the `DD`.\n\nTODO: add further documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "MDY()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/dattime2.txt",
    "NAME": "MDY()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "Returns the date as a string in `Month DD, YY` or `Month DD, YYYY`",
    "SYNTAX": "MDY( [<dDate>] ) --> cDateString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "Returns the date as a string in `Month DD, YY` or `Month DD, YYYY`.\nIf <dDate> is NULL, the system date is used.\n\nTODO: add further documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "DMY()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/dattime2.txt",
    "NAME": "AddMonth()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "add months to a date",
    "SYNTAX": "AddMonth( [<dDate>,] <nMonths> ) --> dShiftedDate",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/dattime2.txt",
    "NAME": "DoY()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "Determines the day of the year for a specific date",
    "SYNTAX": "DMY( [<dDate>] ) --> nDayOfYear",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "Determines the day of the year for a specific date\nif <dDate> is invalid, returns 0.\n\nTODO: add further documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/dattime2.txt",
    "NAME": "IsLeap()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "determines of year of date is a leap year",
    "SYNTAX": "IsLeap( [<dDate>] ) --> lIsLeap",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add further documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/dattime2.txt",
    "NAME": "Quarter()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "Returns a number equal to the quarter in which a date falls",
    "SYNTAX": "Quarter( [<dDate>] ) --> nQuarter",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "Returns a number equal to the quarter in which <dDate>\nfalls. If <dDate> is empty, the system date is employed.\n\nTODO: add further documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/dattime2.txt",
    "NAME": "LastDayOM()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "Returns the the number of days in the month.",
    "SYNTAX": "LastDayOM( [<dDate|nMonth>] ) --> nDaysInMonth",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "`dDate|nMonth` can be a date or a month number. If empty uses the\nsystem date.  If <nMonth> is a 2, LastDayOM() will not know if it\nis a leap year or not. If <dDate> is invalid, returns 0\n\nTODO: add further documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "EoM()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/dattime2.txt",
    "NAME": "NToCDoW()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "(num of day) --> day name",
    "SYNTAX": "NToCDoW( <nDay> ) --> cDay",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CToDoW()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/dattime2.txt",
    "NAME": "NToCMonth()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "(num of month ) --> Month Name",
    "SYNTAX": "NToCMonth( <nMonth> ) --> cMonth",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CToMonth()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/dattime2.txt",
    "NAME": "Week()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "Returns the calendar week a number",
    "SYNTAX": "Week( [<dDate>][, <lSWN>] ) --> nWeek",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "Returns the calendar week a number. If no date is specified,\nthe system date is used. An empty date via hb_SToD()\nreturns 0.\n\nIf <lSWN> is .T., Week() will calculate the \"simple week number\", defined by\n   - week #1 starts on January, 1st\n   - week #(n+1) starts seven days after start of week #n\n\nIf <lSWN> is .F. (default), the ISO 8601 week number, defined by\n   - weeks start on Mondays\n   - week #1 is the one that includes January, 4\nwill be calculated\n\nTODO: add further documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/dattime3.txt",
    "NAME": "WaitPeriod()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "Pauses a specified time in increments of 1/100 seconds",
    "SYNTAX": "WaitPeriod( [<nDelay>] ) --> lNotElapsed",
    "ARGUMENTS": "<nDelay>  Designates the waiting period at initialization in\n1/100ths of seconds.  Values from 1 to 8, 640, 000 (one day) are\npossible.",
    "RETURNS": "WaitPeriod() returns .T., if the time span designated at initialization\nhas not elapsed.",
    "DESCRIPTION": "This function sets a time span for a `DO WHILE` loop to run.\nThe function must initialize prior to the loop, since you must specify\nthe <nDelay> parameter in 1/100th seconds.  Subsequently, the function\ncan be implemented without a parameter for additional loop conditions.\nIt returns .T., as long as the designated time span has not yet run out.\n\nNote:\n\nThe function notes the status of the internal timer at\ninitialization.  From that point on, the initialization should always\nprecede the respective `DO WHILE`; otherwise, the time delay is\nincorrect.  The passing of midnight (the time resets to the 0 value)\nis taken into account.",
    "EXAMPLES": "// Run a loop for 5 seconds:\n\nWaitPeriod( 500 )             // Initialization, 5 seconds\nDO WHILE <cond1> .AND. <cond2> .AND. WaitPeriod()\n   // ...\nENDDO",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/dattime3.txt",
    "NAME": "TimeValid()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "Determines whether a specified time is valid",
    "SYNTAX": "TimeValid( <cTime> ) --> lValid",
    "ARGUMENTS": "<cTime>  Designates a character string that contains the time to\ntest.",
    "RETURNS": "TimeValid() returns .T. when <cTime> is a valid time; or .F. when\n<cTime> is an invalid time.",
    "DESCRIPTION": "With input that requires time manipulation, writing your own UDF to\ncheck time inputs was unavoidable up to now. TimeValid() permits\nComplete checking of a time designation.  You can use this function\neffectively with a VALID clause within a READ mask.\n\nNote\n\nNote the format for time designations.  There must always be\ntwo digits for hours, minutes, seconds, and hundredths; otherwise,\nthe time it is regarded as invalid.  Valid examples are `\"12\"`,\n`\"12:59\"`, `\"12:59:59\"`, and `\"12:59:59:99\"`.  By contrast, invalid\nexamples are `\"24\"`, `\"12:60\"`, or `\"12:1\"`, and/or `\"12:\"`. If you work\nwith time strings that are not completely filled and that you need to\ncheck with TimeValid(), then they must be RTrim()-med prior to the use of\nTimeValid() (see following Examples).",
    "EXAMPLES": "LOCAL cBegin, GetList := {}\n\n// Using the VALID clause with RTrim(), all valid times are\n// accepted, even if no seconds or minutes are specified:\n\ncBegin := Space( 11 )\n@ 5, 10 SAY \"Please input time for beginning work:\";\n   GET cBegin VALID TimeValid( RTrim( cBegin ) )\nREAD\n\n// Using a VALID clause without TRIM, hours and minutes must be\n// specified, so that TimeValid() can confirm a valid time:\n\ncBegin := Space( 5 )\n@ 5, 10 SAY \"Please input time for beginning work:\" ;\n   GET cBegin VALID TimeValid( cBegin )\nREAD",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "SetTime()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/dattime3.txt",
    "NAME": "SetTime()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "Sets the system clock",
    "SYNTAX": "SetTime( <cTime>, [<lMode>] ) --> lSet",
    "ARGUMENTS": "<cTime>  Designates a character string that contains the time that\nis to become the system time.\n\n<lMode>  Designates whether the time should also be set in the\nCMOS-RAM of an AT.  The default is do not write to CMOS-RAM. Note that in\nWindows platform this adjust is automatic, therefore this parameter is\nwithout effect.",
    "RETURNS": "The function returns .T. when the time is set successfully.",
    "DESCRIPTION": "When you use this function to convert the time into the system time from\nwithin your application, all files acquire this time with\neach write procedure.",
    "EXAMPLES": "LOCAL cNewTime\n\n// Set the system time in each case; but the hardware clock only\n// on an AT:\n\ncNewTime := \"10:20:00\"\nIF IsAt()\n   SetTime( cNewTime, .T. )\nELSE\n   SetTime( cNewTime )\nENDIF\n\n// Or, more compactly:\n\nSetTime( cNewTime, IsAt() )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "Windows, Linux",
    "FILES": "Library is hbct.",
    "SEEALSO": "SetDate(), TimeValid()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/dattime3.txt",
    "NAME": "SetDate()",
    "CATEGORY": "CT3 date and time functions",
    "ONELINER": "Sets the system date",
    "SYNTAX": "SetDate( <dDate>, [<lMode>] ) --> lSet",
    "ARGUMENTS": "<dDate>  Designates which date to use to set the system date.\n\n<lMode>  Designates whether the date should also be set in the CMOS-RAM\nof an AT. The default is do not write (.F.). Note that in Windows\nplatform this adjust is automatic, therefore this parameter is without\neffect.",
    "RETURNS": "SetDate() returns .T. when the date is successfully set.",
    "DESCRIPTION": "When you use this function to set the system date from within your\napplication, all files acquire this date with each write procedure.",
    "EXAMPLES": "LOCAL dNewDate\n\n// Set the system date in each case; but the hardware clock only\n// on an AT:\n\ndNewDate := 0d19910730\nIF IsAt()\n   SetDate( dNewDate, .T. )\nELSE\n   SetDate( dNewDate )\nENDIF\n\n// Or, more compactly:\n\nSetDate( dNewDate, IsAt() )",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "Windows, Linux",
    "FILES": "Library is hbct.",
    "SEEALSO": "SetTime()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/exponent.txt",
    "NAME": "Mantissa()",
    "CATEGORY": "CT3 number and bit manipulation functions",
    "ONELINER": "Evaluate the mantissa of a floating point number",
    "SYNTAX": "Mantissa( <nFloatingPointNumber> ) --> nMantissa",
    "ARGUMENTS": "<nFloatingPointNumber> Designate any Harbour number.",
    "RETURNS": "Mantissa() returns the mantissa of the <nFloatingPointNumber> number.",
    "DESCRIPTION": "This function supplements Exponent() to return the mantissa of the\n<nFloatingPointNumber> number.\n\nNote:  The mantissa value can be 0 or in the range of 1 to 2.\n\nThe following calculation reproduces the original value:\n```\n? Mantissa( <nFloatingPointNumber> ) * 2 ^ Exponent( <nFloatingPointNumber> )  // --> <nFloatingPointNumber>\n```\nTODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Exponent()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/exponent.txt",
    "NAME": "Exponent()",
    "CATEGORY": "CT3 number and bit manipulation functions",
    "ONELINER": "Evaluate the exponent of a floating point number",
    "SYNTAX": "Exponent( <nFloatingPointNumber> ) --> nExponent",
    "ARGUMENTS": "<nFloatingPointNumber> Designate any Harbour number.",
    "RETURNS": "Exponent() returns the exponent of the <nFloatingPointNumber> number\nin base 2.",
    "DESCRIPTION": "This function supplements Mantissa() to return the exponent of the\n<nFloatingPointNumber> number.\n\nValues > 1 or values < -1 return a positive number 0 to 1023.\n\nValues < 1 or values > -1 return a negative number -1 to -1023.\n\nThe `Exponent( 0 )`, return 0.\n\nThe following calculation reproduces the original value:\n```\n? 2 ^ Exponent( <nFloatingPointNumber> ) * Mantissa( <nFloatingPointNumber> )  // --> <nFloatingPointNumber>\n```\nTODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Mantissa()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/finan.txt",
    "NAME": "FV()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Future value of a capital",
    "SYNTAX": "FV( nDeposit, nInterest, nPeriods ) --> nFutureValue",
    "ARGUMENTS": "<nDeposit>     amount of money invested per period\n<nInterest>    rate of interest per period, 1 == 100%\n<nPeriods>     period count",
    "RETURNS": "<nFutureValue> Total value of the capital after <nPeriods> of\n               paying <nDeposit> and <nInterest> interest being\n               paid every period and added to the capital (resulting\n               in compound interest)",
    "DESCRIPTION": "FV() calculates the value of a capital after <nPeriods> periods.\nStarting with a value of 0, every period, <nDeposit>\n(Dollars, Euros, Yens, ...) and an interest of <nInterest> for the\ncurrent capital are added for the capital (<nInterest>=Percent/100).\nThus, one gets the non-linear effects of compound interests:\nvalue in period 0 = 0\nvalue in period 1 = ((value in period 0)*(1+<nInterest>/100)) + <nDeposit>\nvalue in period 2 = ((value in period 1)*(1+<nInterest>/100)) + <nDeposit>\n        etc....\nvalue in period <nPeriod> = ((value in period <nPeriod>-1)*(1+<nInterest>/100))< + <nDeposit>\n                          = <nDeposit> * sum from i=0 to <nPeriod>-1 over (1+<nInterest>/100)^i\n                          = <nDeposit> * ((1+<nInterest>/100)^n-1) / (<nInterest>/100)",
    "EXAMPLES": "// Payment of 1000 per year for 10 years at a interest rate\n// of 5 per cent per year\n\n? FV( 1000, 0.05, 10 )  // --> 12577.893",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "PV(), Payment(), Periods(), Rate()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/finan.txt",
    "NAME": "PV()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Present value of a loan",
    "SYNTAX": "PV( nPayment, nInterest, nPeriods ) --> nPresentValue",
    "ARGUMENTS": "<nPayment>     amount of money paid back per period\n<nInterest>    rate of interest per period, 1 == 100%\n<nPeriods>     period count",
    "RETURNS": "<nPresentValue> Present value of a loan when one is paying back\n                <nDeposit> per period at a rate of interest of\n                <nInterest> per period",
    "DESCRIPTION": "PV() calculates the present value of a loan that is paid back\nin <nPeriods> payments of <nPayment> (Dollars, Euros, Yens,...)\nwhile the rate of interest is <nInterest> per period:\ndebt in period 0 = <nPresentValue>\ndebt in period 1 = ((debt in period 0)-<nPayment>)*(1+<nInterest>/100)\ndebt in period 2 = ((debt in period 1)-<nPayment>)*(1+<nInterest>/100)\n     etc...\ndebt in period <nPeriod> = ((debt in period <nPeriod>-1)-<nPayment>)*(1+<nInterest>/100)\n                           -> has to be 0, so\n<nPresentValue> = <nPayment>*(1-(1+<nInterest>/100)^(-n))/(<nInterest>/100)",
    "EXAMPLES": "// You can afford to pay back 100 Dollars per month for 5 years\n// at a interest rate of 0.5% per month (6% per year), so instead\n// of 6000 Dollars (the amount you will pay back) the bank will pay\n// you\n\n? PV( 100, 0.005, 60 ) // --> 5172.56",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "FV(), Payment(), Periods(), Rate()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/finan.txt",
    "NAME": "Payment()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Payments for a loan",
    "SYNTAX": "Payment( nLoan, nInterest, nPeriods ) --> nPayment",
    "ARGUMENTS": "<nLoan>        amount of money you get from the bank\n<nInterest>    rate of interest per period, 1 == 100%\n<nPeriods>     period count",
    "RETURNS": "<nPayment>     Periodical payment one has to make to pay the\n               loan <nLoan> back",
    "DESCRIPTION": "Payment() calculates the payment one has to make periodically\nto pay back a loan <nLoan> within <nPeriods> periods and for a\nrate of interest <nInterest> per period.\ndebt in period 0 = <nLoan>\ndebt in period 1 = ((debt in period 0)-<nPayment>)*(1+<nInterest>/100)\ndebt in period 2 = ((debt in period 1)-<nPayment>)*(1+<nInterest>/100)\n     etc...\ndebt in period <nPeriod> = ((debt in period <nPeriod>-1)-<nPayment>)*(1+<nInterest>/100)\n                           -> has to be 0, so\n<nPayment> = <nLoan>*(<nInterest>/100)/(1-(1+<nInterest>/100)^(-n))",
    "EXAMPLES": "// You get a loan of 5172.56 at a interest rate of 0.5% per\n// month (6% per year).\n// For 5 years, you have to pay back every month\n\n? Payment( 5172.56, 0.005, 60 ) // --> 100.00",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "PV(), FV(), Periods(), Rate()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/finan.txt",
    "NAME": "Periods()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Number of periods for a loan",
    "SYNTAX": "Periods( nLoan, nPayment, nInterest ) --> nPeriods",
    "ARGUMENTS": "<nLoan>        amount of money you get from the bank\n<nPayment>     amount of money you pay back per period\n<nInterest>    rate of interest per period, 1 == 100%",
    "RETURNS": "<nPeriods>     number of periods you need to pay the loan back",
    "DESCRIPTION": "Periods() calculates the number of periods one needs to pay back\na loan of <nLoan> with periodical payments of <nPayment> and for a\nrate of interest <nInterest> per period.\ndebt in period 0 = <nLoan>\ndebt in period 1 = ((debt in period 0)-<nPayment>)*(1+<nInterest>/100)\ndebt in period 2 = ((debt in period 1)-<nPayment>)*(1+<nInterest>/100)\n     etc...\ndebt in period <nPeriod> = ((debt in period <nPeriod>-1)-<nPayment>)*(1+<nInterest>/100)\n                           -> has to be 0, so\n<nPeriods> = -Log(1-<nLoan>*(<nInterest>/100)/<nPayment>)/Log(1+<nInterest>/100))\n\nNote, however that in the case of `nPayment <= nLoan * ( nInterest / 100 )`,\none would need infinite time to pay the loan back. The functions does\nthen return -1.",
    "EXAMPLES": "// You get a loan of 5172.56 at a interest rate of 0.5% per\n// month (6% per year).\n// You can afford to pay 100 back every month, so you need\n\n? Periods( 5172.56, 100, 0.005 ) // --> 60.0\n\n// months to cancel the loan.",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "PV(), FV(), Payment(), Rate()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/finan.txt",
    "NAME": "Rate()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Estimate rate of interest for a loan",
    "SYNTAX": "Rate( nLoan, nPayment, nPeriods ) --> nRate",
    "ARGUMENTS": "<nLoan>          amount of money you get from the bank\n<nPayment>       amount of money you pay back per period\n<nPeriods>       number of periods you pay the loan back",
    "RETURNS": "<nInterest>    estimated rate of interest per period, 1 == 100%",
    "DESCRIPTION": "Rate() calculates the rate of interest per period for the given\nloan, payment per periods and number of periods. This is done with\nthe same equation used in the Payment() or Periods() function:\n\n<nPayment> = <nLoan>*(<nInterest>/100)/(1-(1+<nInterest>/100)^(-<nPeriods>))\n\nHowever, this equation cannot be solved for <nInterest> in a \"closed\"\nmanner, i.e. <nInterest> = ..., so that the result can only be estimated.",
    "EXAMPLES": "// You get a loan of 5172.56, pay 100 back every month for\n// 5 years (60 months). The effective interest rate per\n// period (=month) is\n\n? Rate( 5172.56, 100, 60 ) // --> 0.005",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "PV(), FV(), Payment(), Periods()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ftoc.txt",
    "NAME": "FToC()",
    "CATEGORY": "CT3 number and bit manipulation functions",
    "ONELINER": "",
    "SYNTAX": "FToC( <nFloatingPointNumber> ) --> cFloatingPointNumber\n",
    "ARGUMENTS": "<nFloatingPointNumber> Designate any Harbour number.\n",
    "RETURNS": "FToC() return a string with the size of DOUBLE.\nATTENTION: different implementations or platforms of Harbour, they\ncould produce different format in the string returned by FToC().\n",
    "DESCRIPTION": "Harbour internal numbers in Floating Point are stored in data type\nDOUBLE. FToC() returns these bits as an string. In this way,\nnumbers con be saved more compactly.\n\nTODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CToF(), XToC()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/ftoc.txt",
    "NAME": "CToF()",
    "CATEGORY": "CT3 number and bit manipulation functions",
    "ONELINER": "",
    "SYNTAX": "CToF( <cFloatingPointNumber> ) --> nFloatingPointNumber\n",
    "ARGUMENTS": "<cFloatingPointNumber> Designate a string that contains a Harbour\nnumber in floating point format.\nATTENTION: different implementations or platforms of Harbour, they\ncould produce different format in the string returned by FToC().\n",
    "RETURNS": "CToF() return the floating point number that corresponds to the\nstring passed.\n",
    "DESCRIPTION": "Character strings created with FToC() or XToC() are convert into\nHarbour floating point number\n\nTODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "FToC(), XToC()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/justify.txt",
    "NAME": "JustLeft()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Move characters from the beginning to the end of a string",
    "SYNTAX": "JustLeft( <[@]cString>, [<cChar>|<nChar>] ) --> cJustifiedString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "JustRight()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/justify.txt",
    "NAME": "JustRight()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Move characters from the end to the beginning of a string",
    "SYNTAX": "JustRight( <[@]cString>, [<cChar>|<nChar>] ) --> cJustifiedString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "JustLeft()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/keyset.txt",
    "NAME": "KSetIns()",
    "CATEGORY": "CT3 switch and state functions",
    "ONELINER": "",
    "SYNTAX": "KSetIns( [<lNewSwitch>] ) --> lOldSwitch",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "DOS",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/keyset.txt",
    "NAME": "KSetCaps()",
    "CATEGORY": "CT3 switch and state functions",
    "ONELINER": "",
    "SYNTAX": "KSetCaps( [<lNewSwitch>] ) --> lOldSwitch",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "DOS",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/keyset.txt",
    "NAME": "KSetNum()",
    "CATEGORY": "CT3 switch and state functions",
    "ONELINER": "",
    "SYNTAX": "KSetNum( [<lNewSwitch>] ) --> lOldSwitch",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "DOS",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/keyset.txt",
    "NAME": "KSetScroll()",
    "CATEGORY": "CT3 switch and state functions",
    "ONELINER": "",
    "SYNTAX": "KSetScroll( [<lNewSwitch>] ) --> lOldSwitch",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "DOS",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/misc1.txt",
    "NAME": "XToC()",
    "CATEGORY": "CT3 miscellaneous functions",
    "ONELINER": "",
    "SYNTAX": "XToC( <expValue> ) --> cValue\n",
    "ARGUMENTS": "<expValue> Designate an expression of some of the following data\ntype: NUMBER, CHARACTER, DATE, LOGICAL.\n",
    "RETURNS": "XToC() return a string with the representation of data type of\nexpValue.\n",
    "DESCRIPTION": "Each data type always returns a string with a particular fixed length:\n\n<table>\n Data Type    Result Length      Similar function\n\n Numeric      sizeof( DOUBLE )   FToC()\n Logical      1\n Date         8                  DToS()\n String       Unchanged\n</table>\n\nTODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CToF(), FToC()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/num1.txt",
    "NAME": "Celsius()",
    "CATEGORY": "CT3 numeric functions",
    "ONELINER": "Temperature conversion Fahrenheit to Celsius",
    "SYNTAX": "Celsius( nDegreeFahrenheit ) --> nDegreeCelsius",
    "ARGUMENTS": "<nDegreeFahrenheit>     temperature in degree Fahrenheit",
    "RETURNS": "<nDegreeCelsius>        temperate in degree Celsius",
    "DESCRIPTION": "Celsius() converts temperature values measured in the Fahrenheit scale\nto the Celsius scale.",
    "EXAMPLES": "// melting point of water in standard conditions\n? Celsius( 32.0 )      // --> 0.0\n// boiling point of water in standard conditions\n? Celsius( 212.0 )     // --> 100.0",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Fahrenheit()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/num1.txt",
    "NAME": "Fahrenheit()",
    "CATEGORY": "CT3 numeric functions",
    "ONELINER": "Temperature conversion Celsius to Fahrenheit",
    "SYNTAX": "Fahrenheit( nDegreeCelsius ) --> nDegreeFahrenheit",
    "ARGUMENTS": "<nDegreeCelsius>        temperate in degree Celsius",
    "RETURNS": "<nDegreeFahrenheit>     temperature in degree Fahrenheit",
    "DESCRIPTION": "Fahrenheit() converts temperature values measured in the Celsius scale\nto the Fahrenheit scale.",
    "EXAMPLES": "// melting point of water in standard conditions\n? Fahrenheit( 0.0 )    // --> 32.0\n// boiling point of water in standard conditions\n? Fahrenheit( 100.0 )  // --> 212.0",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Celsius()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/num1.txt",
    "NAME": "Infinity()",
    "CATEGORY": "CT3 numeric functions",
    "ONELINER": "Returns the largest floating point number available in the system",
    "SYNTAX": "Infinity( [<lPlatformIndependant>] ) --> nLargestNumber",
    "ARGUMENTS": "[<lPlatformIndependant>]   .T., if the function should return\n                           the maximum floating point value\n                           available (`DBL_MAX`)\n                           .F., function should try to return\n                           the same value as the original CT3 lib did\n                           Default: .F.",
    "RETURNS": "<nLargestNumber>     the largest floating point number available in the system",
    "DESCRIPTION": "Infinity() returns the largest floating point number available\nin the system. For platform independence, this is set to DBL_MAX.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "Infinity() must not necessarily return the same number as CT3's Infinity().",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/numat.txt",
    "NAME": "NumAt()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Number of occurrences of a sequence in a string",
    "SYNTAX": "NumAt( <cStringToMatch>, <cString>, [<nIgnore>] ) --> nCount",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CSetAtMupa(), SetAtLike()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/numconv.txt",
    "NAME": "NToC()",
    "CATEGORY": "CT3 number and bit manipulation functions",
    "ONELINER": "",
    "SYNTAX": "NToC( <xNumber>[, <nBase>][, <nLength>][, <cPadChar>] ) --> cNumber",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CToN()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/numconv.txt",
    "NAME": "CToN()",
    "CATEGORY": "CT3 number and bit manipulation functions",
    "ONELINER": "",
    "SYNTAX": "CToN( <xNumber>[, <nBase>][, <lMode>] ) --> nNumber",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "NToC()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/numconv.txt",
    "NAME": "BitToC()",
    "CATEGORY": "CT3 number and bit manipulation functions",
    "ONELINER": "",
    "SYNTAX": "BitToC( <nInteger>, <cBitPattern>[, <lMode>] ) --> cBitString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CToBit()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/numconv.txt",
    "NAME": "CToBit()",
    "CATEGORY": "CT3 number and bit manipulation functions",
    "ONELINER": "",
    "SYNTAX": "CToBit( <cBitString>, <cBitPattern> ) --> nWord",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "BitToC()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/pos1.txt",
    "NAME": "PosAlpha()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Left-most position of a letter in a string",
    "SYNTAX": "PosAlpha( <cString>, [<lMode>], [<nIgnore>] ) --> nPosition",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "PosLower(), PosUpper(), PosRange()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/pos1.txt",
    "NAME": "PosLower()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Left-most position of a lowercase letter in a string",
    "SYNTAX": "PosLower( <cString>, [<lMode>], [<nIgnore>] ) --> nPosition",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "PosAlpha(), PosUpper(), PosRange()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/pos1.txt",
    "NAME": "PosRange()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Left-most position of a character from a set in a string",
    "SYNTAX": "PosRange( <cChar1>, <cChar2>, <cString>, [<lMode>],\n          [<nIgnore>] ) --> nPosition",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "PosAlpha(), PosLower(), PosUpper()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/pos1.txt",
    "NAME": "PosUpper()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Left-most position of an uppercase letter in a string",
    "SYNTAX": "PosUpper( <cString>, [<lMode>], [<nIgnore>] ) --> nPosition",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "PosAlpha(), PosLower(), PosRange()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/pos2.txt",
    "NAME": "PosChar()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Replace character at a certain position within a string",
    "SYNTAX": "PosChar( <[@]cString>, <cCharacter|nCharacter>, [<nPosition>] ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "PosDel(), PosIns(), PosRepl(), CSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/pos2.txt",
    "NAME": "PosDel()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Delete characters at a certain position within a string",
    "SYNTAX": "PosDel( <cString>, [<nStartPosition>], <nLength> ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "PosChar(), PosIns(), PosRepl()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/pos2.txt",
    "NAME": "PosIns()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Insert characters at a certain position within a string",
    "SYNTAX": "PosIns( <cString>, <cInsert>, [<nPosition>] ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "PosChar(), PosDel(), PosRepl()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/pos2.txt",
    "NAME": "PosRepl()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Replace characters at a certain position within a string",
    "SYNTAX": "PosRepl( <[@]cString>, <cReplacement>, [<nStartPosition>] ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "PosChar(), PosDel(), PosIns(), CSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/posdiff.txt",
    "NAME": "PosDiff()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "The left-most position there two string differ",
    "SYNTAX": "PosDiff( <cString1>, <cString2>, [<nIgnore>] ) --> nPosition",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "PosEqual()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/posdiff.txt",
    "NAME": "PosEqual()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "The left-most position there two string begin to be equal",
    "SYNTAX": "PosEqual( <cString1>, <cString2>, [<nCompare>], [<nIgnore>] ) --> nPosition",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "PosDiff()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/print.txt",
    "NAME": "PrintStat()",
    "CATEGORY": "CT3 printer functions",
    "ONELINER": "",
    "SYNTAX": "PrintStat( [<nPrinter>] ) --> nState",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "DOS",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/print.txt",
    "NAME": "PrintReady()",
    "CATEGORY": "CT3 printer functions",
    "ONELINER": "",
    "SYNTAX": "PrintReady( [<nPrinter>] ) --> lPrinterReady",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "DOS",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/range.txt",
    "NAME": "RangeRem()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Remove characters within a certain ASCII range from a string",
    "SYNTAX": "RangeRem( <cChar1|nChar1>, <cChar2|nChar2>, <cString> ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "? RangeRem( \"0\", \"9\", \"year2002.dbf\" )  // \"year.dbf\", remove all digits\n? RangeRem( \"9\", \"0\", \"year2002.dbf\" )  // \"22\", testing removal from \"9\" to hb_BChar( 255 )\n                                        // and from hb_BChar( 0 ) to \"0\"\n? RangeRem( \"0\", \"9\", \"yearcurr.dbf\" )  // \"yearcurr.dbf\", test leaving string untouched",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "RangeRepl()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/range.txt",
    "NAME": "RANGEREPL",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Replace characters within a certain ASCII range from a string",
    "SYNTAX": "RangeRepl( <cChar1|nChar1>, <cChar2|nChar2>,\n           <[@]cString>, <cReplacementChar|nReplacementChar> ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "? RangeRepl( \"0\", \"9\", \"year2002.dbf\", \"?\" )  // \"year????.dbf\", replace all digits\n? RangeRepl( \"9\", \"0\", \"year2002.dbf\", \"?\" )  // \"????2??2????\", testing replacement from \"9\" to hb_BChar( 255 )\n                                              // and from hb_BChar( 0 ) to \"0\"\n? RangeRepl( \"0\", \"9\", \"yearcurr.dbf\", \"?\" )  // \"yearcurr.dbf\", test leaving string untouched",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "RangeRem()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/relation.txt",
    "NAME": "CharRelA()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Character relation of two strings",
    "SYNTAX": "CharRelA( <cStringToMatch1>, <cString1>,\n          <cStringToMatch2>, <cString2> ) --> nPosition",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharRelRep()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/relation.txt",
    "NAME": "CharRelRep()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Relation dependent character replacement",
    "SYNTAX": "CharRelRep( <cStringToMatch1>, <cString1>,\n            <cStringToMatch2>, <[@]cString2>,\n            <cReplacement> ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharRelA(), CSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/remove.txt",
    "NAME": "RemAll()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Remove certain characters at the left and right of a string",
    "SYNTAX": "RemAll( <cString>, [<cSearch|nSearch>] ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "RemLeft(), RemRight()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/remove.txt",
    "NAME": "RemLeft()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Remove certain characters at the left of a string",
    "SYNTAX": "RemLeft( <cString>, [<cSearch|nSearch>] ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "RemAll(), RemRight()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/remove.txt",
    "NAME": "RemRight()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Remove certain characters at the right of a string",
    "SYNTAX": "RemRight( <cString>, [<cSearch|nSearch>] ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "RemAll(), RemLeft()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/replace.txt",
    "NAME": "ReplAll()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Replace certain characters at the left and right of a string",
    "SYNTAX": "ReplAll( <cString>, <cReplace|nReplace>, [<cSearch|nSearch>] ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "ReplLeft(), ReplRight()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/replace.txt",
    "NAME": "ReplLeft()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Replace certain characters at the left of a string",
    "SYNTAX": "ReplLeft( <cString>, <cReplace|nReplace>, [<cSearch|nSearch>] ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "ReplAll(), ReplRight()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/replace.txt",
    "NAME": "ReplRight()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Replace certain characters at the right of a string",
    "SYNTAX": "ReplRight( <cString>, <cReplace|nReplace>, [<cSearch|nSearch>] ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "ReplAll(), ReplLeft()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/screen1.txt",
    "NAME": "ScreenAttr()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "",
    "SYNTAX": "ScreenAttr( [<nRow>], [<nColumn>] ) --> nAttr",
    "ARGUMENTS": "<nRow>     Designates the line from which to determine the attribute.\n           The default is the cursor line.\n\n<nColumn>  Designates the column from which to determine the\n           attribute.  The default is the cursor column.\n",
    "RETURNS": "ScreenAttr() returns the attribute at the designated position.\n",
    "DESCRIPTION": "ScreenAttr() returns the current screen attribute at <nRow> and\n<nColumn>.  You can query targeted attributes this way and save them\nto use later, or process them later with InvertAttr().\n\nTODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/screen1.txt",
    "NAME": "ScreenMix()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "",
    "SYNTAX": "ScreenMix( <cCharString>, <cAttributeString>, [<nRow>], [<nCol>] ) --> cEmptyString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/screen1.txt",
    "NAME": "SayScreen()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "",
    "SYNTAX": "SayScreen( <cString>, [<nRow>], [<nCol>] ) --> cEmptyString",
    "ARGUMENTS": "<cString> - the string to output. Although undocumented, can be NIL.\n<nRow> - row number, defaults to cursor row.\n<nCol> - column number, defaults to cursor column.",
    "RETURNS": "Returns an empty string.",
    "DESCRIPTION": "Outputs a string at specified coordinates without changing character\nattributes.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "ScreenMix()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/screen1.txt",
    "NAME": "InvertWin()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "",
    "SYNTAX": "",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/screen1.txt",
    "NAME": "UnTextWin()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "",
    "SYNTAX": "UnTextWin( <nTopLine>, <nLeftColumn>, <nBottomLine>, <nRightColumn>,\n           <cReplacementCharacter|nReplacementCharacter>,\n           [<cInitialCharacter|nInitialCharacter>],\n           [<cEndCharacter|nEndCharacter>] ) --> cNull",
    "ARGUMENTS": "<nTopLine>  Designates the line for the upper-left corner of the\n  area.\n<nLeftColumn>  Designates the column for the upper-left corner of\n  the area.\n<nBottomLine>  Designates the line for the bottom-right corner of\n  the area.\n<nRightColumn>  Designates the line for the bottom-right column of\n  the area.\n<cReplacementCharacter|nReplacementCharacter>  Replaces each\n  character within the window, with the exception of those within the\n  range of <cInitialCharacter|nInitialCharacter> and\n<cEndCharacter|nEndCharacter>.\n<cInitialCharacter|nInitialCharacter>  Designates the beginning of\n  the bracketed area.  The character can be number in the range of 0 to\n  255, or the character string type.  The default value is 176.\n<cEndCharacter|nEndCharacter>  Designates the end of the bracketed\n  area.  The character can be number in the range of 0 to 255 or the\n  character string type.  The default value is 223.",
    "RETURNS": "Returns a null string.",
    "DESCRIPTION": "Replaces an area of characters from a region of the screen\nTODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/screen1.txt",
    "NAME": "CharWin()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "",
    "SYNTAX": "CharWin( <nTop>, <nLeft>, <nBottom>, <nRight>, [<cNewChar|nNewChar>],\n         [<cOldChar|nOldChar>] ) --> cEmptyString",
    "ARGUMENTS": "<nTop> - top row number, default 0\n<nLeft> - left column number, default 0\n<nBottom> - top row number, default MaxRow()\n<nRight> - right column number, default MaxCol()\n<cNewChar|nNewChar> - new character for the screen area,\n      as a numeric value in the range of 0 to\n      255 or as a character string, default value is the CLEARB.\n<cOldChar|nOldChar> - character to exchange. Specify the parameter\n      as a numeric in the range of 0 to 255\n      or as a character string.  The default is to exchange all characters.",
    "RETURNS": "Returns an empty string.",
    "DESCRIPTION": "Exchanges particular characters in a screen area.\nTODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/screen1.txt",
    "NAME": "ColorWin()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "",
    "SYNTAX": "ColorWin( [<nTopLine>], [<nLeftCol>], [<nBottomLine>], [<nRightCol>],\n          [<cNewAttr|nNewAttr>], [<cOldAttr|nOldAttr>] ) --> cNull",
    "ARGUMENTS": "<nTopLine>  Designates the topmost line to begin processing.  The\n  default is the cursor line.\n<nLeftCol>  Designates the leftmost column to begin processing.  The\n  default is the cursor column.\n<nBottomLine>  Designates the bottommost line that is processed.\n  The default is the last screen line or window line.\n<nRightCol>  Designates the rightmost column to clear.  The default\n  is the right screen border or window border.\n<cNewAttr|nNewAttr>  Designates the new attribute to replace the old\n  one.  The default is the standard attribute CLEARA.\n<cOldAttr|nOldAttr>  Designates the old character to exchange.  The\n  default is \"exchange all attributes\".",
    "RETURNS": "Returns an empty string.",
    "DESCRIPTION": "Exchanges particular attributes in a screen area\nTODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/screen1.txt",
    "NAME": "ScreenText()",
    "CATEGORY": "CT3 video functions (Harbour extension)",
    "ONELINER": "",
    "SYNTAX": "ScreenText( <nTop>, <nLeft>, <nBottom>, <nRight> )",
    "ARGUMENTS": "<nTop> - top row number, default 0\n<nLeft> - left column number, default 0\n<nBottom> - top row number, default MaxRow()\n<nRight> - right column number, default MaxCol()",
    "RETURNS": "Returns string with characters taken from given screen region.",
    "DESCRIPTION": "Returns string with characters taken from given screen region.\nTODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/screen1.txt",
    "NAME": "ColorRepl()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "",
    "SYNTAX": "ColorRepl( [<cNewAttr|nNewAttr>], [<cOldAttr|nOldAttr>] ) --> cNull",
    "ARGUMENTS": "<cNewAttr|nNewAttr>  Designates the new attribute.  The default is\n  CLEARA.\n<cOldAttr|InOldAttr>  Designates the old attribute to exchange.  The\n  default is all existing attributes.",
    "RETURNS": "Returns an empty string.",
    "DESCRIPTION": "Exchanges particular screen attributes\nTODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/strdiff.txt",
    "NAME": "StrDiff()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Evaluate the \"Edit (Levensthein) Distance\" of two strings",
    "SYNTAX": "StrDiff( <cString1>, <cString2>, [<nReplacementPenalty>], [<nDeletionPenalty>],\n         [<nInsertionPenalty>] ) --> nDistance",
    "ARGUMENTS": "<cString1>              string at the \"starting point\" of the transformation process, default is \"\"\n<cString2>              string at the \"end point\" of the transformation process, default is \"\"\n<nReplacementPenalty>   penalty points for a replacement of one character, default is 3\n<nDeletionPenalty>      penalty points for a deletion of one character, default is 6\n<nInsertionPenalty>     penalty points for an insertion of one character, default is 1",
    "RETURNS": "<nDistance>             penalty point sum of all operations needed to transform <cString1> to <cString2>",
    "DESCRIPTION": "The StrDiff() functions calculates the so called \"Edit\" or \"Levensthein\" distance of two strings.\nThis distance is a measure for the number of single character replace/insert/delete operations (so called\n\"point mutations\") required to transform <cString1> into <cString2> and its value will be the smallest sum of\nthe penalty points of the required operations.\n\nBe aware that this function is both quite time - `O( hb_BLen( cString1 ) * hb_BLen( cString2 ) )` -\nand memory consuming - `O( ( hb_BLen( cString1 ) + 1 ) * ( hb_BLen( cString2 ) + 1 ) * sizeof( int ) )` -\nso keep the strings as short as possible.\nE.g., on common 32-bit systems `( sizeof( int ) == 4 )`, calling StrDiff() with two strings of 1024 bytes\nin length will consume 4 MiB of memory. To not impose unneeded restrictions, the function will only check if\n`( hb_BLen( cString1 ) + 1 ) * ( hb_BLen( cString2 ) + 1 ) * sizeof( int ) <= UINT_MAX`, although allocating\nUINT_MAX bytes will not work on most systems. If this simple check fails, -1 is returned.\n\nAlso, be aware that there can be an overflow when the penalty points are summed up: Assuming that the\nnumber of transformation operations is in the order of `Max( hb_BLen( cString1 ), hb_BLen( cString2 ) )`,\nthe penalty point sum, that is internally stored in an \"int\" variable, is in the order of\n`( Max( hb_BLen( cString1 ), hb_BLen( cString2 ) ) * Max( nReplacementPenalty, nDeletionPenalty, nInsertionPentaly )`.\nThe StrDiff() does not do an overflow check due to time performance reasons. Future versions of StrDiff()\ncould use a type different to \"int\" to store the penalty point sum to save memory or to avoid overflows.\n\nThe function is aware of the settings done by SetAtLike(), that means that the wildcard character\nis considered equal to ALL characters.\n",
    "EXAMPLES": "? StrDiff( \"ABC\", \"ADC\" )   // 3, one character replaced\n? StrDiff( \"ABC\", \"AEC\" )   // 3, ditto\n? StrDiff( \"CBA\", \"ABC\" )   // 6, two characters replaced\n? StrDiff( \"ABC\", \"AXBC\" )  // 1, one character inserted\n? StrDiff( \"AXBC\", \"ABC\" )  // 6, one character removed\n? StrDiff( \"AXBC\", \"ADC\" )  // 9, one character removed and one replaced",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "SetAtLike()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/strswap.txt",
    "NAME": "StrSwap()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Swap the contents of two strings",
    "SYNTAX": "StrSwap( <[@]cString1>, <[@]cString2> ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/tab.txt",
    "NAME": "TabExpand()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Replace tabulator control characters with fill characters",
    "SYNTAX": "TabExpand( <cString>, [<nTabWidth>], [<cFillChar|nFillChar>],\n           [<cNewLineCharacters>], [<cTabChar|nTabChar>],\n           [<lIgnore141>] ) --> cExpandedString",
    "ARGUMENTS": "<cString>\n<nTabWidth>\n<cFillChar|nFillChar>\n<cNewLineCharacters>      string indicating new line,\n                          default is the string returned by\n                          hb_eol()\n<cTabChar|nTabChar>       character indicating a tab stop,\n                          default is `Chr( 9 )`\n<lIgnore141>              .T., if the soft-CR used by MemoEdit()\n                          should be ignored as a newline indicator,\n                          default is .F.\n                          (functions uses `hb_BChar( 141 )`)",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "TabExpand() is compatible with CT3's TabExpand(), but there are\nthree new parameters for a better fine control of the function's\nbehaviour.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "TabPack()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/tab.txt",
    "NAME": "TabPack()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Pack fill characters to appropriate tab characters",
    "SYNTAX": "TabPack( <cString>, [<nTabWidth>], [<cFillChar|nFillChar>],\n         [<cNewLineCharacters>], [<cTabChar|nTabChar>],\n         [<lIgnore141>] ) --> cPackedString",
    "ARGUMENTS": "<cString>\n<nTabWidth>\n<cFillChar|nFillChar>\n<cNewLineCharacters>      string indicating new line,\n                          default is the string returned by\n                          hb_eol()\n<cTabChar|nTabChar>       character indicating a tab stop,\n                          default is `Chr( 9 )`\n<lIgnore141>              .T., if the soft-CR used by MemoEdit()\n                          should be ignored as a newline indicator,\n                          default is .F.\n                          (functions uses `hb_BChar( 141 )`)",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "TabPack() is compatible with CT3's TabPack(), but there are\nthree new parameters for a better fine control of the function's\nbehaviour.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "TabExpand()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/token1.txt",
    "NAME": "AtToken()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Position of a token in a string",
    "SYNTAX": "AtToken( <cString>, [<cTokenizer>],\n         [<nTokenCount>], [<nSkipWidth>] ) --> nPosition",
    "ARGUMENTS": "<cString>          is the processed string\n[<cTokenizer>]     is a list of characters separating the tokens\n                   in <cString>\n                   Default:\n                   `Chr( 0 ) + Chr( 9 ) + Chr( 10 ) + Chr( 13 ) + Chr( 26 ) + hb_BChar( 138 ) + hb_BChar( 141 ) + Chr( 32 ) + \",.;:!\\?/\\\\<>()#&%+-*\"`\n[<nTokenCount>]    specifies the count of the token whose\n                   position should be calculated\n                   Default: last token\n[<nSkipWidth>]     specifies the maximum number of successive\n                   tokenizing characters that are combined as\n                   _one_ token stop, e.g. specifying 1 can\n                   yield to empty tokens\n                   Default: 0, any number of successive tokenizing\n                   characters are combined as _one_ token stop",
    "RETURNS": "<nPosition>        The start position of the specified token or\n                   0 if such a token does not exist in <cString>.",
    "DESCRIPTION": "The AtToken() function calculates the start position of the\n<nTokenCount>th token in <cString>. By setting the new <nSkipWidth>\nparameter to a value different than 0, you can specify how many tokenizing\ncharacters are combined at most to one token stop. Be aware that\nthis can result to empty tokens there the start position is not\ndefined clearly. Then, AtToken() returns the position there the\ntoken _would_ start if its length is larger than 0. To check for\nempty tokens, simply look if the character at the returned position\nis within the tokenizer list.",
    "EXAMPLES": "AtToken( \"Hello, World!\" )  // --> 8 (empty strings after tokenizer are not a token !)",
    "STATUS": "R",
    "COMPLIANCE": "AtToken() is compatible with CT3's AtToken(), but has an additional\n4th parameter to let you specify a skip width equal to that in the\nToken() function.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Token(), NumToken(), TokenLower(), TokenUpper(), TokenSep()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/token1.txt",
    "NAME": "Token()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Tokens of a string",
    "SYNTAX": "Token( <cString>, [<cTokenizer>],\n       [<nTokenCount], [<nSkipWidth>],\n       [<@cPreTokenSep>], [<@cPostTokenSep>] ) --> cToken",
    "ARGUMENTS": "<cString>          is the processed string\n[<cTokenizer>]     is a list of characters separating the tokens\n                   in <cString>\n                   Default:\n                   `Chr( 0 ) + Chr( 9 ) + Chr( 10 ) + Chr( 13 ) + Chr( 26 ) + hb_BChar( 138 ) + hb_BChar( 141 ) + Chr( 32 ) + \",.;:!\\?/\\\\<>()#&%+-*\"`\n[<nTokenCount>]    specifies the count of the token that\n                   should be extracted\n                   Default: last token\n[<nSkipWidth>]     specifies the maximum number of successive\n                   tokenizing characters that are combined as\n                   _one_ token stop, e.g. specifying 1 can\n                   yield to empty token\n                   Default: 0, any number of successive tokenizing\n                   characters are combined as _one_ token stop\n[<@cPreTokenSep>]  If given by reference, the tokenizer before\n                   the actual token will be stored\n[<@cPostTokenSep>] If given by reference, the tokenizer after\n                   the actual token will be stored",
    "RETURNS": "<cToken>           the token specified by the parameters given above",
    "DESCRIPTION": "The Token() function extracts the <nTokenCount>th token from the\nstring <cString>. In the course of this, the tokens in the\nstring are separated by the character(s) specified in <cTokenizer>.\nThe function may also extract empty tokens, if you specify a skip\nwidth other than zero.\nBe aware of the new 5th and 6th parameter there the Token() function\nstores the tokenizing character before and after the extracted token.\nTherefore, additional calls to the TokenSep() function are not\nnecessary.",
    "EXAMPLES": "? Token( \"Hello, World!\" )             // \"World\"\n? Token( \"Hello, World!\",, 2, 1 )      // \"\"\n? Token( \"Hello, World!\", \",\", 2, 1 )  // \" World!\"\n? Token( \"Hello, World!\", \" \", 2, 1 )  // \"World!\"",
    "STATUS": "R",
    "COMPLIANCE": "Token() is compatible with CT3's Token(), but two additional\nparameters have been added there the Token() function can store\nthe tokenizers before and after the current token.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "NumToken(), AtToken(), TokenLower(), TokenUpper(), TokenSep()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/token1.txt",
    "NAME": "NumToken()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Retrieves the number of tokens in a string",
    "SYNTAX": "NumToken( <cString>, [<cTokenizer>], [<nSkipWidth>] ) --> nTokenCount",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Token(), AtToken(), TokenLower(), TokenUpper(), TokenSep()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/token1.txt",
    "NAME": "TokenLower()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Change the first letter of tokens to lower case",
    "SYNTAX": "TokenLower( <[@]cString>, [<cTokenizer>], [<nTokenCount>],\n            [<nSkipWidth>] ) --> cString",
    "ARGUMENTS": "<[@]cString>      is the processed string\n[<cTokenizer>]    is a list of characters separating the tokens\n                  in <cString>\n                  Default:\n                  `Chr( 0 ) + Chr( 9 ) + Chr( 10 ) + Chr( 13 ) + Chr( 26 ) + hb_BChar( 138 ) + hb_BChar( 141 ) + Chr( 32 ) + \",.;:!\\?/\\\\<>()#&%+-*\"`\n[<nTokenCount>]   specifies the number of tokens that\n                  should be processed\n                  Default: all tokens\n[<nSkipWidth>]    specifies the maximum number of successive\n                  tokenizing characters that are combined as\n                  _one_ token stop, e.g. specifying 1 can\n                  yield to empty token\n                  Default: 0, any number of successive tokenizing\n                  characters are combined as _one_ token stop",
    "RETURNS": "<cString>         the string with the lowercased tokens",
    "DESCRIPTION": "The TokenLower() function changes the first letter of tokens in <cString>\nto lower case. To do this, it uses the same tokenizing mechanism\nas the Token() function. If TokenLower() extracts a token that starts\nwith a letter, this letter will be changed to lower case.\nYou can omit the return value of this function by setting the CSetRef()\nswitch to .T., but you must then pass <cString> by reference to get\nthe result.",
    "EXAMPLES": "? TokenLower( \"Hello, World, here I am!\" )          // \"hello, world, here i am!\"\n? TokenLower( \"Hello, World, here I am!\",, 3 )      // \"hello, world, here I am!\"\n? TokenLower( \"Hello, World, here I am!\", \",\", 3 )  // \"hello, World, here I am!\"\n? TokenLower( \"Hello, World, here I am!\", \" W\" )    // \"hello, World, here i am!\"",
    "STATUS": "R",
    "COMPLIANCE": "TokenLower() is compatible with CT3's TokenLower(),\nbut a new 4th parameter, <nSkipWidth> has been added for\nsynchronization with the the other token functions.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Token(), NumToken(), AtToken(), TokenUpper(), TokenSep(), CSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/token1.txt",
    "NAME": "TokenUpper()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Change the first letter of tokens to upper case",
    "SYNTAX": "TokenUpper( <[@]cString>, [<cTokenizer>], [<nTokenCount>],\n            [<nSkipWidth>] ) --> cString",
    "ARGUMENTS": "<[@]cString>      is the processed string\n[<cTokenizer>]    is a list of characters separating the tokens\n                  in <cString>\n                  Default:\n                  `Chr( 0 ) + Chr( 9 ) + Chr( 10 ) + Chr( 13 ) + Chr( 26 ) + hb_BChar( 138 ) + hb_BChar( 141 ) + Chr( 32 ) + \",.;:!\\?/\\\\<>()#&%+-*\"`\n[<nTokenCount>]   specifies the number of tokens that\n                  should be processed\n                  Default: all tokens\n[<nSkipWidth>]    specifies the maximum number of successive\n                  tokenizing characters that are combined as\n                  _one_ token stop, e.g. specifying 1 can\n                  yield to empty token\n                  Default: 0, any number of successive tokenizing\n                  characters are combined as _one_ token stop",
    "RETURNS": "<cString>         the string with the uppercased tokens",
    "DESCRIPTION": "The TokenUpper() function changes the first letter of tokens in <cString>\nto upper case. To do this, it uses the same tokenizing mechanism\nas the Token() function. If TokenUpper() extracts a token that starts\nwith a letter, this letter will be changed to upper case.\nYou can omit the return value of this function by setting the CSetRef()\nswitch to .T., but you must then pass <cString> by reference to get\nthe result.",
    "EXAMPLES": "? TokenUpper( \"Hello, world, here I am!\" )          // \"Hello, World, Here I Am!\"\n? TokenUpper( \"Hello, world, here I am!\",, 3 )      // \"Hello, World, Here I am!\"\n? TokenUpper( \"Hello, world, here I am!\", \",\", 3 )  // \"Hello, world, here I am!\"\n? TokenUpper( \"Hello, world, here I am!\", \" w\" )    // \"Hello, wOrld, Here I Am!\"",
    "STATUS": "R",
    "COMPLIANCE": "TokenUpper() is compatible with CT3's TokenUpper(),\nbut a new 4th parameter, <nSkipWidth> has been added for\nsynchronization with the the other token functions.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Token(), NumToken(), AtToken(), TokenLower(), TokenSep(), CSetRef()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/token1.txt",
    "NAME": "TokenSep()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Retrieves the token separators of the last Token() call",
    "SYNTAX": "TokenSep( [<lMode>] ) --> cSeparator",
    "ARGUMENTS": "[<lMode>]   if set to .T., the token separator BEHIND the token\n            retrieved from the Token() call will be returned.\n            Default: .F., returns the separator BEFORE the token",
    "RETURNS": "Depending on the setting of <lMode>, the separating character of the\nthe token retrieved from the last Token() call will be returned.\nThese separating characters can now also be retrieved with the Token()\nfunction.",
    "DESCRIPTION": "When one does extract tokens from a string with the Token() function,\none might be interested in the separator characters that have been\nused to extract a specific token. To get this information you can\neither use the TokenSep() function after each Token() call, or\nuse the new 5th and 6th parameter of the Token() function.",
    "EXAMPLES": "see Token() function",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Token(), NumToken(), AtToken(), TokenLower(), TokenUpper()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/token2.txt",
    "NAME": "TokenInit()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Initializes a token environment",
    "SYNTAX": "TokenInit( <[@]cString>], [<cTokenizer>], [<nSkipWidth>],\n           [<@cTokenEnvironment>] ) --> lState",
    "ARGUMENTS": "<[@]cString>          is the processed string\n<cTokenizer>          is a list of characters separating the tokens\n                      in <cString>\n                      Default:\n                      `Chr( 0 ) + Chr( 9 ) + Chr( 10 ) + Chr( 13 ) + Chr( 26 ) + hb_BChar( 138 ) + hb_BChar( 141 ) + Chr( 32 ) + \",.;:!\\?/\\\\<>()#&%+-*\"`\n<nSkipWidth>          specifies the maximum number of successive\n                      tokenizing characters that are combined as\n                      _one_ token stop, e.g. specifying 1 can\n                      yield to empty token\n                      Default: 0, any number of successive tokenizing\n                      characters are combined as _one_ token stop\n<@cTokenEnvironment>  is a token environment stored in a binary\n                      encoded string",
    "RETURNS": "<lState>              success of the initialization",
    "DESCRIPTION": "The TokenInit() function initializes a token environment. A token\nenvironment is the information about how a string is to be tokenized.\nThis information is created in the process of tokenization of the\nstring <cString> - equal to the one used in the Token() function\nwith the help of the <cTokenizer> and <nSkipWidth> parameters.\n\nThis token environment can be very useful when large strings have\nto be tokenized since the tokenization has to take place only once\nwhereas the Token() function must always start the tokenizing process\nfrom scratch.\n\nUnlike CT3, this function provides two mechanisms of storing the\nresulting token environment. If a variable is passed by reference\nas 4th parameter, the token environment is stored in this variable,\notherwise the global token environment is used. Do not modify the\ntoken environment string directly !\n\nAdditionally, a counter is stored in the token environment, so that\nthe tokens can successively be obtained. This counter is first set to 1.\nWhen the TokenInit() function is called without a string a tokenize,\nthe counter of either the global environment or the environment given\nby reference in the 4th parameter is rewind to 1.\n\nAdditionally, unlike CT3, TokenInit() does not need the string\n<cString> to be passed by reference, since one must provide the\nstring in calls to TokenNext() again.",
    "EXAMPLES": "TokenInit( cString )             // tokenize the string <cString> with default\n                                 // rules and store the token environment globally\n                                 // and eventually delete an old global TE\nTokenInit( @cString )            // no difference in result, but eventually faster,\n                                 // since the string must not be copied\nTokenInit()                      // rewind counter of global TE to 1\nTokenInit( \"1,2,3\", \",\" , 1 )    // tokenize constant string, store in global TE\nTokenInit( cString, , 1, @cTE1 ) // tokenize cString and store TE in\n                                 // cTE1 only without overriding global TE\nTokenInit( cString, , 1, cTE1 )  // tokenize cString and store TE in\n                                 // GLOBAL TE since 4th parameter is\n                                 // not given by reference !!!\nTokenInit( ,,, @cTE1 )           // set counter in TE stored in cTE1 to 1",
    "STATUS": "R",
    "COMPLIANCE": "TokenInit() is compatible with CT3's TokenInit(),\nbut there is an additional parameter featuring local token environments.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Token(), TokenExit(), TokenNext(), TokenNum(), TokenAt(), SaveToken(), RestToken(), TokenEnd()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/token2.txt",
    "NAME": "TokenNext()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Successively obtains tokens from a string",
    "SYNTAX": "TokenNext( <[@]cString>, [<nToken>],\n           [<@cTokenEnvironment>] ) --> cToken",
    "ARGUMENTS": "<[@]cString>             the processed string\n<nToken>                 a token number\n<@cTokenEnvironment>     a token environment",
    "RETURNS": "<cToken>                 a token from <cString>",
    "DESCRIPTION": "With TokenNext(), the tokens determined with the TokenInit() functions\ncan be retrieved. To do this, TokenNext() uses the information stored\nin either the global token environment or the local one supplied by\n<cTokenEnvironment>. Note that, is supplied, this 3rd parameter has\nalways to be passed by reference.\n\nIf the 2nd parameter, <nToken> is given, TokenNext() simply returns\nthe <nToken>th token without manipulating the TE counter. Otherwise\nthe token pointed to by the TE counter is returned and the counter\nis incremented by one. Like this, a simple loop with TokenEnd() can\nbe used to retrieve all tokens of a string successively.\n\nNote that <cString> does not have to be the same used in TokenInit(),\nso that one can do a \"correlational tokenization\", i.e. tokenize a string\nas if it was another! E.G. using TokenInit() with the string\n\"AA, BBB\" but calling TokenNext() with \"CCCEE\" would\ngive first \"CC\" and then \"EE\" (because \"CCCEE\" is not long enough).",
    "EXAMPLES": "LOCAL cString := \"The quick brown fox jumps over the lazy dog\"\n// default behaviour\nTokenInit( cString )  // initialize a TE\nDO WHILE ! TokenEnd()\n   ? TokenNext( cString )  // get all tokens successively\nENDDO\n? TokenNext( cString, 3 )  // get the 3rd token, counter will remain the same\nTokenExit()                // free the memory used for the global TE",
    "STATUS": "R",
    "COMPLIANCE": "TokenNext() is compatible with CT3's TokenNext(),\nbut there are two additional parameters featuring local token\nenvironments and optional access to tokens.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "TokenInit(), TokenExit(), TokenNum(), TokenAt(), SaveToken(), RestToken(), TokenEnd()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/token2.txt",
    "NAME": "TokenNum()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Get the total number of tokens in a token environment",
    "SYNTAX": "TokenNum( [<@cTokenEnvironment>] ) --> nNumberofTokens",
    "ARGUMENTS": "<@cTokenEnvironment>     a token environment",
    "RETURNS": "<nNumberofTokens>        number of tokens in the token environment",
    "DESCRIPTION": "The TokenNum() function can be used to retrieve the total number\nof tokens in a token environment.\nIf the parameter <@cTokenEnvironment> is supplied (must be by\nreference), the information from this token environment is used,\notherwise the global TE is used.",
    "EXAMPLES": "TokenInit( \"a.b.c.d\", \".\", 1 )  // initialize global TE\n? TokenNum()  // --> 4",
    "STATUS": "R",
    "COMPLIANCE": "TokenNum() is a new function in Harbour's CT3 library.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "TokenInit(), TokenExit(), TokenNext(), TokenAt(), SaveToken(), RestToken(), TokenEnd()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/token2.txt",
    "NAME": "TokenEnd()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Check whether additional tokens are available with TokenNext()",
    "SYNTAX": "TokenEnd( [<@cTokenEnvironment>] ) --> lTokenEnd",
    "ARGUMENTS": "<@cTokenEnvironment>     a token environment",
    "RETURNS": "<lTokenEnd>              .T., if additional tokens are available",
    "DESCRIPTION": "The TokenEnd() function can be used to check whether the next\ncall to TokenNext() would return a new token. This cannot be\ndecided with TokenNext() alone, since an empty token cannot be\ndistinguished from a \"no more\" tokens.\nIf the parameter <@cTokenEnvironment> is supplied (must be by\nreference), the information from this token environment is used,\notherwise the global TE is used.\nWith a combination of TokenEnd() and TokenNext(), all tokens from a\nstring can be retrieved successively (see example).",
    "EXAMPLES": "TokenInit( \"a.b.c.d\", \".\", 1 )  // initialize global TE\nDO WHILE ! TokenEnd()\n   ? TokenNext( \"a.b.c.d\" )     // get all tokens successively\nENDDO",
    "STATUS": "R",
    "COMPLIANCE": "TokenEnd() is compatible with CT3's TokenEnd(),\nbut there are is an additional parameter featuring local token environments.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "TokenInit(), TokenExit(), TokenNext(), TokenNum(), TokenAt(), SaveToken(), RestToken()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/token2.txt",
    "NAME": "TokenExit()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Release global token environment",
    "SYNTAX": "TokenExit() --> lStaticEnvironmentReleased",
    "ARGUMENTS": "",
    "RETURNS": "<lStaticEnvironmentReleased>   .T., if global token environment is successfully released",
    "DESCRIPTION": "The TokenExit() function releases the memory associated with the\nglobal token environment. One should use it for every TokenInit()\nusing the global TE. Additionally, TokenExit() is implicitly called\nwhen the thread or application ends.",
    "EXAMPLES": "LOCAL cString := \"The quick brown fox jumps over the lazy dog\"\nTokenInit( cString ) // initialize a TE\nDO WHILE ! TokenEnd()\n   ? TokenNext( cString )  // get all tokens successively\nENDDO\n? TokenNext( cString, 3 )  // get the 3rd token, counter will remain the same\nTokenExit()                // free the memory used for the global TE",
    "STATUS": "R",
    "COMPLIANCE": "TokenExit() is a new function in Harbour's CT3 library.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "TokenInit(), TokenNext(), TokenNum(), TokenAt(), SaveToken(), RestToken(), TokenEnd()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/token2.txt",
    "NAME": "TokenAt()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Get start and end positions of tokens in a token environment",
    "SYNTAX": "TokenAt( [<lSeparatorPositionBehindToken>], [<nToken>],\n         [<@cTokenEnvironment>] ) --> nPosition",
    "ARGUMENTS": "<lSeparatorPositionBehindToken>   .T., if TokenAt() should return\n                                  the position of the separator character\n                                  BEHIND the token.\n                                  Default: .F., return start position of a token.\n<nToken>                          a token number\n<@cTokenEnvironment>              a token environment",
    "RETURNS": "<nPosition>",
    "DESCRIPTION": "The TokenAt() function is used to retrieve the start and end position\nof the tokens in a token environment. Note however that the position of\nlast character of a token is given by `TokenAt( .T. ) - 1` !!\n\nIf the 2nd parameter, <nToken> is given, TokenAt() returns the\npositions of the <nToken>th token. Otherwise\nthe token pointed to by the TE counter, i.e. the token that will\nbe retrieved by TokenNext() _NEXT_ is used.\n\nIf the parameter <@cTokenEnvironment> is supplied (must be by\nreference), the information from this token environment is used,\notherwise the global TE is used.",
    "EXAMPLES": "LOCAL cString := \"The quick brown fox jumps over the lazy dog\"\nTokenInit( cString ) // initialize a TE\nDO WHILE ! TokenEnd()\n   ? \"From\", TokenAt(), \"to\", TokenAt( .T. ) - 1\n   ? TokenNext( cString )  // get all tokens successively\nENDDO\n? TokenNext( cString, 3 )  // get the 3rd token, counter will remain the same\nTokenExit()                // free the memory used for the global TE",
    "STATUS": "R",
    "COMPLIANCE": "TokenAt() is compatible with CT3's TokenAt(),\nbut there are two additional parameters featuring local token\nenvironments and optional access to tokens.",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "TokenInit(), TokenExit(), TokenNext(), TokenNum(), SaveToken(), RestToken(), TokenEnd()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/token2.txt",
    "NAME": "SaveToken()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Save the global token environment",
    "SYNTAX": "SaveToken() --> cStaticTokenEnvironment",
    "ARGUMENTS": "",
    "RETURNS": "<cStaticTokenEnvironment>   a binary string encoding the global TE",
    "DESCRIPTION": "The SaveToken() function can be used to store the global TE for future\nuse or when two or more incremental tokenizers must the nested.\nNote however that the latter can now be solved with locally stored\ntoken environments.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "TokenInit(), TokenExit(), TokenNext(), TokenNum(), TokenAt(), RestToken(), TokenEnd()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/token2.txt",
    "NAME": "RestToken()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Restore global token environment",
    "SYNTAX": "RestToken( <cStaticTokenEnvironment> ) --> cOldStaticEnvironment",
    "ARGUMENTS": "<cStaticTokenEnvironment>     a binary string encoding a TE",
    "RETURNS": "<cOldStaticEnvironment>       a string encoding the old global TE",
    "DESCRIPTION": "The RestToken() function restores the global TE to the one encoded\nin <cStaticTokenEnvironment>. This can either be the return value\nof SaveToken() or the value stored in the 4th parameter in a\nTokenInit() call.",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "TokenInit(), TokenExit(), TokenNext(), TokenNum(), TokenAt(), SaveToken(), TokenEnd()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/trig.txt",
    "NAME": "Pi()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Returns Pi, the perimeter-to-diameter-ratio of a circle",
    "SYNTAX": "Pi() --> nPi",
    "ARGUMENTS": "",
    "RETURNS": "<nPi>      the math constant Pi with maximum precision available",
    "DESCRIPTION": "The function Pi() can be used if the constant Pi is needed\nwith maximum precision. One of the most known interpretations of this\nnumber is the constant perimeter-to-diameter-ratio of circles.",
    "EXAMPLES": "// the diameter of a circle-like swimming pool is 3.4 meters, how\n// long is the perimeter?\n\n? Str( Pi() * 3.4, 5, 3 ) + \" meters\"  // --> \"10.681 meters\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Sin(), Cos(), Tan(), Cot(), Asin(), Acos(), Atan(), Atn2(), Sinh(), Cosh(), Tanh(), RToD(), DToR()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/trig.txt",
    "NAME": "Sin()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Sine of the argument",
    "SYNTAX": "Sin( nRadiant ) --> nSine",
    "ARGUMENTS": "<nRadiant>       an angle size given in radiants",
    "RETURNS": "<nSine>          the sine of <nRadiant>",
    "DESCRIPTION": "The function Sin() calculates the sine of an angle whose size is\ngiven in radiants (full angle equals `2 * Pi()` - see DToR() for angle size\ngiven in degrees).\nA common geometric interpretation of the Sin() function is the\ncounterkathede-hypotenuse-ratio of a right-angled triangle.",
    "EXAMPLES": "? Sin( 0.0 )  // --> 0.0\n? Sin( 1.0 )  // --> 0.8414...",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Cos(), Tan(), Cot(), Asin(), Acos(), Atan(), Atn2(), Sinh(), Cosh(), Tanh(), RToD(), DToR(), Pi()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/trig.txt",
    "NAME": "Cos()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Cosine of the argument",
    "SYNTAX": "Cos( nRadiant ) --> nCosine",
    "ARGUMENTS": "<nRadiant>       an angle size given in radiants",
    "RETURNS": "<nCosine>        the cosine of <nRadiant>",
    "DESCRIPTION": "The function Cos() calculates the cosine of an angle whose size is\ngiven in radiants (full angle equals `2 * Pi()` - see DToR() for angle size\ngiven in degrees).\nA common geometric interpretation of the Cos() function is the\nankathede-hypotenuse-ratio of a right-angled triangle.",
    "EXAMPLES": "? Cos( 0.0 )  // --> 1.0\n? Cos( 1.0 )  // --> 0.5403...",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Sin(), Tan(), Cot(), Asin(), Acos(), Atan(), Atn2(), Sinh(), Cosh(), Tanh(), RToD(), DToR(), Pi()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/trig.txt",
    "NAME": "Tan()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Tangent of the argument",
    "SYNTAX": "Tan( nRadiant ) --> nTangent",
    "ARGUMENTS": "<nRadiant>       an angle size given in radiants",
    "RETURNS": "<nTangent>       the tangent of <nRadiant>",
    "DESCRIPTION": "The function Tan() calculates the tangent of an angle whose size is\ngiven in radiants (full angle equals `2 * Pi()` - see DToR() for angle size\ngiven in degrees).\nA common geometric interpretation of the Tan() function is the\ncounterkathede-ankathede-ratio of a right-angled triangle, or,\n`Tan( x )` = `Sin( x ) / Cos( x )`.",
    "EXAMPLES": "? Tan( 0.0 )  // --> 0.0\n? Tan( 1.0 )  // --> 1.5574...",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Sin(), Cos(), Cot(), Asin(), Acos(), Atan(), Atn2(), Sinh(), Cosh(), Tanh(), RToD(), DToR(), Pi()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/trig.txt",
    "NAME": "Cot()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Cotangent of the argument",
    "SYNTAX": "Cot( nRadiant ) --> nCotangent",
    "ARGUMENTS": "<nRadiant>       an angle size given in radiants",
    "RETURNS": "<nCotangent>     the cotangent of <nRadiant>",
    "DESCRIPTION": "The function Cot() calculates the cotangent of an angle whose size is\ngiven in radiants (full angle equals `2 * Pi()` - see DToR() for angle size\ngiven in degrees).\nA common geometric interpretation of the Cot() function is the\nankathede-counterkathede-ratio of a right-angled triangle, or,\n`Cot( x )` = `Cos( x ) / Sin( x )` = `1 / Tan( x )`.",
    "EXAMPLES": "? Cot( 1.0 )  // --> 0.6420...",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Sin(), Cos(), Tan(), Asin(), Acos(), Atan(), Atn2(), Sinh(), Cosh(), Tanh(), RToD(), DToR(), Pi()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/trig.txt",
    "NAME": "Asin()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Arcus sine of the argument",
    "SYNTAX": "Asin( nSine ) --> nRadiant",
    "ARGUMENTS": "<nSine>         the sine of an angle",
    "RETURNS": "<nRadiant>      the angle whose sine is <nSine>",
    "DESCRIPTION": "The function Asin() is the inverse function of Sin(). It takes a\nsine value and returns the smallest(!) angle whose sine equals to the argument.\nThe return value is given in radiants (full angle equals `2 * Pi()` -\nsee DToR() if you need to convert it into degrees).\nNote, that <nSine> must be between -1 and 1 and that <nRadiant>\nis always between `-Pi() / 2` and `Pi() / 2`.",
    "EXAMPLES": "? Asin( 0.0 )  // --> 0.0\n? Asin( 0.5 )  // --> 0.5235...",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Sin(), Cos(), Tan(), Cot(), Acos(), Atan(), Atn2(), Sinh(), Cosh(), Tanh(), RToD(), DToR(), Pi()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/trig.txt",
    "NAME": "Acos()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Arcus cosine of the argument",
    "SYNTAX": "Acos( nCosine ) --> nRadiant",
    "ARGUMENTS": "<nCosine>       the cosine of an angle",
    "RETURNS": "<nRadiant>      the angle whose cosine is <nCosine>",
    "DESCRIPTION": "The function Acos() is the inverse function of Cos(). It takes a\ncosine value and returns the smallest(!) angle whose cosine equals to the argument.\nThe return value is given in radiants (full angle equals `2 * Pi()` -\nsee DToR() if you need to convert it into degrees).\nNote, that <nCosine> must be between -1 and 1 and that <nRadiant>\nis always between 0 and Pi().",
    "EXAMPLES": "? Acos( 0.0 )  // --> Pi() / 2\n? Acos( 0.5 )  // --> 1.04719...",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Sin(), Cos(), Tan(), Cot(), Asin(), Atan(), Atn2(), Sinh(), Cosh(), Tanh(), RToD(), DToR(), Pi()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/trig.txt",
    "NAME": "Atan()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Arcus tangent of the argument",
    "SYNTAX": "Acos( nTangent ) --> nRadiant",
    "ARGUMENTS": "<nTangent>      the tangent of an angle",
    "RETURNS": "<nRadiant>      the angle whose tangent is <nTangent>",
    "DESCRIPTION": "The function Atan() is the inverse function of Tan(). It takes a\ntangent value and returns the smallest(!) angle whose tangent equals to the argument.\nThe return value is given in radiants between `-Pi() / 2` and `Pi() / 2`\n(full angle equals `2 * Pi()` - see DToR() if you need to convert it into degrees).",
    "EXAMPLES": "? Atan( 0.0 )  // --> 0.0\n? Atan( 0.5 )  // --> 0.4636...",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Sin(), Cos(), Tan(), Cot(), Asin(), Acos(), Atan(), Sinh(), Cosh(), Tanh(), RToD(), DToR(), Pi()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/trig.txt",
    "NAME": "Atn2()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Arcus tangent a sine and a cosine argument",
    "SYNTAX": "Atn2( nSine, nCosine ) --> nRadiant",
    "ARGUMENTS": "<nSine>         the sine of an angle\n<nCosine>       the cosine of an angle",
    "RETURNS": "<nRadiant>      the angle whose tangent is <nSine>/<nCosine>",
    "DESCRIPTION": "The function Atn2() is an alternate function for calculating\nthe arcus tangent, `Atn2( x, y )` = `Atan( x / y)`.\nIt takes two arguments, the sine and the cosine\nof the angle that should be calculated. Thus, in contrast to the Atan()\nfunction, Atn2() can distinguish whether the sine or the cosine has\na negative sign (or both being positive or negative), so that\nthe return value can be between `-Pi()` and Pi() and covers the full\nangle.\nThe return value is given in radiants (full angle equals `2 * Pi()` -\nsee DToR() if you need to convert it into degrees).",
    "EXAMPLES": "? Atn2( 0.0, 1.0 )  // --> 0.0\n? Atn2( Sqrt( 1 / 2 ), Sqrt( 1 / 2 ) )  // --> Pi() / 4",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Sin(), Cos(), Tan(), Cot(), Asin(), Acos(), Atan(), Sinh(), Cosh(), Tanh(), RToD(), DToR(), Pi()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/trig.txt",
    "NAME": "Sinh()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Hyperbolic Sine of the argument",
    "SYNTAX": "Sinh( nArea ) --> nHyperbolicSine",
    "ARGUMENTS": "<nArea>            the size of the area (see below)",
    "RETURNS": "<nHyperbolicSine>  the hyperbolic sine of <nArea>",
    "DESCRIPTION": "The function Sinh() calculates the hyperbolic sine of the argument.\nIn analytical mathematics it is defined as `1 / 2 * ( Exp( nArea ) - Exp( -nArea ) )`.\nA common geometric interpretation of the Sinh() function is the\nmaximum y value of the points in the area with the given size <nArea>,\nthat is bound by the x axis, a straight line through the point of\norigin (this one is fixed by the area) and the hyperbola `x ^ 2 - y ^ 2 = 1`.",
    "EXAMPLES": "? Sinh( 0.0 )  // --> 0.0\n? Sinh( 1.0 )  // --> 1.1752...",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Sin(), Cos(), Tan(), Cot(), Asin(), Acos(), Atan(), Atn2(), Cosh(), Tanh(), RToD(), DToR(), Pi()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/trig.txt",
    "NAME": "Cosh()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Hyperbolic Cosine of the argument",
    "SYNTAX": "Cosh( nArea ) --> nHyperbolicCosine",
    "ARGUMENTS": "<nArea>              the size of the area (see below)",
    "RETURNS": "<nHyperbolicCosine>  the hyperbolic cosine of <nArea>",
    "DESCRIPTION": "The function Cosh() calculates the hyperbolic cosine of the argument.\nIn analytical mathematics it is defined as `1 / 2 * ( Exp( nArea ) + Exp( -nArea ) )`.\nA common geometric interpretation of the Cosh() function is the\nmaximum x value of the points in the area with the given size <nArea>,\nthat is bound by the x axis, a straight line through the point of\norigin (this one is fixed by the area) and the hyperbola `x ^ 2 - y ^ 2 = 1`.",
    "EXAMPLES": "? Cosh( 0.0 )  // --> 1.0\n? Cosh( 1.0 )  // --> 1.5430...",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Sin(), Cos(), Tan(), Cot(), Asin(), Acos(), Atan(), Atn2(), Sinh(), Tanh(), RToD(), DToR(), Pi()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/trig.txt",
    "NAME": "Tanh()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Hyperbolic Tangent of the argument",
    "SYNTAX": "Tanh( nArea ) --> nHyperbolicTangent",
    "ARGUMENTS": "<nArea>               the size of the area (see below)",
    "RETURNS": "<nHyperbolicTangent>  the hyperbolic tangent of <nArea>",
    "DESCRIPTION": "The function Tanh() calculates the hyperbolic tangent of the argument.\nIn analytical mathematics it is defined as `Sinh( x ) / Cosh( x )`.",
    "EXAMPLES": "? Tanh( 0.0 )  // --> 0.0\n? Tanh( 1.0 )  // --> 0.7615...",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Sin(), Cos(), Tan(), Cot(), Asin(), Acos(), Atan(), Atn2(), Sinh(), Cosh(), RToD(), DToR(), Pi()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/trig.txt",
    "NAME": "RToD()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Convert radiant to degree",
    "SYNTAX": "RToD( nRadiant ) --> nDegree",
    "ARGUMENTS": "<nRadiant>         the size of an angle in radiant",
    "RETURNS": "<nDegree>          the size of that angle in degree",
    "DESCRIPTION": "The function RToD() can be used to convert sizes of angles given\nin radiant (like those returned by the ASin(), ACos() or ATan() functions)\nto degrees that are commonly used geometry and mechanics.",
    "EXAMPLES": "? RToD( Pi() )      // --> 180\n? Tanh( Pi() / 3 )  // --> 60",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Sin(), Cos(), Tan(), Cot(), Asin(), Acos(), Atan(), Atn2(), Sinh(), Cosh(), Tanh(), DToR(), Pi()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/trig.txt",
    "NAME": "DToR()",
    "CATEGORY": "CT3 math functions",
    "ONELINER": "Convert degree to radiant",
    "SYNTAX": "DToR( nDegree ) --> nRadiant",
    "ARGUMENTS": "<nDegree>          the size of that angle in degree",
    "RETURNS": "<nRadiant>         the size of an angle in radiant",
    "DESCRIPTION": "The function DToR() can be used to convert sizes of angles given\nin degrees to radiant (as expected by sin, cos or tan functions).",
    "EXAMPLES": "? DToR( 180 )  // --> Pi()\n? DToR( 60 )   // --> Pi() / 3",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "Sin(), Cos(), Tan(), Cot(), Asin(), Acos(), Atan(), Atn2(), Sinh(), Cosh(), Tanh(), RToD(), Pi()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/video.txt",
    "NAME": "CharPix()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "Gets the number of scan lines per character.",
    "SYNTAX": "CharPix() --> nHeight",
    "ARGUMENTS": "",
    "RETURNS": "Returns the number of scan lines per character.",
    "DESCRIPTION": "Returns the number of scan lines per character.",
    "EXAMPLES": "",
    "STATUS": "S",
    "COMPLIANCE": "",
    "PLATFORMS": "DJGPP",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/video.txt",
    "NAME": "VGAPalette()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "Changes VGA palette colors",
    "SYNTAX": "VGAPalette( [<cColor|nColor>, [<nRedValue>, <nGreenValue>,\n                               <nBlueValue]] ) --> lValid",
    "ARGUMENTS": "<cColor|nColor> - the color to change in CA-Cl*pper color notation or\n        as a number from 0 to 15.\n<nRedValue>, <nGreenValue>, and <nBlueValue> specify the palette\n        settings for the respective portions in the range from 0 to 63.\n        If no RGB value is specified, the palette register is reset to\n        its default value (currently unsupported).\nIf the function is called without parameters, the palette registers for\nall colors are reset to their default values (currently unsupported).",
    "RETURNS": "Returns .T. on success.",
    "DESCRIPTION": "",
    "EXAMPLES": "",
    "STATUS": "S",
    "COMPLIANCE": "",
    "PLATFORMS": "DJGPP",
    "FILES": "Library is hbct.",
    "SEEALSO": "EGAPalette(), FontReset()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/video.txt",
    "NAME": "VideoType()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "Detects supported video adapter modes",
    "SYNTAX": "VideoType() --> nMask",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: Finish documentation",
    "EXAMPLES": "",
    "STATUS": "S",
    "COMPLIANCE": "",
    "PLATFORMS": "DJGPP",
    "FILES": "Library is hbct.",
    "SEEALSO": "IsCGA(), IsEGA(), IsHercules(), IsMCGA(), IsMono(), IsPGA(), IsVGA()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/video.txt",
    "NAME": "SetFont()",
    "CATEGORY": "CT3 video functions",
    "ONELINER": "Loads font from a string.",
    "SYNTAX": "SetFont( <cFontString>, [<nFontArea>], [<nOffset>], [<nCounter>] ) --> nError\n    or:\nSetFont( <cFontString>, [<nFontArea>], [<lCompute>] ) --> nError",
    "ARGUMENTS": "<cFontString> Binary string containing a valid font definition.\n<nFontArea> Number of a font area where the font must be loaded.\n<nOffset> First character code to be loaded.\n<nCounter> Number of characters to load.\n<lCompute> When .T., the function computes font height automatically.",
    "RETURNS": "",
    "DESCRIPTION": "TODO: Finish documentation",
    "EXAMPLES": "",
    "STATUS": "S",
    "COMPLIANCE": "",
    "PLATFORMS": "DJGPP",
    "FILES": "Library is hbct.",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/wordrepl.txt",
    "NAME": "WordRepl()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Replacement of double characters",
    "SYNTAX": "WordRepl( <cDoubleCharacterSearchString>, <[@]cString>,\n          <cDoubleCharacterReplaceString>, [<lMode>] ) --> cString",
    "ARGUMENTS": "<cDoubleCharacterSearchString>   is a string of double characters\n                                 that should be replaced\n<[@]cString>                     is the processed string\n<cDoubleCharacterReplaceString>  is a string of double characters that\n                                 replace the one of <cSearchString>\n[<lMode>]                        sets the replacement method (see description)\n                                 Default: .F.",
    "RETURNS": "<cString>                        the processed string",
    "DESCRIPTION": "The WordRepl() takes the double characters of <cDoubleCharacterSearchString>\none after the other and searches for them in <cString>.\nFor <lMode> set to .F., this search is successful, if the double\ncharacter sequence in <cString> starts at an odd position or at any\nposition, if <lMode> is set to .T.\nIf this happens, the double character sequence will be replaced with\nthe corresponding double character sequence of <cDoubleCharacterReplaceString>.\nIf <cDoubleCharacterReplaceString> is shorter than <cDoubleCharacterSearchString>\nthe last double sequence of <cDoubleCharacterReplaceString> is used for\nthe \"rest\" of <cDoubleCharacterSearchString>. Note that the last double\ncharacter sequence in \"AABBC\" is \"BB\" in this context !!\nAfter the replacement the function restarts the search in <cString>\nBEHIND the replacement if the CSetAtMupa() switch is turned off, or\nBEHIND the first character of the replacement if the switch is turned on.\n(see examples for this !)\nOne can omit the return value of this function by setting the CSetRef()\nto .T., but one must then pass <cString> by reference to get a result.",
    "EXAMPLES": "? WordRepl( \"CC\", \"AABBCCDDEE\", \"XX\" )  // \"AABBXXDDEE\"\n? WordRepl( \"aa\", \"1aaaa\", \"ba\" )       // \"1abaa\"\n? WordRepl( \"aa\", \"1aaaa\", \"ba\", .T. )  // \"1baba\"\nCSetAtMupa( .T. )\n? WordRepl( \"aa\", \"1aaaa\", \"ba\" )       // \"1abaa\"\n? WordRepl( \"aa\", \"1aaaa\", \"ba\", .T. )  // \"1bbba\"",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CharRepl(), RangeRepl(), PosRepl(), CSetRef(), CSetAtMupa()"
  },
  {
    "_COMPONENT": "hbct",
    "_LANG": "en",
    "_DOCSOURCE": "./hbct/doc/en/wordtoch.txt",
    "NAME": "WordToChar()",
    "CATEGORY": "CT3 string functions",
    "ONELINER": "Replace double with single characters",
    "SYNTAX": "WordToChar( <cDoubleCharacterSearchString>, <cString>,\n            <cSingleCharacterReplaceString> ) --> cString",
    "ARGUMENTS": "",
    "RETURNS": "",
    "DESCRIPTION": "TODO: add documentation",
    "EXAMPLES": "",
    "STATUS": "R",
    "COMPLIANCE": "C",
    "PLATFORMS": "All",
    "FILES": "Library is hbct.",
    "SEEALSO": "CSetAtMupa(), CharRepl(), WordRepl()"
  }
]
