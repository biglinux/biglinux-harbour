[
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/aading.txt",
    "NAME": "ft_AAddition()",
    "CATEGORY": "Array",
    "ONELINER": "Add elements unique of source array to target array",
    "SYNTAX": "ft_AAddition( <aList1>, <aList2> [, <lTrimmer> [, <lCaseSens> ] ] ) ;\n        --> aNewArray",
    "ARGUMENTS": "<aList1> is the primary array.\n\n<aList2> is the secondary array.\n\n<lTrimmer> is a logical value denoting whether leading or\n        trailing spaces should be included in the\n        comparison. If .T., then ignores spaces in\n        comparison, defaults to .T., .F. includes spaces.\n\n<lCaseSens> is a logical value denoting case sensitivity.\n        If .T., then comparison is sensitive to case,\n        defaults to .T., .F. ignores case.",
    "RETURNS": "An array of the union of <aList1> and <aList2>.",
    "DESCRIPTION": "This function will add the elements unique of <aList2> with <aList1>.\nIt returns a new array including all the elements of <aList1>\nplus the unique elements of <aList2>.",
    "EXAMPLES": "LOCAL aList1 := { \"apple\", \"orange\", \"pear\" }\nLOCAL aList2 := { \"apple \", \"banana\", \"PEAR\" }\n\n// ignores spaces, sensitive to case\n? hb_ValToExp( ft_AAddition( aList1, aList2 ) )\n// --> { \"apple\", \"orange\", \"pear\", \"banana\", \"PEAR\" }\n\n// ignores spaces, not sensitive to case\n? hb_ValToExp( ft_AAddition( aList1, aList2, , .F. ) )\n// --> { \"apple\", \"orange\", \"pear\", \"banana\" }\n\n// sensitive to spaces, not sensitive to case\n? hb_ValToExp( ft_AAddition( aList1, aList2, .F. , .F. ) )\n// --> { \"apple\", \"orange\", \"pear\", \"apple \", \"banana\" }"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/aavg.txt",
    "NAME": "ft_AAvg()",
    "CATEGORY": "Array",
    "ONELINER": "Average numeric values in an array",
    "SYNTAX": "ft_AAvg( <aArray> [, <nStartIndex> [, <nEndIndex> ] ] ) --> nAverage",
    "ARGUMENTS": "<aArray> is the array containing the elements to be averaged.\n\n<nStartIndex> is the first array item to include,\ndefaults to first element.\n\n<nEndIndex> is the last array element to include,\ndefaults to all elements.",
    "RETURNS": "The average of the specified array elements.",
    "DESCRIPTION": "This function is used to get a numeric average of selected or all\nelements of an array.\n\nThis routine requires ft_ASum().",
    "EXAMPLES": "LOCAL aSubTotals := { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }\n? ft_AAvg( aSubTotals )         // Get Average of Entire Array\n? ft_AAvg( aSubTotals, 5 )      // Get Average of 5th Element On\n? ft_AAvg( aSubTotals, , 10 )   // Get Average of 1st 10 Elements\n? ft_AAvg( aSubTotals, 5, 10 )  // Get Average of Elements 5-10"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/acctadj.txt",
    "NAME": "ft_AcctAdj()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Adjust beginning or ending fiscal pd. dates to acctg. dates",
    "SYNTAX": "ft_AcctAdj( [ <dGivenDate> ], [ <lIsEnd> ] ) --> dDate",
    "ARGUMENTS": "<dGivenDate> is any valid date in any valid format.\nDefaults to Date() if not supplied.\n\n<lIsEnd> is a logical variable. .F. = adjust for beginning of\nperiod mode, .T. = adjust for end of period mode.  Defaults to\nbeginning of period mode.",
    "RETURNS": "An adjusted date dependent upon mode and work week start day.",
    "DESCRIPTION": "Called by other ft_Acct*() functions. The algorithm is:\n\nBeginning of period mode:\n```\nIF dGivenDate is in last 3 days of work week\n   Return next week's start date\nELSE\n   Return this week's start date\nENDIF\n```\n\nEnd of period mode:\n```\nIF dGivenDate is in last 4 days of work week\n   Return this week's end date\nELSE\n   Return prior week's end date\nENDIF\n```",
    "EXAMPLES": "LOCAL dDate\n\n// Beginning of period mode (lIsEnd == .F.)\n\ndDate := 0d19910131         // In last 3 days of work week\n? ft_AcctAdj( dDate )       // --> 1991-02-03  (next week's start)\n\ndDate := 0d19910331         // Not in last 3 days of work week\n? ft_AcctAdj( dDate )       // --> 1991-03-31  (this week's start)\n\n// End of period mode (lIsEnd == .T.)\n\ndDate := 0d19910131         // In last 4 days of work week\n? ft_AcctAdj( dDate, .T. )  // --> 1991-02-02  (this week's end)\n\ndDate := 0d19910331         // Not in last 4 days of work week\n? ft_AcctAdj( dDate, .T. )  // --> 1991-03-30  (prior week's end)",
    "SEEALSO": "ft_DateCnfg(), ft_DayToBoW()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/acctmnth.txt",
    "NAME": "ft_AcctMonth()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Return accounting month data",
    "SYNTAX": "ft_AcctMonth( [ <dGivenDate> ], [ <nMonthNum> ] ) --> aDateInfo",
    "ARGUMENTS": "<dGivenDate> is any valid date in any date format.  Defaults\nto current system date if not supplied.\n\n<nMonthNum> is a number from 1 to 12 signifying a month.\nDefaults to current month if not supplied.",
    "RETURNS": "A three element array containing the following data:\n```\naDateInfo[ 1 ] - The year and month as a character string \"YYYYMM\"\naDateInfo[ 2 ] - The beginning date of the accounting month\naDateInfo[ 3 ] - The ending date of the accounting month\n```",
    "DESCRIPTION": "ft_AcctMonth() creates an array containing data about the\naccounting month containing the given date.\n\nAn accounting period has the following characteristics:\n\nIf the first week of the period contains 4 or more 'work'\ndays, it is included in the period; otherwise, the first\nweek was included in the prior period.\n\nIf the last week of the period contains 4 or more 'work'\ndays it is included in the period; otherwise, the last week\nis included in the next period.  This results in 13 week\n'quarters' and 4 or 5 week 'months'.  Every 5 or 6 years, a\n'quarter' will contain 14 weeks and the year will contain 53\nweeks.",
    "EXAMPLES": "LOCAL aDateInfo\n// get info about accounting month containing 1990-09-15\naDateInfo := ft_AcctMonth( 0d19900915 )\n? aDateInfo[ 1 ]  // --> 199009      (9th month)\n? aDateInfo[ 2 ]  // --> 1990-09-02  beginning of month 9\n? aDateInfo[ 3 ]  // --> 1990-09-29  end of month 9\n\n// get info about accounting month 5 in year containing 1990-09-15\naDateInfo := ft_AcctMonth( 0d19900915, 5 )\n? aDateInfo[ 1 ]  // --> 199005\n? aDateInfo[ 2 ]  // --> 1990-04-29  beginning of month 5\n? aDateInfo[ 3 ]  // --> 1990-06-02  end of month 5",
    "SEEALSO": "ft_DateCnfg(), ft_AcctWeek(), ft_AcctQtr(), ft_AcctYear()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/acctqtr.txt",
    "NAME": "ft_AcctQtr()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Return accounting quarter data",
    "SYNTAX": "ft_AcctQtr( [ <dGivenDate> ], [ <nQtrNum> ] ) --> aDateinfo",
    "ARGUMENTS": "<dGivenDate> is any valid date in any date format.  Defaults\nto current system date if not supplied.\n\n<nQtrNum> is a number from 1 to 4 signifying a quarter.\nDefaults to current quarter if not supplied.",
    "RETURNS": "A three element array containing the following data:\n```\naDateInfo[ 1 ] - The year and qtr. as a character string \"YYYYQQ\"\naDateInfo[ 2 ] - The beginning date of the accounting quarter\naDateInfo[ 3 ] - The ending date of the accounting quarter\n```",
    "DESCRIPTION": "ft_AcctQtr() creates an array containing data about the\naccounting quarter containing the given date.\n\nAn accounting period has the following characteristics:\n\nIf the first week of the period contains 4 or more 'work'\ndays, it is included in the period; otherwise, the first\nweek was included in the prior period.\n\nIf the last week of the period contains 4 or more 'work'\ndays it is included in the period; otherwise, the last week\nis included in the next period.  This results in 13 week\n'quarters' and 4 or 5 week 'months'.  Every 5 or 6 years, a\n'quarter' will contain 14 weeks and the year will contain 53\nweeks.",
    "EXAMPLES": "LOCAL aDateInfo\n// get info about accounting month containing 1990-09-15\naDateInfo := ft_AcctQtr( 0d19900915 )\n? aDateInfo[ 1 ]  // --> 199003      (3rd quarter)\n? aDateInfo[ 2 ]  // --> 1990-07-01  beginning of quarter 3\n? aDateInfo[ 3 ]  // --> 1990-09-29  end of quarter 3\n\n// get info about accounting qtr. 2 in year containing 1990-09-15\naDateInfo := ft_AcctQtr( 0d19900915, 2 )\n? aDateInfo[ 1 ]  // --> 199002\n? aDateInfo[ 2 ]  // --> 1989-04-01  beginning of quarter 2\n? aDateInfo[ 3 ]  // --> 1990-06-30  end of quarter 2",
    "SEEALSO": "ft_DateCnfg(), ft_AcctWeek(), ft_AcctMonth(), ft_AcctYear()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/acctweek.txt",
    "NAME": "ft_AcctWeek()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Return accounting week data",
    "SYNTAX": "ft_AcctWeek( [ <dGivenDate> ], [ <nWeekNum> ] ) --> aDateInfo",
    "ARGUMENTS": "<dGivenDate> is any valid date in any date format.  Defaults\nto current system date if not supplied.\n\n<nWeekNum> is a number from 1 to 52 signifying a week.\nDefaults to current week if not supplied.",
    "RETURNS": "A three element array containing the following data:\n```\naDateInfo[ 1 ] - The year and week as a character string \"YYYYWW\"\naDateInfo[ 2 ] - The beginning date of the accounting week\naDateInfo[ 3 ] - The ending date of the accounting week\n```",
    "DESCRIPTION": "ft_AcctWeek() returns an array containing data about the\naccounting week containing the given date.\n\nAn accounting period has the following characteristics:\n\nIf the first week of the period contains 4 or more 'work'\ndays, it is included in the period; otherwise, the first\nweek was included in the prior period.\n\nIf the last week of the period contains 4 or more 'work'\ndays it is included in the period; otherwise, the last week\nis included in the next period.  This results in 13 week\n'quarters' and 4 or 5 week 'months'.  Every 5 or 6 years, a\n'quarter' will contain 14 weeks and the year will contain 53\nweeks.",
    "EXAMPLES": "LOCAL aDateInfo\n// get info about accounting week containing 1990-09-15\naDateInfo := ft_AcctWeek( 0d19900915 )\n? aDateInfo[ 1 ]  // --> 199037      (37th week)\n? aDateInfo[ 2 ]  // --> 1990-09-09  beginning of week 37\n? aDateInfo[ 3 ]  // --> 1990-09-15  end of week 37\n\n// get info about accounting week 25 in year containing 1990-09-15\naDateInfo := ft_AcctWeek( 0d19900915, 25 )\n? aDateInfo[ 1 ]  // --> 199025\n? aDateInfo[ 2 ]  // --> 1989-06-17  beginning of week 25\n? aDateInfo[ 3 ]  // --> 1990-06-23  end of week 25",
    "SEEALSO": "ft_DateCnfg(), ft_AcctMonth(), ft_AcctQtr(), ft_AcctYear()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/acctyear.txt",
    "NAME": "ft_AcctYear()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Return accounting year data",
    "SYNTAX": "ft_AcctYear( [ <dGivenDate> ] ) --> aDateInfo",
    "ARGUMENTS": "<dGivenDate> is any valid date in any date format.  Defaults\nto current system date if not supplied.",
    "RETURNS": "A three element array containing the following data:\n```\naDateInfo[ 1 ] - The year as a character string \"YYYY\"\naDateInfo[ 2 ] - The beginning date of the accounting year\naDateInfo[ 3 ] - The ending date of the accounting year\n```",
    "DESCRIPTION": "ft_AcctYear() creates an array containing data about the\naccounting year containing the given date.\n\nAn accounting period has the following characteristics:\n\nIf the first week of the period contains 4 or more 'work'\ndays, it is included in the period; otherwise, the first\nweek was included in the prior period.\n\nIf the last week of the period contains 4 or more 'work'\ndays it is included in the period; otherwise, the last week\nis included in the next period.  This results in 13 week\n'quarters' and 4 or 5 week 'months'.  Every 5 or 6 years, a\n'quarter' will contain 14 weeks and the year will contain 53\nweeks.",
    "EXAMPLES": "LOCAL aDateInfo\n// get info about accounting year containing 1990-09-15\naDateInfo := ft_AcctYear( 0d19900915 )\n? aDateInfo[ 1 ]  // --> 1990\n? aDateInfo[ 2 ]  // --> 1989-12-31  beginning of year\n? aDateInfo[ 3 ]  // --> 1990-12-29  end of year",
    "SEEALSO": "ft_DateCnfg(), ft_AcctWeek(), ft_AcctMonth(), ft_AcctQtr()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/adapter.txt",
    "NAME": "ft_Adapter()",
    "CATEGORY": "Video",
    "ONELINER": "Report the type of video adapter installed",
    "SYNTAX": "ft_Adapter() --> nResult",
    "ARGUMENTS": "None",
    "RETURNS": "Integer representing type of video adapter\n\n   0 - monochrome\n   1 - CGA\n   2 - EGA\n   3 - VGA",
    "DESCRIPTION": "This function is valuable if you use a graphics library and need to\nknow what type of graphics adapter is installed.",
    "EXAMPLES": "LOCAL nVideo := ft_Adapter()\n\nDO CASE\nCASE nVideo == 0\n   ? \"You have a monochrome adapter.\"\nCASE nVideo == 1\n   ? \"You have a CGA adapter.\"\nCASE nVideo == 2\n   ? \"You have an EGA adapter.\"\nCASE nVideo == 3\n   ? \"You have a VGA adapter.\"\nENDCASE",
    "SEEALSO": "ft_SetMode()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/adessort.txt",
    "NAME": "ft_ADesSort()",
    "CATEGORY": "Array",
    "ONELINER": "Sort an array in descending order",
    "SYNTAX": "ft_ADesSort( <aArray> [, <nStartIndex> [, <nEndIndex> ] ] ) --> aSorted",
    "ARGUMENTS": "<aArray> is the array to be sorted\n\n<nStartIndex> is the first array item to include in the sort,\ndefaults to first element\n\n<nEndIndex> is the last array element to include in the sort,\ndefaults to all elements",
    "RETURNS": "The array, sorted in descending order.",
    "DESCRIPTION": "This function is used to sort an array in descending order, i.e., Z-A",
    "EXAMPLES": "LOCAL aNames := { \"apple\", \"orange\", \"pear\", \"banana\", \"cherry\", \"mango\" }\nft_ADesSort( aNames, 2, 4 )  // Sort Elements 1-3\n? hb_ValToExp( aNames )\nft_ADesSort( aNames, 5 )     // Sort from the 5th Element On\n? hb_ValToExp( aNames )\nft_ADesSort( aNames, , 2 )   // Sort the 1st 3 Elements\n? hb_ValToExp( aNames )\nft_ADesSort( aNames )        // Sort the Entire Array\n? hb_ValToExp( aNames )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/aemaxlen.txt",
    "NAME": "ft_AEMaxLen()",
    "CATEGORY": "Array",
    "ONELINER": "Find longest element within an array",
    "SYNTAX": "ft_AEMaxLen( <aArray> [, <nDimension> [, <nStart> [, <nCount> ] ] ] ) ;\n           --> nMaxlen",
    "ARGUMENTS": "<aArray> is the array containing the elements to be measured.\n\n<nDimension> is the array dimension to be measured,\n           defaults to first dimension.\n\n<nStart> is the starting array element to include,\n           defaults to first array element.\n\n<nCount> is the number of array elements to process from\n           from <nStart>, defaults to remaining elements\n           in array.",
    "RETURNS": "The length of the longest size element of an array.",
    "DESCRIPTION": "This function will measure each element of an array\ndimension and return the longest element.",
    "EXAMPLES": "// FIXME\n? ft_AEMaxLen( aArray )           // Measure the 1st dimension of an Array\n? ft_AEMaxLen( aArray, 2 )        // Measure the 2nd dimension of an Array\n? ft_AEMaxLen( aArray, 2, , 9 )   // Measure Elements 1-9 of the 2nd dimension or subarray\n? ft_AEMaxLen( aArray, 3, 5, 9 )  // Measure Elements 5-9 of the 3rd dimension or subarray\n? ft_AEMaxLen( aArray, 3, 5 )     // Measure Elements 5 to last in the 3rd dimension or subarray",
    "SEEALSO": "ft_AEMinLen()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/aeminlen.txt",
    "NAME": "ft_AEMinLen()",
    "CATEGORY": "Array",
    "ONELINER": "Find shortest element within an array",
    "SYNTAX": "ft_AEMinLen( <aArray> [, <nDimension> [, <nStart> [, <nCount> ] ] ] )\n           --> nMinlen",
    "ARGUMENTS": "<aArray> is the array containing the elements to be measured.\n\n<nDimension> is the array dimension to be measured,\n           defaults to first dimension.\n\n<nStart> is the starting array element to include,\n           defaults to first array element.\n\n<nCount> is the number of array elements to process from\n           from <nStart>, defaults to remaining elements\n           in array.",
    "RETURNS": "The length of the shortest size element of an array.",
    "DESCRIPTION": "This function will measure each element of an array\ndimension and return the shortest element.",
    "EXAMPLES": "// FIXME\n? ft_AEMinLen( aArray )           // Measure the 1st dimension of an Array\n? ft_AEMinLen( aArray, 2 )        // Measure the 2nd dimension of an Array\n? ft_AEMinLen( aArray, 2, , 9 )   // Measure Elements 1-9 of 2nd dimension\n? ft_AEMinLen( aArray, 3, 5, 9 )  // Measure Elements 5-9 of 3rd dimension\n? ft_AEMinLen( aArray, 3, 5 )     // Measure Elements 5 to end of 3rd dimension",
    "SEEALSO": "ft_AEMaxLen()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/alt.txt",
    "NAME": "ft_Alt()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Determine status of the Alt key",
    "SYNTAX": "ft_Alt() --> lValue",
    "ARGUMENTS": "None",
    "RETURNS": ".T. if Alt key is pressed, .F. if otherwise.",
    "DESCRIPTION": "This function is useful for times you need to know whether or not the\nAlt key is pressed, such as during a MemoEdit().",
    "EXAMPLES": "IF ft_Alt()\n   @ 0, 0 SAY \"Alt\"\nELSE\n   @ 0, 0 SAY \"   \"\nENDIF",
    "SEEALSO": "ft_CapLock(), ft_Ctrl(), ft_NumLock(), ft_PrtScr(), ft_Shift()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/amedian.txt",
    "NAME": "ft_AMedian()",
    "CATEGORY": "Array",
    "ONELINER": "Find middle value in array, or average of two middle values",
    "SYNTAX": "ft_AMedian( <aArray> [, <nStart> [, <nEnd> ] ] )\n           --> nMedian",
    "ARGUMENTS": "<aArray> is the array containing the elements to be averaged.\n\n<nStart> is the first array element to include,\ndefaults to first element.\n\n<nEnd> is the last array element to include,\ndefaults to last element.",
    "RETURNS": "The median average of the array elements",
    "DESCRIPTION": "This function sorts the elements of a numeric array and\nthen returns the value in the middle element of the sorted\narray.  If there is no exact middle value, then it returns\nthe average of the two middle values.  Half of the elements\nare > median and half are < median.  A median average may\nmore reflect a more useful average when there are extreme\nvalues in the set.",
    "EXAMPLES": "LOCAL aArray := { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }\n? ft_AMedian( aArray )         // Return Median for entire array\n? ft_AMedian( aArray, 2 )      // Return Median for elements from 2 to end\n? ft_AMedian( aArray, , 9 )    // Return Median for 1st 9 elements\n? ft_AMedian( aArray, 8, 40 )  // Return Median for elements 8 to 40"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/anomatch.txt",
    "NAME": "ft_ANoMatches()",
    "CATEGORY": "Array",
    "ONELINER": "Find the number of array elements meeting a condition",
    "SYNTAX": "ft_ANoMatches( <aArray>, <bCompareBlock> ;\n               [, <nStartIndex> [, <nEndIndex> ] ] ) --> nNoOfMatches",
    "ARGUMENTS": "<aArray> is the array to be searched\n\n<bCompareBlock> is a code block containing the expression for\nthe array elements to be tested with.  Each element is passed\nas a parameter to the block.  If the block returns .T., the\nnumber of matches will be incremented by one.\n\n<nStartIndex> is the first array item to include in the search,\ndefaults to first element.\n\n<nEndIndex> is the last array element to include in the search,\ndefaults to all elements.",
    "RETURNS": "The number of elements that cause the code block to return .T.",
    "DESCRIPTION": "This function returns the number of array elements that, when passed\nto the supplied code block, cause that code block to return a .T. value.",
    "EXAMPLES": "// FIXME\n// Search the Entire Array\n? ft_ANoMatches( aTries, {| x | x <= 100 } )\n\n// Search from the 5th Element On\n? ft_ANoMatches( aCodes, {| x | Upper( x ) == cCurrentCode }, 5 )\n\n// Search the 1st 10 Elements\n? ft_ANoMatches( aDates, {| x | IS_BETWEEN( Date() - 7, x, Date() + 7 ) }, 10 )\n\n// Search Elements 5-10\n? ft_ANoMatches( aNames, {| x | x <= cLastGoodName }, 5, 10 )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/any2any.txt",
    "NAME": "ft_XToY()",
    "CATEGORY": "Conversion",
    "ONELINER": "Convert from any data type to any other data type",
    "SYNTAX": "ft_XToY( <xValueToConvert>, <cTypeToConvertTo> ;\n         [, <lWantYesNo> ] ) --> xResult",
    "ARGUMENTS": "<xValueToConvert> is the value to convert.\n\n<cTypeToConvertTo> is the type of value to convert to\n(\"C\",\"D\",\"L\",\"N\",\"A\" or \"B\").\n\n<lWantYesNo> is a logical to signal if 'Y' or 'N' is to be returned\nif Converting a logical, otherwise '.T.' or '.F.' will be returned\nfor logicals.",
    "RETURNS": "The original value converted to the new type.",
    "DESCRIPTION": "This function converts a value of character, date, numeric, logical,\narray or code block type to any of the other type.  While it is\nguaranteed to return a value of the correct type, that value may not\nbe meaningful (i.e., converting from a code block returns an Empty()\nvalue of the desired type).",
    "EXAMPLES": "? ft_XToY( \"123\", \"N\" )  // --> 123\n? ft_XToY( 1, \"L\" )      // --> .T."
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/aredit.txt",
    "NAME": "ft_ArEdit()",
    "CATEGORY": "Array",
    "ONELINER": "2 dimensional array editing function using TBrowse",
    "SYNTAX": "ft_ArEdit( <nTop>, <nLeft>, <nBottom>, <nRight>, <Array Name>, ;\n   <nElem>, <aHeadings>, <aBlocks> [, <bGetFunc> ] ) --> xElement",
    "ARGUMENTS": "<nTop>, <nLeft>, <nBottom>, <nRight> are coordinates for TBrowse\n\n<Array Name> is name of 2 dimensional to array edit\n\n<nElem>      is pointer for element in array\n\n<aHeadings>  is array of column headings\n\n<aBlocks>    is array of blocks describing each array element\n\n[ <bGetFunc> ] is get editing function for handling individual elements",
    "RETURNS": "Value of element positioned on when exit ft_ArEdit()\nThe type of this value depends on what is displayed.",
    "DESCRIPTION": "This function allows you to position yourself in an array,\nadd and delete rows with the <F7> and <F8> keys,\nand pass a UDF with information to edit the individual gets.",
    "EXAMPLES": "LOCAL i, ar[ 3 ][ 26 ], aBlocks[ 3 ], aHeadings[ 3 ]\nLOCAL nElem := 1, bGetFunc\n\n// This example will allow you to browse a 2 dimensional array\n// But you cannot edit it since there is no GetBlock UDF\n// It allows the user to hit <Enter> to select an element or <Esc>\n// to return 0\n\nft_ArEdit( 3, 5, 18, 75, ar, @nElem, aHeadings, aBlocks )\n\n// This second example shows how to edit a 2 dimensional array\n// as might be done to edit an invoice\n\n// Set up two dimensional array \"ar\"\n\nFOR i := 1 TO 26\n   ar[ 1 ][ i ] := i                          //  1  ->  26  Numeric\n   ar[ 2 ][ i ] := Chr( Asc( \"A\" ) + i - 1 )  // \"A\" -> \"Z\"  Character\n   ar[ 3 ][ i ] := Chr( Asc( \"Z\" ) - i + 1 )  // \"Z\" -> \"A\"  Character\nNEXT\n\n// set up aHeadings Array for column headings\n\naHeadings  := { \"Numbers\", \"Letters\", \"Reverse\" }\n\n// Need to set up individual array blocks for each TBrowse column\n\naBlocks[ 1 ] := {|| Str( ar[ 1 ][ nElem ], 2 ) }  // prevent default 10 spaces\naBlocks[ 2 ] := {|| ar[ 2 ][ nElem ] }\naBlocks[ 3 ] := {|| ar[ 3 ][ nElem ] }\n\n// set up TestGet() as the passed Get Function so ft_ArEdit() knows how\n// to edit the individual gets.\n\nbGetFunc := {| b, ar, nDim, nElem | TestGet( b, ar, nDim, nElem ) }\nSetColor( \"N/W, W/N, , , W/N\" )\nCLS\nft_ArEdit( 3, 5, 18, 75, ar, @nElem, aHeadings, aBlocks, bGetFunc )\n\nSTATIC FUNCTION TestGet( ... )\n   RETURN .T."
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/asum.txt",
    "NAME": "ft_ASum()",
    "CATEGORY": "Array",
    "ONELINER": "Sum the elements of an array",
    "SYNTAX": "ft_ASum( <aArray> [, <nStartIndex> [, <nEndIndex> ] ] ) --> nSum",
    "ARGUMENTS": "<aArray> is the array containing the elements to be summed.\n\n<nStartIndex> is the first array item to include,\ndefaults to first element.\n\n<nEndIndex> is the last array element to include,\ndefaults to all elements.",
    "RETURNS": "The sum of the elements of the array or the lengths of the elements.",
    "DESCRIPTION": "This function is to sum the elements of a numeric array or to sum the\nlengths of a character array.",
    "EXAMPLES": "LOCAL aSubTotals := { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }\n? ft_ASum( aSubTotals )         // Sum the Entire Array\n? ft_ASum( aSubTotals, 5 )      // Sum from the 5th Element On\n? ft_ASum( aSubTotals, , 10 )   // Sum the 1st 10 Elements\n? ft_ASum( aSubTotals, 5, 10 )  // Sum Elements 5-10"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/at2.txt",
    "NAME": "ft_At2()",
    "CATEGORY": "String",
    "ONELINER": "Find position of the nth occurrence of a substring",
    "SYNTAX": "ft_At2( <cSearch>, <cTarget> [, <nOccurs> [, <lCaseSens> ] ] ) --> nPos",
    "ARGUMENTS": "<cSearch> is the character substring to search for.\n\n<cTarget> is the character string to search.\n\n<nOccurs> is the occurrence of <cSearch> to look for,\n           defaults to 1.\n\n<lCaseSens> is a logical value denoting case sensitivity.\n           If .F., then search is _not_ sensitive to case,\n           defaults to .T.",
    "RETURNS": "The position of the nth occurrence of a substring",
    "DESCRIPTION": "This function will find the nth occurrence of a substring\nwithin a string.",
    "EXAMPLES": "LOCAL cSearch := \"t\"\nLOCAL cTarget := \"This is the day that the Lord has made.\"\n\n? ft_At2( cSearch, cTarget )          // --> 9\n? ft_At2( cSearch, cTarget, 2 )       // --> 17\n? ft_At2( cSearch, cTarget, 2, .F. )  // --> 9",
    "SEEALSO": "ft_FindITh(), ft_RAt2()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/at2.txt",
    "NAME": "ft_RAt2()",
    "CATEGORY": "String",
    "ONELINER": "Find position of the reversed nth occurrence of a substring",
    "SYNTAX": "ft_RAt2( <cSearch>, <cTarget> [, <nOccurs> [, <lCaseSens> ] ] ) --> nPos",
    "ARGUMENTS": "<cSearch> is the character substring to search for.\n\n<cTarget> is the character string to search.\n\n<nOccurs> is the occurrence of <cSearch> to look for,\n           defaults to 1.\n\n<lCaseSens> is a logical value denoting case sensitivity.\n           If .F., then search is _not_ sensitive to case,\n           defaults to .T.",
    "RETURNS": "The position of the nth occurrence of a reversed substring",
    "DESCRIPTION": "This function will find the nth occurrence of a reversed\nsubstring within a string.",
    "EXAMPLES": "LOCAL cSearch := \"t\"\nLOCAL cTarget := \"This is the day that the Lord has made.\"\n\n? ft_RAt2( cSearch, cTarget )          // --> 22\n? ft_RAt2( cSearch, cTarget, 2 )       // --> 20\n? ft_RAt2( cSearch, cTarget, 2, .F. )  // --> 20",
    "SEEALSO": "ft_FindITh(), ft_At2()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/bitclr.txt",
    "NAME": "ft_BitClr()",
    "CATEGORY": "String",
    "ONELINER": "Clear (reset) selected bit in a byte",
    "SYNTAX": "ft_BitClr( <cByte>, <nBitPos> ) --> cByte",
    "ARGUMENTS": "<cByte> is a character from `hb_BChar( 0 )` to `hb_BChar( 255 )`.\n\n<nBitPos> is a number from 0 to 7 conforming to standard\nright-to-left bit numbering convention and representing the\nposition of the bit within the byte.",
    "RETURNS": "Returns new byte, with designated bit cleared (reset).\nIf parameters are faulty, returns NIL.",
    "DESCRIPTION": "In effect, ANDs argument byte with a byte that has all bits set except\nthe target bit.  If bit is already clear (0), it remains clear.\nNote: Calls ft_IsBit() which is also in this Library.\n\nThis function is presented to illustrate that bit-wise operations\nare possible with Clipper code.  For greater speed, write `.c`\nversion and use the Clipper Extend system.",
    "EXAMPLES": "// This code would clear bit 4 in a byte represented by hb_BChar( 115 ):\nLOCAL cNewByte := ft_BitClr( hb_BChar( 115 ), 4 )\n? hb_BCode( cNewbyte )  // --> 99\n? cNewByte              // --> \"c\"\n\n// This code would clear bit 5 in the byte represented by letter \"A\":\n? ft_BitClr( \"A\", 5 )   // --> \"A\", since bit 5 already clear",
    "SEEALSO": "ft_BitSet(), ft_IsBit()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/bitset.txt",
    "NAME": "ft_BitSet()",
    "CATEGORY": "String",
    "ONELINER": "Set selected bit in a byte",
    "SYNTAX": "ft_BitSet( <cByte>, <nBitPos> ) --> cByte",
    "ARGUMENTS": "<cByte> is a character from `hb_BChar( 0 )` to `hb_BChar( 255 )`.\n\n<nBitPos> is a number from 0 to 7 conforming to standard right-to-left\nbit numbering convention and representing the position of the bit\nwithin the byte.",
    "RETURNS": "Returns new byte, with designated bit set.  If parameters are faulty,\nreturns NIL.",
    "DESCRIPTION": "In effect, ORs argument byte with a byte that has only the target bit\nset.  If bit is already set, it remains set.\nNote: Calls ft_IsBit() which is also in this Library.\n\nThis function is presented to illustrate that bit-wise operations\nare possible with Clipper code.  For greater speed, write `.c`\nversion and use the Clipper Extend system.",
    "EXAMPLES": "// This code would set bit 4 in a byte represented by hb_BChar( 107 ):\nLOCAL cNewbyte := ft_BitSet( hb_BChar( 107 ), 4 )\n? hb_BCode( cNewbyte )  // --> 123\n? cNewbyte              // --> \"{\"\n\n// This code would set bit 5 in the byte represented by the letter \"A\".\n? ft_BitSet( \"A\", 5 )   // --> \"a\", bit 5 set",
    "SEEALSO": "ft_BitClr(), ft_IsBit()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/blink.txt",
    "NAME": "ft_Blink()",
    "CATEGORY": "Menus/Prompts",
    "ONELINER": "Display a blinking message on the screen",
    "SYNTAX": "ft_Blink( <cMsg>, [ <nRow> ], [ <nCol> ] ) --> NIL",
    "ARGUMENTS": "<cMsg> is the string to blink.\n\n<nRow> is an optional screen row for `@...SAY`, default current.\n\n<nCol> is an optional screen col for `@...SAY`, default current.",
    "RETURNS": "NIL",
    "DESCRIPTION": "A quick way to blink a msg on screen in the CURRENT colors.\nRestores colors on return.",
    "EXAMPLES": "ft_Blink( \"WAIT\", 5, 10 )  // Blinks \"WAIT\" in current colors @ 5,10\n\n@ 5, 10 SAY \"WAIT - Printing Report\"\nft_Blink( \"...\" )          // Blink \"...\" after wait message..."
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/byt2bit.txt",
    "NAME": "ft_Byt2Bit()",
    "CATEGORY": "Conversion",
    "ONELINER": "Convert byte to string of 1's and 0's",
    "SYNTAX": "ft_Byt2Bit( <cByte> ) --> cBitPattern",
    "ARGUMENTS": "<cByte> is the byte to convert.",
    "RETURNS": "9-character string, consisting of 1's and 0's, representing bits 0\nthrough 7 of parameter byte, with space between bits 3 and 4.  Returns\nNIL if parameters are faulty.",
    "DESCRIPTION": "Can be used to show results of bit manipulation, both before and after.\nBinary representation follows right-to-left convention of bit position\nnumbering, 0 through 7.  Space between high and low nibbles for clarity\nand easy comparison to hexadecimal notation.\n\nThis function is presented to illustrate that bit-wise operations\nare possible with Clipper code.  For greater speed, write `.c`\nversion and use the Clipper Extend system.",
    "EXAMPLES": "// These three code lines perform a bitwise AND on bytes with values of\n// hb_BChar( 20 ) and hb_BChar( 36 ), and deliver the result as a string\n// in binary (bit) format.\n\n? ft_Byt2Bit( hb_BChar( 20 ) )  // --> \"00010100\"\n? ft_Byt2Bit( hb_BChar( 36 ) )  // --> \"00100100\"\n? ft_Byt2Bit( ft_ByteAnd( hb_BChar( 20 ), hb_BChar( 36 ) ) )  // --> \"00000100\"",
    "SEEALSO": "ft_Byt2Hex()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/byt2hex.txt",
    "NAME": "ft_Byt2Hex()",
    "CATEGORY": "Conversion",
    "ONELINER": "Convert byte to hexadecimal version of its binary value",
    "SYNTAX": "ft_Byt2Hex( cByte ) --> cHexValue",
    "ARGUMENTS": "<cByte> is the byte to convert.",
    "RETURNS": "Three-character string, consisting of two digits of hexadecimal\nnotation and letter `h` to signify hex.  Returns NIL if parameters are\nfaulty.",
    "DESCRIPTION": "Can be used to show results of bit manipulation, both before and after.\n\nThis function is presented to illustrate that bit-wise operations\nare possible with Clipper code.  For greater speed, write `.c`\nversion and use the Clipper Extend system.",
    "EXAMPLES": "// These three code lines perform a bitwise AND on bytes with values of\n// hb_BChar( 20 ) and hb_BChar( 36 ), and deliver the result as a string\n// in hexadecimal format, using 'h' to signify hexadecimal.\n\n? ft_Byt2Hex( hb_BChar( 20 ) )  // --> \"14h\"\n? ft_Byt2Hex( hb_BChar( 36 ) )  // --> \"24h\"\n? ft_Byt2Hex( ft_ByteAnd( hb_BChar( 20 ), hb_BChar( 36 ) ) )  // --> \"04h\"",
    "SEEALSO": "ft_Byt2Bit()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/byteand.txt",
    "NAME": "ft_ByteAnd()",
    "CATEGORY": "String",
    "ONELINER": "Perform bit-wise AND on two ASCII characters (bytes)",
    "SYNTAX": "ft_ByteAnd( <cByte1>, <cByte2> ) --> cByte",
    "ARGUMENTS": "<cByte1> and <cByte2> are characters from `hb_BChar( 0 )` to `hb_BChar( 255 )`.\nMay be passed in hb_BChar() form, as character literals, or as expressions\nevaluating to character values.",
    "RETURNS": "Returns resulting byte, as a string.  If parameters are faulty,\nreturns NIL.",
    "DESCRIPTION": "Can be used for any bit-wise masking operation.  In effect, this is a\nbit-by-bit AND operation.  Equivalent to AND assembler instruction.\n\nThis function is presented to illustrate that bit-wise operations\nare possible with Clipper code.  For greater speed, write `.c`\nversion and use the Clipper Extend system.",
    "EXAMPLES": "// This code would mask out the high nibble (four most significant bits)\n// of the byte represented by hb_BChar( 123 ) and leave the low nibble\n// bits as in the parameter byte.\n\nLOCAL cNewbyte := ft_ByteAnd( hb_BChar( 123 ), hb_BChar( 15 ) )\n? hb_BCode( cNewByte )  // --> 11\n? cNewByte              // --> non-printable character",
    "SEEALSO": "ft_ByteOr(), ft_ByteXor(), ft_ByteNot(), ft_ByteNeg()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/byteneg.txt",
    "NAME": "ft_ByteNeg()",
    "CATEGORY": "String",
    "ONELINER": "Perform bit-wise negation on an ASCII character",
    "SYNTAX": "ft_ByteNeg( <cByte> ) --> cNewByte",
    "ARGUMENTS": "<cByte> is a character from `hb_BChar( 0 )` to `hb_BChar( 255 )`.\nMay be passed in hb_BChar() form, as character literals, or as expressions\nevaluating to character values.",
    "RETURNS": "Returns resulting byte, as a string.  If parameters are faulty,\nreturns NIL.",
    "DESCRIPTION": "Can be used for bit-wise byte manipulation.  In effect, this is a\nbit-by-bit NEG (two's complement) operation.  Equivalent to NEG\nassembler instruction.\n\nThis function is presented to illustrate that bit-wise operations\nare possible with Clipper code.  For greater speed, write `.c`\nversion and use the Clipper Extend system.",
    "EXAMPLES": "// This code performs a bit-wise NEG on byte represented by hb_BChar( 32 ):\n\nLOCAL cNewByte := ft_ByteNot( hb_BChar( 32 ) )\n? hb_BCode( cNewByte )  // --> 224",
    "SEEALSO": "ft_ByteOr(), ft_ByteXor(), ft_ByteNot(), ft_ByteAnd()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/bytenot.txt",
    "NAME": "ft_ByteNot()",
    "CATEGORY": "String",
    "ONELINER": "Perform bit-wise NOT on an ASCII character (byte)",
    "SYNTAX": "ft_ByteNot( <cByte> ) --> cNewByte",
    "ARGUMENTS": "<cByte> is a character from `hb_BChar( 0 )` to `hb_BChar( 255 )`.\nMay be passed in hb_BChar() form, as character literals, or as expressions\nevaluating to character values.",
    "RETURNS": "Returns resulting byte, as a string.  If parameters are faulty,\nreturns NIL.",
    "DESCRIPTION": "Can be used for bitwise byte manipulation.  In effect, this is a\nbit-by-bit *not* (one's complement) operation.  Equivalent to the\n`NOT` assembler instruction.\n\nThis function is presented to illustrate that bit-wise operations\nare possible with Clipper code.  For greater speed, write `.c`\nversion and use the Clipper Extend system.",
    "EXAMPLES": "// This code performs a bitwise NOT on byte represented by hb_BChar( 32 ):\n\nLOCAL cNewByte := ft_ByteNot( hb_BChar( 32 ) )\n? hb_BCode( cNewByte )  // --> 223",
    "SEEALSO": "ft_ByteOr(), ft_ByteXor(), ft_ByteNeg(), ft_ByteAnd()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/byteor.txt",
    "NAME": "ft_ByteOr()",
    "CATEGORY": "String",
    "ONELINER": "Perform bit-wise OR on two ASCII characters (bytes)",
    "SYNTAX": "ft_ByteOr( <cByte1>, <cByte2> ) --> cNewByte",
    "ARGUMENTS": "<cByte1> and <cByte2> are characters from `hb_BChar( 0 )` to `hb_BChar( 255 )`.\nMay be passed in hb_BChar() form, as character literals, or as expressions\nevaluating to character values.",
    "RETURNS": "Returns resulting byte, as a string.  If parameters are faulty,\nreturns NIL.",
    "DESCRIPTION": "Can be used for bit-wise byte manipulation.  In effect, this is a\nbit-by-bit OR operation.  Equivalent to OR assembler instruction.\n\nThis function is presented to illustrate that bit-wise operations\nare possible with Clipper code.  For greater speed, write `.c`\nversion and use the Clipper Extend system.",
    "EXAMPLES": "// This code performs a bit-wise OR on two bytes represented\n// by hb_BChar( 20 ) and hb_BChar( 10 ):\n\nLOCAL cNewByte := ft_ByteOr( hb_BChar( 20 ), hb_BChar( 10 ) )\n? hb_BCode( cNewByte )  // --> 30\n? cNewByte              // --> non-printable character",
    "SEEALSO": "ft_ByteXor(), ft_ByteNot(), ft_ByteNeg(), ft_ByteAnd()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/bytexor.txt",
    "NAME": "ft_ByteXor()",
    "CATEGORY": "String",
    "ONELINER": "Perform bit-wise XOR on two ASCII characters (bytes)",
    "SYNTAX": "ft_ByteXor( <cByte1>, <cByte2> ) --> cNewByte",
    "ARGUMENTS": "<cByte1> and <cByte2> are characters from `hb_BChar( 0 )` to `hb_BChar( 255 )`.\nMay be passed in hb_BChar() form, as character literals, or as expressions\nevaluating to character values.",
    "RETURNS": "Returns resulting byte, as a string.  If parameters are faulty,\nreturns NIL.",
    "DESCRIPTION": "Can be used for bit-wise byte manipulation.  In effect, this is a\nbit-by-bit XOR operation.  Equivalent to XOR assembler instruction.\n\nThis function is presented to illustrate that bit-wise operations\nare possible with Clipper code.  For greater speed, write `.c`\nversion and use the Clipper Extend system.",
    "EXAMPLES": "// This code performs a bit-wise XOR on two bytes represented\n// by hb_BChar( 32 ) and hb_BChar( 55 ):\n\nLOCAL cNewByte := ft_ByteXor( hb_BChar( 32 ), hb_BChar( 55 ) )\n? hb_BCode( cNewByte )  // --> 23\n? cNewByte              // --> non-printable character",
    "SEEALSO": "ft_ByteOr(), ft_ByteNot(), ft_ByteNeg(), ft_ByteAnd()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/calendar.txt",
    "NAME": "ft_Calendar()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Display date/time calendar, find a date, return calendar data.",
    "SYNTAX": "ft_Calendar( [ <nRow> ], [ <nCol> ], [ <cColor> ], [ <lShadow> ] ,\n             [ <lShowHelp> ] ) --> aRetVal",
    "ARGUMENTS": "<nRow> is an optional screen row for calendar display,\n       default row 1.\n\n<nCol> is an optional screen col for calendar display,\n       default col 63.\n\n<cColor> is an optional color string for displayed messages,\n         default is bright white text over green background.\n\n<lShadow> is an optional logical variable. If true (.T.),\n          it uses ft_Shadow() to add a transparent shadow\n          to the display, default (.F.).\n\n<lShowHelp> is an optional logical variable. If true, uses\n            ft_XBox() to display  a four line help message\n            if the F1 key is pressed, default (.F.).\n",
    "RETURNS": "<aRetVal>  is an 8 element array containing date, month, day, year,\n            month (in character format), day of the week, Julian day\n            and current time.\n",
    "DESCRIPTION": "ft_Calendar() simply displays today's date, time and Julian\nday in a two line display with an optional box shadow. Cursor keys may\nbe used to page through the calendar by day, week, month or year\nincrements. Returns an 8 element array of calendar data:\n\n<table>\n Element  Value\n [ 1 ]    Date in current date format.\n [ 2 ]    Numeric month number.\n [ 3 ]    Numeric day number.\n [ 4 ]    Numeric year number.\n [ 5 ]    Month in character format.\n [ 6 ]    Day of the week in character format.\n [ 7 ]    Numeric Julian day.\n [ 8 ]    Current time in time format.\n</table>\n\nWARNING: ft_Calendar() uses ft_Shadow() and ft_XBox()\n         from the NanForum Toolkit!",
    "EXAMPLES": "LOCAL aRetVal := ft_Calendar( 10, 40, \"W+/RB\", .T., .T. )\n? aRetVal[ 1 ]  // --> 1991-04-20\n? aRetVal[ 2 ]  // -->   4\n? aRetVal[ 3 ]  // -->  20\n? aRetVal[ 4 ]  // -->  1991\n? aRetVal[ 5 ]  // --> \"April\"\n? aRetVal[ 6 ]  // --> \"Saturday\"\n? aRetVal[ 7 ]  // -->        110\n? aRetVal[ 8 ]  // --> \"12:45:20\"",
    "SEEALSO": "ft_DayOfYr()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/caplock.txt",
    "NAME": "ft_CapLock()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Determine and optionally change the status of CapLock key",
    "SYNTAX": "ft_CapLock([ <lNewSetting> ]) --> lCurrentSetting",
    "ARGUMENTS": "<lNewSetting> is optional and if supplied is the new setting\nfor the CapLock key.  Specify .T. to turn CapLock on, or .F. to\nturn it off.",
    "RETURNS": ".T. if CapLock is set, .F. if it isn't set.  The value returned\n represents the setting in effect prior to any changes that might\n by made by <lNewSetting>.",
    "DESCRIPTION": "This function is useful if you need to know or set the status of the\nCapLock key for some reason.",
    "EXAMPLES": "IF ft_CapLock()\n   ? \"CapLock is active\"\nENDIF",
    "SEEALSO": "ft_Alt(), ft_Ctrl(), ft_NumLock(), ft_PrtScr(), ft_Shift()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/chdir.txt",
    "NAME": "ft_ChDir()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Change the current directory",
    "SYNTAX": "ft_ChDir( <cDirName> ) --> nResult",
    "ARGUMENTS": "<cDirName> is the name of the desired directory.",
    "RETURNS": "0  if successful\n3  if path not found\n99 if invalid parameters passed",
    "DESCRIPTION": "Use this function if you prefer to change the active directory\ninstead of relying on the `SET PATH` command.",
    "EXAMPLES": "? ft_ChDir( \"mydir\" )\n? ft_ChDir( hb_DirSepToOS( \"/\" ) )\n? ft_ChDir( hb_DirSepToOS( \"./\" ) )\n? ft_ChDir( hb_DirSepToOS( \"../mydir\" ) )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/cint86.txt",
    "NAME": "ft_int86()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Execute a software interrupt",
    "SYNTAX": "ft_int86( <nInterruptNumber>, <aRegisterValues> ) --> lResult",
    "ARGUMENTS": "<nInterruptNumber> is the interrupt to execute.\n\n<aRegisterValues> is an array that contains values to be loaded\ninto the various CPU registers.  The correspondence between\nregisters and array elements is as follows:\n\n```\naElement[ 1 ]  ==  AX register\naElement[ 2 ]  ==  BX register\naElement[ 3 ]  ==  CX register\naElement[ 4 ]  ==  DX register\naElement[ 5 ]  ==  SI register\naElement[ 6 ]  ==  DI register\naElement[ 7 ]  ==  BP register\naElement[ 8 ]  ==  DS register\naElement[ 9 ]  ==  ES register\naElement[ 10 ] ==  Flags register\n```",
    "RETURNS": ".T. if all parameters valid and the function was able\n    to execute the desired interrupt.\n.F. if invalid parameters passed.  If you call this function in\n    protected mode, .F. may also be returned if an allocation\n    of low DOS memory fails.\n\nIn addition, the array elements will contain whatever values were in\nthe CPU registers immediately after the interrupt was executed.  If\neither of the string parameters were altered by the interrupt, these\nchanges will be reflected as well.",
    "DESCRIPTION": "It is occasionally useful to be able to call interrupts directly from\nClipper, without having to write a separate routine in C or ASM.  This\nfunction allows you that capability.\n\nGiven Clipper's high-level orientation, this function is necessarily\nsomewhat messy to use.  First, declare an array of ten elements to\nhold the eight values for the CPU registers and two string parameters.\nThen initialize the array elements with the values that you want the\nCPU registers to contain when the interrupt is executed.  You need not\ninitialize all the elements.  For example, if the interrupt requires\nyou to specify values for AX, DX, and DS, you would only need to\ninitialize elements 1, 4, and 8.\n\nOnce you have done the required register setup, call ft_int86(),\npassing the interrupt number and the register array as parameters.\nThe function will load the CPU with your specified values, execute the\ninterrupt, and then store the contents of the CPU registers back into\nyour array.  This will allow you to evaluate the results of the\ninterrupt.\n\nSome interrupt services require you to pass the address of a string in\na pair of registers.  This function is capable of handling these sorts\nof situations, but it will take a little work on your part.  If you need\nto pass a string that uses the DS register, store the string in element\n8;  if you need to pass a string that uses the ES register, store the\nstring in element 9.  ft_int86() will detect that you've supplied a\nstring instead of a numeric value and will behave accordingly.\n\nThat takes care of obtaining the segment portion of the pointer.  To\nspecify which register is to contain the offset, use the values REG_DS\nand REG_ES which are defined in the ftint86.ch file.  When one of these\nvalues is found in an array element, it alerts ft_int86() to use the\noffset portion of a pointer instead of a numeric value.  REG_DS tells\nft_int86() to use the offset of the string in element 8, while REG_ES\ntells ft_int86() to use the offset of the string in element 9.\n\nAll the CPU registers are sixteen bits in size.  Some, however, are\nalso split into two 8-bit registers.  This function is only capable of\nreceiving and returning registers that are 16 bits in size.  To split\na 16-bit register into two 8-bit values, you can use the\npseudo-functions HighByte() and LowByte(), contained in the .ch file.\n\nTo alter an 8-bit number so it will appear in the high-order byte of a\nregister when passed to the ft_int86() function, use the MakeHI()\npseudo-function contained in the .ch file.\n\nWhen run in real mode, this function is a shell for __ftint86(),\nwhich is written in assembler and does the actual work of executing\nthe interrupt.  __ftint86() is callable from C, so feel free to\nincorporate it into any C routines for which it might be useful.  The\nsource for __ftint86() can be found in the file AINT86.ASM.\n\nWhen run in protected mode, this function is a shell for cpmiInt86(),\nwhich is written in assembler and makes a DPMI call to drop into\nreal mode and execute the interrupt.  cpmiInt86() is also callable\nfrom C, so feel free to incorporate it into any C routines for which\nit might be useful.  cpmiInt86() is part of the CPMI API.  See the\nCPMI documentation for more information.",
    "EXAMPLES": "// FIXME\n// This example shows how to call the DOS \"create file\" service.  Take\n// special note of how to set up string parameters.\n\n#include \"ftint86.ch\"\n\nLOCAL aRegs[ 10 ]            // Declare the register array\naRegs[ AX ] := makehi( 60 )  // DOS service, create file\naRegs[ CX ] := 0             // Specify file attribute\n\n// Pay attention here, this is crucial.  Note how to set up the string\n// so it appears in DS:DX.\n\naRegs[ DS ] := \"my_file.ext\"\naRegs[ DX ] := REG_DS\nft_int86( 33, aRegs )        // Make the call to the DOS interrupt\n\n\n// This example shows how to call the DOS \"get current directory\"\n// service.  This one also uses a string parameter, but note that it\n// uses a different offset register.\n\n#include \"ftint86.ch\"\n\nLOCAL aRegs[ 10 ]\naRegs[ AX ] := makehi( 71 )\naRegs[ DX ] := 0           // Choose default drive\n\n// This service requires a 64-byte buffer whose address is in DS:SI.  DOS\n// will fill the buffer with the current directory.\n\naRegs[ DS ] := Space( 64 )\naRegs[ SI ] := REG_DS\nft_int86( 33, aRegs )\n\n? aRegs[ DS ]       // Display the directory name\n\n\n// For the sake of completeness, here's an example that doesn't use a\n// string.  This one changes the video mode.\n\n#include \"ftint86.ch\"\n\nLOCAL aRegs[ 10 ]\n\naRegs[ AX ] := 16          // Choose hi-res graphics\nft_int86( 16, aRegs )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/clrsel.txt",
    "NAME": "ft_ClrSel()",
    "CATEGORY": "Menus/Prompts",
    "ONELINER": "User Selectable Color Routine",
    "SYNTAX": "ft_ClrSel( <aClrData>, [ <lClrMode> ], [ <cTestChr> ]  --> aClrData",
    "ARGUMENTS": "<aClrData> is an array of subarrays, with each subarray containing\n   information about the color settings.\n\n   The subarray has the following structure:\n\n   [ 1 ] cName    is the name of this color setting i.e. \"Pick List\"\n            Maximum length is 20 bytes\n\n   [ 2 ] cClrStr  is the current color string\n            Default is \"W/N,N/W,N/N,N/N,N/W\"\n\n            If Setting type is \"M\" (Menu) the colors are...\n               1.  Prompt Color\n               2.  Message Color\n               3.  HotKey Color\n               4.  LightBar Color\n               5.  LightBar HotKey Color\n\n            Note: While there are many ways to code the individual\n               color combinations,  they should be in the same\n               format that gets returned from SetColor(), so\n               the defaults can be found in the color palette.\n\n               foreground [+] / background [*]\n               i.e. \"GR+/BG*, N/W*, N+/N, , W/N\"\n\n   [ 3 ] cType  is the type of color setting\n            Default is \"W\" (Window)\n\n               T = Title     Only 1 color element\n               D = Desktop   Background color and character\n               M = Menu      For ft_MenuTo() style menus\n               W = Window    Windows with radio buttons\n               G = Get       For use with `@ SAY...`\n               B = Browse    For TBrowse() and *dbEdit()\n               A = AChoice   Pick-lists etc...\n\n            W/G/B/A are functionally the same but will provide\n            a more appropriate test display.\n\n   [ 4 ] cFillChar  is the character (for desktop background only)\n            Default is \"\"\n\n\n<lClrMode>   .T.  use color palette\n            .F.  use monochrome palette\n\n            Default is the IsColor() setting\n\n<cTestChr>  2 Byte character string for color test display\n\n            Default is \"\"\n",
    "RETURNS": "An array identical to the one passed, with new selected colors",
    "DESCRIPTION": "This function allows users to select their own color combinations\nfor all the different types of screen I/O in a typical application.\nThis facilitates an easy implementation of Ted Means' replacement\nof the `@..PROMPT`/`MENU TO` found in the NanForum Toolkit.  If you are\nnot using ft_MenuTo(), you can specify `\"A\"` for setting type and have\na normal color string returned.",
    "EXAMPLES": "LOCAL aClrs\nLOCAL lColor := IsColor()\n\nSet( _SET_SCOREBOARD, .F. )\nSetBlink( .F. )       // Allow bright backgrounds\n\n// .... a typical application might have the following different settings\n//      normally these would be stored in a .dbf/.dbv\naClrs := { ;\n   { \"Desktop\",        \"N/BG\",                          \"D\", \"\" }, ;\n   { \"Title\",          \"N/W\",                           \"T\"      }, ;\n   { \"Top Menu\",       \"N/BG,N/W,W+/BG,W+/N,GR+/N\",     \"M\"      }, ;\n   { \"Sub Menu\",       \"W+/N*,GR+/N*,GR+/N*,W+/R,G+/R\", \"M\"      }, ;\n   { \"Standard Gets\",  \"W/B,  W+/N,,, W/N\",             \"G\"      }, ;\n   { \"Nested Gets\",    \"N/BG, W+/N,,, W/N\",             \"G\"      }, ;\n   { \"Help\",           \"N/G,  W+/N,,, W/N\",             \"W\"      }, ;\n   { \"Error Messages\", \"W+/R*,N/GR*,,,N/R*\",            \"W\"      }, ;\n   { \"Database Query\", \"N/BG, N/GR*,,,N+/BG\",           \"B\"      }, ;\n   { \"Pick List\",      \"N/GR*,W+/B,,, BG/GR*\",          \"A\"      } }\n\naClrs := ft_ClrSel( aClrs, lColor )\n\n? hb_ValToExp( aClrs )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/cntryset.txt",
    "NAME": "ft_SetCentury()",
    "CATEGORY": "Environment",
    "ONELINER": "Check/Set the CENTURY Setting",
    "SYNTAX": "ft_SetCentury( [ <lNewSetState> ] ) --> lOldState",
    "ARGUMENTS": "<lNewSetState> - Boolean to Set CENTURY\n                 .F. - Toggle CENTURY off\n                 .T. - Toggle CENTURY on\n                 If not specified, leave CENTURY as is",
    "RETURNS": "The state of the CENTURY setting upon entry to the routine",
    "DESCRIPTION": "This function returns the state (ON/OFF, TRUE/FALSE) of the CENTURY\nand optionally sets it ON or OFF.",
    "EXAMPLES": "? ft_SetCentury()       // Get current CENTURY Setting\n\n? ft_SetCentury( .T. )  // Get the current CENTURY Setting\n                        // and turn it on (set it to TRUE)\n\n? ft_SetCentury( .F. )  // Get the current CENTURY Setting\n                        // and turn it off (set it to FALSE)"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/color2n.txt",
    "NAME": "ft_Color2N()",
    "CATEGORY": "String",
    "ONELINER": "Returns the numeric complement of a Clipper color string",
    "SYNTAX": "ft_Color2N( <cColor> ) --> nValue",
    "ARGUMENTS": "<cColor> is a Clipper color string",
    "RETURNS": "The numeric complement of a color string or 0 if passed color\nis invalid.",
    "DESCRIPTION": "This function is useful when calling other functions that expect\na numeric color parameter.  It is often more convenient to pass\na converted color string than having to calculate or look up the\ncorresponding number.",
    "EXAMPLES": "LOCAL nColor\n\n? nColor := ft_Color2N( \"gr+/b\" )  // --> 30\n\nft_SetAttr( 0, 0, 10, 10, nColor )",
    "SEEALSO": "ft_N2Color()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/ctrl.txt",
    "NAME": "ft_Ctrl()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Determine status of the Ctrl key",
    "SYNTAX": "ft_Ctrl() --> lValue",
    "ARGUMENTS": "None",
    "RETURNS": ".T. if Ctrl key is pressed, .F. if otherwise.",
    "DESCRIPTION": "This function is useful for times you need to know whether or not\nthe Ctrl key is pressed, such as during a MemoEdit().",
    "EXAMPLES": "IF ft_Ctrl()\n   @ 0, 0 SAY \"Ctrl\"\nELSE\n   @ 0, 0 SAY \"    \"\nENDIF",
    "SEEALSO": "ft_CapLock(), ft_NumLock(), ft_PrtScr(), ft_Shift(), ft_Alt()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/d2e.txt",
    "NAME": "ft_D2E()",
    "CATEGORY": "Conversion",
    "ONELINER": "Convert decimal to scientific notation",
    "SYNTAX": "ft_D2E( <nDec>, <nPrecision> ) --> cNumE",
    "ARGUMENTS": "<nDec>         Decimal number to convert\n\n<nPrecision>   Number of decimal places in result.\n               Defaults to 6 decimal places.",
    "RETURNS": "<cNumE>        A string representing a number in\n               scientific notation",
    "DESCRIPTION": "Given a decimal number and the desired precision,\na string representing the equivalent in scientific\nnotation is returned.",
    "EXAMPLES": "? ft_D2E( 12.345, 2 )      // --> 1.23E1\n? ft_D2E( -12.345, 3 )     // --> -1.235E1\n? ft_D2E( 0.00000543, 2 )  // --> 5.43E-6",
    "SEEALSO": "ft_E2D()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/datecnfg.txt",
    "NAME": "ft_DateCnfg()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Set beginning of year/week for ft_*() date functions",
    "SYNTAX": "ft_DateCnfg( [ <cFYStart> ], [ <nDow> ] ) --> aDateInfo",
    "ARGUMENTS": "<cFYStart> is a character date string in the user's system date\nformat, i.e., the same as the user would enter for CToD().  If\nthis argument is NIL, the current value is unchanged.\n\nNote: The year portion of the date string must be present and\nbe a valid year; however, it has no real meaning.\n\n<nDow> is a number from 1 to 7 (1 = Sunday) indicating the\ndesired start of a work week.  If this argument is NIL,\nthe current value is unchanged.\n",
    "RETURNS": "A 2-element array containing the following information:\n\n aDateInfo[ 1 ] - an ANSI date string indicating the beginning\n                  date of the year.  Only the month and day are\n                  meaningful.\n\n aDateInfo[ 2 ] - the number of the first day of the week\n                  (1 = Sunday)\n",
    "DESCRIPTION": "ft_DateCnfg() is called internally by many of the date functions\nin the library to determine the beginning of year date and\nbeginning of week day.\n\nThe default beginning of the year is January 1st and the default\nbeginning of the week is Sunday (day 1).  Either or both of these\nsettings may be changed by calling ft_DateCnfg() with the proper\narguments.  They will retain their values for the duration of the\nprogram or until they are changed again by a subsequent call to\nft_DateCnfg().\n\nIt is not necessary to call ft_DateCnfg() unless you need to\nchange the defaults.\n\nft_DateCnfg() affects the following library functions:\n\n  ft_Week()       ft_AcctWeek()       ft_DayToBoW()\n  ft_Month()      ft_AcctMonth()      ft_DayOfYr()\n  ft_Qtr()        ft_AcctQtr()        ft_AcctAdj()\n  ft_Year()       ft_AcctYear()",
    "EXAMPLES": "Set( _SET_DATEFORMAT, \"yyyy-mm-dd\" )\n\n// Configure library date functions to begin year on July 1st.\nft_DateCnfg( \"1980-07-01\" )  // year is insignificant\n\nSET DATE TO AMERICAN  // System date format: American\n? hb_ValToExp( ft_DateCnfg() )                 // --> { \"1980.01.01\", 1 }  (Sun)\n? hb_ValToExp( ft_DateCnfg( \"07/01/80\" ) )     // --> { \"1980.07.01\", 1 }  (Sun)\n? hb_ValToExp( ft_DateCnfg( \"07/01/80\", 2 ) )  // --> { \"1980.07.01\", 2 }  (Mon)\n? hb_ValToExp( ft_DateCnfg( , 2 ) )            // --> { \"1980.01.01\", 2 }  (Mon)\n\nSET DATE TO BRITISH  // System date format: British\n? hb_ValToExp( ft_DateCnfg( \"01/07/80\", 2 ) )  // --> { \"1980.07.01\", 2 }  (Mon)",
    "SEEALSO": "ft_AcctAdj()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/dayofyr.txt",
    "NAME": "ft_DayOfYr()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Return calendar, fiscal or accounting day data",
    "SYNTAX": "ft_DayOfYr( [ <dGivenDate> ], [ <nDayNum> ], [ <lIsAcct> ] )\n       --> aDateInfo",
    "ARGUMENTS": "<dGivenDate> is any valid date in any valid format.  Defaults\nto current system date if not supplied.\n\n<nDayNum> is a number from 1 to 371, signifying a day of a year.\nDefaults to current day if not supplied.\n\n<lIsAcct> is a logical which specifies the type of year to base\nthe return value on:  .F. = calendar or fiscal year,\n.T. = accounting year.",
    "RETURNS": "A three element array containing the following data:\n\n   If <nDayNum> is specified:\n\n   aDateInfo[ 1 ] - The date of the specified day number\n   aDateInfo[ 2 ] - The beginning date of the year\n   aDateInfo[ 3 ] - The ending date of the year\n\n   If <nDayNum> is not specified:\n\n   aDateInfo[ 1 ] - The year and day as a character string \"YYYYDDD\"\n   aDateInfo[ 2 ] - The beginning date of the year\n   aDateInfo[ 3 ] - The ending date of the year",
    "DESCRIPTION": "ft_DayOfYr() returns an array containing data about a day in the\ncalendar or fiscal year containing the given date.\n\nThe beginning of year date defaults to January 1st but may be\nchanged with ft_DateCnfg().",
    "EXAMPLES": "LOCAL aDateInfo\n\naDateInfo := ft_DayOfYr( 0d19910331 )\n? aDateInfo[ 1 ]  // --> 1991090     (90th day of year 1991)\n? aDateInfo[ 2 ]  // --> 1991-01-01\n? aDateInfo[ 3 ]  // --> 1991-12-31\n\naDateInfo := ft_DayOfYr( , 90 )  // assume current date is 3/31/91\n? aDateInfo[ 1 ]  // --> 1991-03-31  (90th day of year)\n? aDateInfo[ 2 ]  // --> 1991-01-01\n? aDateInfo[ 3 ]  // --> 1991-12-31\n\naDateInfo := ft_DayOfYr( , 90, .T. )\n? aDateInfo[ 1 ]  // --> 1991-03-29  (90th day of accounting year)\n? aDateInfo[ 2 ]  // --> 1990-12-30  (1st day of accounting year)\n? aDateInfo[ 3 ]  // --> 1991-12-28  (last day of accounting year)",
    "SEEALSO": "ft_DateCnfg()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/daytobow.txt",
    "NAME": "ft_DayToBoW()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Calculate no. of days between date and beginning of week",
    "SYNTAX": "ft_DayToBoW( [ <dGivenDate> ] ) --> nDays",
    "ARGUMENTS": "<dGivenDate> is any valid date in any valid date format.\nDefaults to current date if not supplied.",
    "RETURNS": "A positive number of days to beginning of week, range 0 to 6.",
    "DESCRIPTION": "ft_DayToBoW() returns the number of days to the beginning of the\nweek.  Normally this will be one less than the value that\nwould be returned by the Clipper function DoW(), unless the\nday for the beginning of the week has been changed with\nft_DateCnfg().",
    "EXAMPLES": "LOCAL dDate := 0d19900915\n\n? DoW( dDate )          // --> 7\n? CDoW( dDate )         // --> \"Saturday\"\n? ft_DayToBoW( dDate )  // --> 6\n\n// change beginning of week to Friday (yeah!)\nft_DateCnfg( , 6 )\n? DoW( dDate )          // --> 7\n? CDoW( dDate )         // --> \"Saturday\"\n? ft_DayToBoW( dDate )  // --> 1",
    "SEEALSO": "ft_DateCnfg(), ft_AcctWeek(), ft_Week()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/dectobin.txt",
    "NAME": "ft_Dec2Bin()",
    "CATEGORY": "Conversion",
    "ONELINER": "Convert decimal to binary",
    "SYNTAX": "ft_Dec2Bin( <nNum> ) --> cBinaryNumber",
    "ARGUMENTS": "<nNum> is the numeric expression to be converted.",
    "RETURNS": "A character string representing <nNum> in binary format.",
    "DESCRIPTION": "This function can be used in conjunction with any bit-wise\noperations.",
    "EXAMPLES": "? ft_Dec2Bin( 255 )  // --> \"11111111\"\n? ft_Dec2Bin( 2 )    // --> \"00000010\""
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/default.txt",
    "NAME": "ft_Default()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Retrieve and optionally change the current default drive",
    "SYNTAX": "ft_Default( [ <cDrive> ] ) --> cDrive",
    "ARGUMENTS": "<cDrive> is optional, and if specified is the new default drive.",
    "RETURNS": "The current default drive.  If a change of default drive is requested,\nthe return value is the drive _after_ the change is made.  This allows\nyou to make sure you specified a valid drive (i.e. if you attempt to\nchange the default drive, and the function returns a different drive\nletter than the one you specified, then the drive does not exist).",
    "DESCRIPTION": "Useful any time you need to know or change the default drive.",
    "EXAMPLES": "LOCAL cDrive := ft_Default()  // Get the current drive\nft_Default( \"C\" )             // Switch to drive C:\n\nIF ! ft_Default( \"E\" ) == \"E\"\n   ? \"Drive E: does not exist!\"\nENDIF"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/descendn.txt",
    "NAME": "ft_Descend()",
    "CATEGORY": "Conversion",
    "ONELINER": "Create a descending index key value",
    "SYNTAX": "ft_Descend( <exp> ) --> <value>",
    "ARGUMENTS": "<exp> is any expression of character, numeric, date, or logical type.",
    "RETURNS": "The inverse of <exp>",
    "DESCRIPTION": "This function is a replacement for CA-Cl*pper's Descend() function,\nwhich is known to produce memory corruption occasionally.",
    "EXAMPLES": "? ft_Descend( 1 )  // --> -1",
    "SEEALSO": "ft_XToY()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/dfile.txt",
    "NAME": "ft_DFSetup()",
    "CATEGORY": "File I/O",
    "ONELINER": "Set up parameters for ft_DispFile()",
    "SYNTAX": "ft_DFSetup( <cInFile>, <nTop>, <nLeft>, <nBottom>, <nRight>, ;\n         <nStart>, <nCNormal>, <nCHighlight>, <cExitKeys>,   ;\n         <lBrowse>, <nColSkip>, <nRMargin>, <nBuffSize> ) --> nResult",
    "ARGUMENTS": "<cInFile>     - text file to display (full path and filename)\n<nTop>        - upper row of window\n<nLeft>       - left col of window\n<nBottom>     - lower row of window\n<nRight>      - right col of window\n<nStart>      - line to place highlight at startup\n<nCNormal>    - normal text color     (numeric attribute)\n<nCHighlight> - text highlight color  (numeric attribute)\n<cExitKeys>   - terminating key list  (each byte of string is a\n                key code)\n<lBrowse>     - act-like-a-browse-routine flag\n<nColSkip>    - col increment for left/right arrows\n<nRMargin>    - right margin - anything to right is truncated\n<nBuffSize>   - size of the paging buffer",
    "RETURNS": "0 if successful, FError() code if not",
    "DESCRIPTION": "Note: make sure you allocate a buffer large enough to hold enough\ndata for the number of lines that you have in the window.  Use the\nfollowing formula as a guideline:\n\n   buffer size = (# of line) + 1 * RMargin\n\nThis is the smallest you should make the buffer.  For normal use,\n4096 bytes is recommended",
    "EXAMPLES": "#include \"inkey.ch\"\nLOCAL cKey\n\n@ 4, 9 TO 11, 71\n\nft_DFSetup( \"test.txt\", 5, 10, 10, 70, 1, 7, 15, ;\n   { \"A\", \"a\", \"B\", \"b\", K_F3 }, .T., 5, 132, 4096 )\n\ncKey := ft_DispFile()\n\nft_DFClose()\n\n@ 20, 0 SAY \"Key that terminated ft_DispFile() was: \" + \"[\" + cKey + \"]\"",
    "SEEALSO": "ft_DispFile(), ft_DFClose()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/dfile.txt",
    "NAME": "ft_DFClose()",
    "CATEGORY": "File I/O",
    "ONELINER": "Close file displayed by ft_DispFile()",
    "SYNTAX": "ft_DFClose() --> NIL",
    "ARGUMENTS": "None",
    "RETURNS": "NIL",
    "DESCRIPTION": "Closes the file opened by ft_DFSetup()",
    "EXAMPLES": "#include \"inkey.ch\"\nLOCAL cKey\n\n@ 4, 9 TO 11, 71\n\nft_DFSetup( \"test.txt\", 5, 10, 10, 70, 1, 7, 15, ;\n   { \"A\", \"a\", \"B\", \"b\", K_F3 }, .T., 5, 132, 4096 )\n\ncKey := ft_DispFile()\n\nft_DFClose()\n\n@ 20, 0 SAY \"Key that terminated ft_DispFile() was: \" + \"[\" + cKey + \"]\"",
    "SEEALSO": "ft_DFSetup(), ft_DispFile()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/diskfunc.txt",
    "NAME": "ft_DskSize()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Return the maximum capacity of a fixed disk",
    "SYNTAX": "ft_DskSize( [ <cDrive> ] ) --> nMaxCapacity",
    "ARGUMENTS": "<cDrive> is the fixed disk to query. If no drive is sent, the\noperation will be performed on the default drive. Send without\nthe `:`.",
    "RETURNS": "An integer representing the maximum disk capacity in bytes.",
    "DESCRIPTION": "Function utilizing ft_int86() to return Maximum Disk Size.\nUses ft_int86() through the internal function `_ftDiskInfo()`.",
    "EXAMPLES": "? ft_DskSize()       // Maximum capacity for default drive\n? ft_DskSize( \"D\" )  // Maximum capacity for drive D:"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/diskfunc.txt",
    "NAME": "ft_DskFree()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Return the amount of available disk space",
    "SYNTAX": "ft_DskFree( [ <cDrive> ] ) --> nSpaceAvail",
    "ARGUMENTS": "<cDrive> is the fixed disk to query. If no parameter is passed\nthe operation will be performed on the default drive.  Do not\ninclude the `:`.",
    "RETURNS": "Integer representing the available disk space in bytes.",
    "DESCRIPTION": "Function to return the available space on the passed\ndrive letter or the default drive if no drive is passed.\n\nUses ft_int86() through the internal function `_ftDiskInfo()`.",
    "EXAMPLES": "? ft_DskFree()  // --> free space on default drive."
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/dispc.txt",
    "NAME": "ft_DispFile()",
    "CATEGORY": "File I/O",
    "ONELINER": "Browse a text file",
    "SYNTAX": "ft_DispFile() --> cExitkey",
    "ARGUMENTS": "None",
    "RETURNS": "The ASCII keystroke that terminated ft_DispFile()",
    "DESCRIPTION": "This routine displays a text file within a defined window using as\nlittle memory as possible.  The text file to display has to be\npresent or an error value of 0 is returned (as a character.)\n\nAssumptions: The routine assumes that all lines are terminated\n             with a CR/LF sequence (0x0d and 0x0a).\n\nNote:        Make sure you allocate a buffer large enough to hold\n             enough data for the number of lines that you have\n             in the window.  Use the following formula as a\n             guideline - buffer size = (# of line) + 1 * RMargin\n             this is the smallest you should make the buffer and\n             for normal use I recommend 4096 bytes.\n\nCursor Keys: <Up>, <Down>    - moves the highlight line\n             <Left>, <Right> - moves the window over <nColSkip> col's\n             <Home>          - moves the window to the far left\n             <End>           - moves the window to the <nRMargin> column\n             <PgUp>, <PgDn>  - moves the highlight one page\n             <Ctrl+PgUp>     - moves the highlight to the file top\n             <Ctrl+PgDn>     - moves the highlight to the file bottom\n             <Ctrl+Right>    - moves the window 16 col's to the right\n             <Ctrl+Left>     - moves the window 16 col's to the left\n\n             <Esc>, <Return> - terminates the function\n\n             All other keys are ignored unless they are specified\n             within <cExitKeys> parameter.  This list will tell the\n             routine what keys terminate the function.  Special\n             keys must be passed by a unique value and that value\n             can be found by looking in the dhkey.h file.",
    "EXAMPLES": "#include \"inkey.ch\"\nLOCAL cKey\n\n@ 4, 9 TO 11, 71\n\nft_DFSetup( \"test.txt\", 5, 10, 10, 70, 1, 7, 15, ;\n   { \"A\", \"a\", \"B\", \"b\", K_F3 }, .T., 5, 132, 4096 )\n\ncKey := ft_DispFile()\n\nft_DFClose()\n\n@ 20, 0 SAY \"Key that terminated ft_DispFile() was: \" + \"[\" + cKey + \"]\"",
    "SEEALSO": "ft_DFSetup(), ft_DFClose()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/dispmsg.txt",
    "NAME": "ft_DispMsg()",
    "CATEGORY": "Menus/Prompts",
    "ONELINER": "Display a message and optionally waits for a key-press",
    "SYNTAX": "ft_DispMsg( <aMessageArray>, [ <cKey2Check> ],\n            [ <nTopBoxRow> ], [ <nLeftBoxColumn> ],\n            [ <cnBoxType> ], [ <lShadow> ] ) --> lKeyMatch",
    "ARGUMENTS": "<aMessageArray> is a multidimensional array of messages to be\ndisplayed and the color attributes for each message.\n\nThe first dimension of the array contains one or more elements,\neach representing one line in the message box, up to the maximum\nnumber of rows on the screen.\n\nWithin each line of the message individual characters or groups\nof characters may be delimited with braces `[]`.  The braces will\nbe stripped out and the character(s) inside those braces will be\nhighlighted.\n\nThe second dimension of the array contains a color attribute for\nthe corresponding element in dimension one, plus one additional\nelement for the color of the box border.  Dimension two will\nalways contain one more element than dimension one.  If an\nattribute is omitted, the last color selected will be used.\n\n<cKey2Check> is a character string of one or more keys to check\nfor.  If omitted, the message is displayed and control is returned\nto the calling procedure.  If one character is specified,\nft_DispMsg() waits for one key-press, restores the screen and\nreturns.  If multiple characters are specified, ft_DispMsg()\nremains in a loop until one of the specified keys has been\npressed, then restores the screen and returns.\n\n<nTopBoxRow> is the upper row for the message box.  If omitted, the\nbox is centered vertically.\n\n<nLeftBoxColumn> is the leftmost column for the box.  If omitted, the\nbox is centered horizontally.\n\n<cnBoxType> is a string of characters or a variable for the box\nborder.  See the DispBox() function.  If omitted, a double box is\ndrawn.\n\n<lShadow> is a logical variable.  If true (.T.) or omitted, it\nuses ft_Shadow() to add a transparent shadow to the box.  If\nfalse (.F.), the box is drawn without the shadow.",
    "RETURNS": "If <cKey2Check> is not specified, ft_DispMsg() will return false\n(.F.).\n\nIf <cKey2Check> is a one-character string, ft_DispMsg() will return\ntrue (.T.) if the user presses that key, or false (.F.) if any\nother key is pressed.\n\nIf <cKey2Check> consists of multiple characters, it will lock the\nuser in a loop until one of those keys are pressed and return the\nInkey() value of the key-press.",
    "DESCRIPTION": "ft_DispMsg() is a multi-purpose pop-up for user messages.\nMultiple lines may be displayed, each with a different attribute.\nThe box will be automatically centered on the screen, or the row\nand/or column can be specified by the programmer.  It also centers\neach line of the message within the box.",
    "EXAMPLES": "// The following example displays a simple two-line message\n// and returns immediately to the calling routine.\n\nft_DispMsg( { { \"Printing Report\", ;\n   \"Press <Esc> To Interrupt\" }, ;\n   { \"W+/B*\", \"W/B\", \"GR+/B\" } } )\n\n// The next example displays a message and waits for a key press.\n\nft_DispMsg( { { \"Press <D> To Confirm Deletion\", ;\n   \"Or Any Other Key To Abort\" }, ;\n   { \"W+/B\", \"W+/B\", \"GR+/B\" } }, ;\n   \"D\" )\n\n// The next example displays a one-line message centered on row 5\n// and returns to the calling procedure.\n\nft_DispMsg( { { \"Please Do Not Interrupt\" }, ;\n   { \"W+/B\", \"GR+/B\" } }, ;\n   , 5, )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/dosver.txt",
    "NAME": "ft_DosVer()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Return the current DOS major and minor version as a string",
    "SYNTAX": "ft_DosVer() --> cVersion",
    "ARGUMENTS": "None",
    "RETURNS": "A character string with the major version number first, a\nperiod (\".\"), then the minor version number (e.g., \"3.30\")",
    "DESCRIPTION": "ft_DosVer() invokes DOS interrupt 21h, service 30 in order to\nreturn the current DOS version.  It does this by setting up\nan array corresponding to machine registers and then calling\nthe toolkit function ft_int86().\n\nIt returns a character string corresponding to the DOS\nversion, as follows:  The major version, a period (\".\"), then\nthe minor version.",
    "EXAMPLES": "? \"OS version:\", ft_DosVer()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/e2d.txt",
    "NAME": "ft_E2D()",
    "CATEGORY": "Conversion",
    "ONELINER": "Convert scientific notation string to a decimal",
    "SYNTAX": "ft_E2D( <cNumE> ) --> nDec",
    "ARGUMENTS": "<cNumE>   Scientific notation string to convert",
    "RETURNS": "<nDec>    Decimal number",
    "DESCRIPTION": "Given a string in the format `x.yEz`, the decimal\nequivalent is returned.",
    "EXAMPLES": "? ft_E2D( \"1.23E1\" )    // --> 12.3\n? ft_E2D( \"-1.235E1\" )  // --> -12.35\nSet( _SET_DECIMALS, 6 )\n? ft_E2D( \"5.43E-6\" )   // --> 0.00000543",
    "SEEALSO": "ft_D2E()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/easter.txt",
    "NAME": "ft_Easter()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Return the date of Easter",
    "SYNTAX": "ft_Easter( <xYear> ) --> dEdate",
    "ARGUMENTS": "<xYear> can be a character, date or numeric describing the year\nfor which you wish to receive the date of Easter.",
    "RETURNS": "The actual date that Easter occurs.",
    "DESCRIPTION": "Returns the date of Easter for any year after 1582 up to Clipper's\nlimit which the manual states is 9999, but the Guide agrees with\nthe actual imposed limit of 2999.\n\nThis function can be useful in calendar type programs that indicate\nwhen holidays occur.",
    "EXAMPLES": "? ft_Easter( 1990 )  // --> 1990-04-15"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/elapmil.txt",
    "NAME": "ft_ElapMin()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Return difference, in minutes, between two mil format times.",
    "SYNTAX": "ft_ElapMin( <cTime1>, <cTime2> ) --> nMinutes",
    "ARGUMENTS": "<cTime1, cTime2>  character strings of military form `hhmm`,\n    where 0 <= `hh` < 24.",
    "RETURNS": "<nMinutes>",
    "DESCRIPTION": "Finds the arithmetic difference between time two times\n(time 2 - time 1).\nIf time 2 is smaller than time 1, a _negative_ value is returned.",
    "EXAMPLES": "? ft_ElapMin( \"1718\", \"2040\" )  // --> 202\n? ft_ElapMin( \"2040\", \"1718\" )  // --> -202",
    "SEEALSO": "ft_ElTime(), ft_Mil2Min(), ft_Min2Mil()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/elapsed.txt",
    "NAME": "ft_Elapsed()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Return elapsed time between two days and/or times",
    "SYNTAX": "ft_Elapsed([ <dStart> ], [ <dEnd> ], ;\n           <cTimeStart>, <cTimeEnd>) --> aTimedata",
    "ARGUMENTS": "<dStart> is any valid date in any date format. Defaults to Date().\n\n<dEnd> is any valid date in any date format. Defaults to Date().\n\n<cTimeStart> is a valid Time string of the format `hh:mm:ss` where\nhh is hours in 24-hour format.\n\n<cTimeEnd> is a valid Time string of the format `hh:mm:ss` where\nhh is hours in 24-hour format.",
    "RETURNS": "A two-dimensional array containing elapsed time data.",
    "DESCRIPTION": "ft_Elapsed() calculates the elapsed time between two Date/Time events.\n\nIt returns an array which contains the following data:\n```\naRetVal[ 1 ][ 1 ] Integer Days      aRetVal[ 1 ][ 2 ] Total Days    (nn.nnnn)\naRetVal[ 2 ][ 1 ] Integer Hours     aRetVal[ 2 ][ 2 ] Total Hours   (nn.nnnn)\naRetVal[ 3 ][ 1 ] Integer Minutes   aRetVal[ 3 ][ 2 ] Total Minutes (nn.nnnn)\naRetVal[ 4 ][ 1 ] Integer Seconds   aRetVal[ 4 ][ 2 ] Total Seconds (nn)\n```",
    "EXAMPLES": "LOCAL aRetVal := ft_Elapsed( 0d19901128, 0d19901130, \"08:00:00\", \"12:10:30\" )\n\n// will return:\n? aRetVal[ 1 ][ 1 ]  // -->  2  (Days)\n? aRetVal[ 2 ][ 1 ]  // -->  4  (Hours)\n? aRetVal[ 3 ][ 1 ]  // --> 10  (Minutes)\n? aRetVal[ 4 ][ 1 ]  // --> 30  (Seconds)\n? aRetVal[ 1 ][ 2 ]  // -->    2.1740  (Days)\n? aRetVal[ 2 ][ 2 ]  // -->   52.1750  (Hours)\n? aRetVal[ 3 ][ 2 ]  // --> 3130.5000  (Minutes)\n? aRetVal[ 4 ][ 2 ]  // --> 187830     (Seconds)"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/eltime.txt",
    "NAME": "ft_ElTime()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Compute difference between times in hours, minutes, seconds.",
    "SYNTAX": "ft_ElTime( <cTime1>, <cTime2> ) --> cDiff",
    "ARGUMENTS": "<cTime1, cTime2>  character strings representing times in\n   `hh:mm:ss` format.",
    "RETURNS": "<cDiff>  character string representing time difference in\n   `hh:mm:ss` format.",
    "DESCRIPTION": "Return the absolute difference between two times in `hh:mm:ss` format\nin character hours, minutes and seconds (`hh:mm:ss`).",
    "EXAMPLES": "? ft_ElTime( \"22:40:12\", \"23:55:17\" )  // --> 01:15:05\n? ft_ElTime( \"23:55:17\", \"22:40:12\" )  // --> 01:15:05",
    "SEEALSO": "ft_ElapMin(), ft_Mil2Min(), ft_Min2Mil()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/findith.txt",
    "NAME": "ft_FindITh()",
    "CATEGORY": "String",
    "ONELINER": "Find the \"ith\" occurrence of a substring within a string",
    "SYNTAX": "ft_FindITh( <cCheckFor>, <cCheckIn>, <nWhichOccurrence> ;\n            [, <lIgnoreCase> ] ) --> nStringPosition",
    "ARGUMENTS": "<cCheckFor> is the string to search for.\n\n<cCheckIn> is the string to search.\n\n<nWhichOccurrence> is the number of the occurrence to find.\n\n<lIgnoreCase> is a logical indicating if the search is to be case\n   sensitive.  The default is no case sensitivity (.T.).",
    "RETURNS": "The position in the string <cCheckIn> of the \"ith\" occurrence of <cCheckFor>.",
    "DESCRIPTION": "This function finds the position in a string of the \"ith\" time another\nstring appears in it.",
    "EXAMPLES": "// Find the position in cMemoString of the 10th occurrence\n// of \"the\", case insensitive\nLOCAL cMemoString := hb_MemoRead( \"test.txt\" )\n\n? ft_FindITh( \"the\", cMemoString, 10 )",
    "SEEALSO": "ft_At2()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/firstday.txt",
    "NAME": "ft_FDay()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Return first day of the month",
    "SYNTAX": "ft_FDay( [ <dDateToChk> ] ) --> dFirstDay",
    "ARGUMENTS": "<dDateToChk> is a date within a month for which you want to find\nthe first date of that month.  If not passed or is an incorrect type,\ndefaults to current system date.",
    "RETURNS": "A Clipper date value representing the first date of the month.",
    "DESCRIPTION": "This function will return the first day of the month of the date\npassed, or the first day of the current month if no argument is\nsupplied.",
    "EXAMPLES": "? ft_FDay( 0d19900915 )  // --> 1990-09-01\n? ft_FDay()              // --> 1991-03-01  (current month)",
    "SEEALSO": "ft_LDay()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/floptst.txt",
    "NAME": "ft_FlopTst()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Test diskette drive status",
    "SYNTAX": "ft_FlopTst( <cDirectory|nDrive> ) --> nStatus",
    "ARGUMENTS": "<nDrive> is the diskette drive number, 0 = A:, 1 = B:",
    "RETURNS": "-1 - Wrong Parameters\n 0 - Drive Loaded and ready to read or write\n 1 - Drive Door Open or Diskette inserted upside down\n 2 - Diskette is unformatted\n 3 - Write protected\n 4 - Undetermined",
    "DESCRIPTION": "ft_FlopTst() is designed as a full replacement for ISDRIVE().  Where\nISDRIVE() returns just .T. or .F. depending if the diskette drive is\nready or not, ft_FlopTst() returns a numeric code designating the\ndiskette drive's status.\n\nft_FlopTst() is particularly useful in backup and restore programs\nthat need to test the floppy drive before writing/reading from a\nfloppy disk.\n\nNo testing has been performed on systems with more than 2 floppy\ndrives.  If the third drive is \"C\" and the fourth \"D\" then there\nshould be no problems.",
    "EXAMPLES": "LOCAL iStatus := ft_FlopTst( \"A:\" )\nDO CASE\nCASE iStatus == 1\n   ? \"The door to drive A is open.\"\nCASE iStatus == 2\n   ? \"The diskette in drive A is not formatted.\"\nCASE iStatus == 3\n   ? \"The diskette in drive A is write-protected.\"\nCASE iStatus == 4\n   ? \"Something is wrong with drive A, but I don't know what.\"\nENDCASE"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/ftattr.txt",
    "NAME": "ft_SaveAtt()",
    "CATEGORY": "Video",
    "ONELINER": "Save the attribute bytes of a specified screen region.",
    "SYNTAX": "ft_SaveAtt( <nTop>, <nLeft>, <nBottom>, <nRight> ) --> cAttributes",
    "ARGUMENTS": "<nTop>, <nLeft>, <nBottom>, and <nRight> define the screen region.",
    "RETURNS": "A character string containing the screen attribute bytes for the\nspecified region.  If the memory to store the return value could\nnot be allocated, the function returns NIL.",
    "DESCRIPTION": "This function is similar to Clipper's SaveScreen(), except that it only\nsaves the attribute bytes.  This is useful if you want to change the\nscreen color without affecting the text.\n\n<b>Internals Alert:</b>\n\nThis function calls the Clipper internal __gtMaxCol() to obtain the\nmaximum column value for the current video mode.  If you're too gutless\nto use internals, then this function isn't for you.",
    "EXAMPLES": "// Save attributes of row 4\n? hb_StrToHex( ft_SaveAtt( 4, 0, 4, MaxCol() ) )\n\n// Save attributes from middle of screen\n? hb_StrToHex( ft_SaveAtt( 10, 20, 14, 59 ) )",
    "SEEALSO": "ft_RestAtt()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/ftattr.txt",
    "NAME": "ft_RestAtt()",
    "CATEGORY": "Video",
    "ONELINER": "Restore the attribute bytes of a specified screen region.",
    "SYNTAX": "ft_RestAtt( <nTop>, <nLeft>, <nBottom>, <nRight>, <cAttributes> ) --> NIL",
    "ARGUMENTS": "<nTop>, <nLeft>, <nBottom>, and <nRight> define the screen region.\n<cAttributes> is a character string containing the attribute bytes\n              for the screen region.  This will most often be a string\n              previously returned by ft_SaveAtt(), but any character\n              string may be used (provided it is of the proper size).",
    "RETURNS": "NIL",
    "DESCRIPTION": "This function is similar to Clipper's RestScreen(), except that it only\nrestores the attribute bytes.  This is useful if you want to change the\nscreen color without affecting the text.\n\n<b>Internals Alert:</b>\n\nThis function calls the Clipper internals __gtSave() and __gtRest() to\nmanipulate the the screen image.  If you're too gutless to use\ninternals, then this function isn't for you.",
    "EXAMPLES": "// FIXME\nLOCAL cBuffer\n\n// Restore attributes of row 4\nft_RestAtt( 4, 0, 4, MaxCol(), cBuffer )\n\n// Restore attributes to middle of screen\nft_RestAtt( 10, 20, 14, 59, cBuffer )",
    "SEEALSO": "ft_SaveAtt()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/fttext.txt",
    "NAME": "ft_FUse()",
    "CATEGORY": "File I/O",
    "ONELINER": "Open or close a text file for use by the ft_F*() functions",
    "SYNTAX": "ft_FUse( [ <cFile> ] [, <nMode> ] ) --> nHandle | 0",
    "ARGUMENTS": "<cFile> is the text file you want to open.  If not specified,\nthe file currently open, if any, will be closed.\n\n<nMode> is the open mode for the file.  Please refer to the\ndiscussion of file open modes in fileio.ch for a list of allowable\nopen modes.  If not specified, the file will be opened with a mode\nof FO_READ + FO_SHARED.",
    "RETURNS": "If <cFile> is passed and the file is opened successfully, an\ninteger containing the text file's workarea.  If the file cannot be\nopened, 0 will be returned.  In this case, check the return value\nof ft_FError() for the cause of the error.\n\nIf ft_FUse() is called without any arguments, it will close the\ntext file in the current \"text area\" and return 0.\n\nIf a read error occurs ft_FError() will contain the error code.",
    "DESCRIPTION": "The ft_F*() file functions are for reading text files, that is,\nfiles where each line (record) is delimited by a CRLF/LF.\n\nEach file is opened in its own \"workarea\", similar to the concept\nuse by dbf files.  As provided, a maximum of 10 files (in 10\nworkareas) can be opened (assuming there are sufficient file\nhandles available).  That number may be increased by modifying\nthe #define TEXT_WORKAREAS in the C source code and recompiling.",
    "EXAMPLES": "#include \"fileio.ch\"\n\n? ft_FUse( \"test.txt\" )  // Open a text file for reading\n? ft_FUse( \"test.txt\", FO_READWRITE + FO_SHARED )  // Open a text file for reading and writing\n? ft_FUse()              // Close file",
    "SEEALSO": "ft_FUse(), ft_FSelect()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/fttext.txt",
    "NAME": "ft_FSelect()",
    "CATEGORY": "File I/O",
    "ONELINER": "Select a text file workarea",
    "SYNTAX": "ft_FSelect( [ <nNewArea> ] ) --> nPreviousArea",
    "ARGUMENTS": "<nNewArea> is the text file workarea to select.",
    "RETURNS": "The current selected text file area.",
    "DESCRIPTION": "This function selects a text file \"workarea\" from 1 to 10.  A\nfile may or may not be open in the selected area.\n\nPassing 0 for <nNewArea> selects the next available workarea,\nsimilar to Clipper's SELECT 0 command.  If no more workareas are\navailable the current workarea is not changed.\n\nEach file is opened in its own \"workarea\", similar to the concept\nused by dbf files.  As provided, a maximum of 10 files (in 10\nworkareas) can be opened (assuming there are sufficient file\nhandles available).  That number may be increased by modifying\nthe #define TEXT_WORKAREAS in the C source code and recompiling.\n\nAll the ft_F*() file functions operate on the file in the currently\nselected text file workarea.\n\nText file workareas are separate from and independent of Clipper's\ndatabase workareas.",
    "EXAMPLES": "LOCAL nFile1, nFile2\n\nft_FSelect( 1 )\nnFile1 := ft_FUse( \"test.txt\" )\n? ft_FLastRe()  // no. of lines in test.txt\n\nft_FSelect( 2 )\nnFile2 := ft_FUse( \"test.dbf\" )\n? ft_FLastRe()  // no. of lines in test.dbf",
    "SEEALSO": "ft_FUse()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/fttext.txt",
    "NAME": "ft_FGoTop()",
    "CATEGORY": "File I/O",
    "ONELINER": "Go to the first record in a text file",
    "SYNTAX": "ft_FGoTop() --> NIL",
    "ARGUMENTS": "None",
    "RETURNS": "NIL",
    "DESCRIPTION": "This function moves the record pointer to the first record\nin the currently selected text file workarea.\n\nA text file \"record\" is a line of text terminated by a CRLF/LF.",
    "EXAMPLES": "ft_FUse( \"test.txt\" )  // open text file\n\nDO WHILE ! ft_FEof()\n   ? ft_FReadLn()      // read thru file\n   ft_FSkip()\nENDDO\n\nft_FGoTop()            // go back to top\n\n? ft_FRecNo()          // 1",
    "SEEALSO": "ft_FSelect(), ft_FUse(), ft_FRecNo(), ft_FGoBot()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/fttext.txt",
    "NAME": "ft_FError()",
    "CATEGORY": "File I/O",
    "ONELINER": "Return the error code for a text file operation",
    "SYNTAX": "ft_FError() --> nErrorNo",
    "ARGUMENTS": "None",
    "RETURNS": "The DOS error code if one occurred.  See a reference on DOS error\ncodes for an explanation of what the code means.",
    "DESCRIPTION": "This function returns the DOS error code associated with a file\noperation on the currently selected text file.\n\nErrors could stem from any open, create, read or write operation,\namong others.",
    "EXAMPLES": "IF ft_FUse( \"test.txt\" ) == 0  // open text file\n   ? \"Error opening file 'test.txt', \" + ;\n      \"error code (\" + hb_ntos( ft_FError() ) + \")\"\nENDIF",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/fttext.txt",
    "NAME": "ft_FRecNo()",
    "CATEGORY": "File I/O",
    "ONELINER": "Return the current record number of a text file",
    "SYNTAX": "ft_FRecNo() --> nRecNo",
    "ARGUMENTS": "None",
    "RETURNS": "The current record number of a text file or 0 if no file is open.",
    "DESCRIPTION": "This function returns the current record number of the file open\nin the currently selected text file workarea.\n\nA text file \"record\" is a line of text terminated by a CRLF/LF.",
    "EXAMPLES": "ft_FUse( \"test.txt\" )  // open text file\n\nDO WHILE ! ft_FEof()\n   ? ft_FReadLn()      // read thru file\n   ft_FSkip()\nENDDO\n\nft_FGoTop()            // go back to top\n\n? ft_FRecNo()          // 1",
    "SEEALSO": "ft_FSelect(), ft_FUse(), ft_FGoTop(), ft_FGoBot()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/fttext.txt",
    "NAME": "ft_FGoBot()",
    "CATEGORY": "File I/O",
    "ONELINER": "Go to the last record in a text file",
    "SYNTAX": "ft_FGoBot() --> NIL",
    "ARGUMENTS": "None",
    "RETURNS": "NIL",
    "DESCRIPTION": "This function moves the record pointer to the last record of the\nfile in the currently selected text file workarea.\n\nIf a read error occurs ft_FError() will contain the error code.\n\nA text file \"record\" is a line of text terminated by a CRLF/LF.",
    "EXAMPLES": "// read last line\nft_FUse( \"test.txt\" )\nft_FGoBot()\n? ft_FReadLn()",
    "SEEALSO": "ft_FSelect(), ft_FUse(), ft_FGoTop(), ft_FRecNo(), ft_FReadLn()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/fttext.txt",
    "NAME": "ft_FSkip()",
    "CATEGORY": "File I/O",
    "ONELINER": "Move the record pointer to a new position in a text file",
    "SYNTAX": "ft_FSkip( [ <nLines> ] ) --> nLinesSkipped",
    "ARGUMENTS": "<nLines> is the number of lines to skip.  Defaults to 1 if\nnot specified.",
    "RETURNS": "The number of lines actually skipped.  If the file's EOF or\nBOF was encountered before <nLines> could be skipped, the\nreturn value will be less than <nLines>.",
    "DESCRIPTION": "This function moves the text file record pointer, similar to\nthe CLIPPER SKIP command.\n\nUse the return value to determine how many records were actually\nskipped, for example to write a custom skipper function for\nTBrowse-ing text files.\n\nIf a read error occurs ft_FError() will contain the error code.\n\nA text file \"record\" is a line of text terminated by a CRLF/LF.",
    "EXAMPLES": "// display each record of a text file\n\nft_FUse( \"test.txt\" )\nDO WHILE ! ft_FEof()\n   ? ft_FReadLn()\n   ft_FSkip()\nENDDO",
    "SEEALSO": "ft_FRecNo(), ft_FGoTop()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/fttext.txt",
    "NAME": "ft_FReadLn()",
    "CATEGORY": "File I/O",
    "ONELINER": "Read a line from the currently selected text file",
    "SYNTAX": "ft_FReadLn() --> cLine",
    "ARGUMENTS": "None",
    "RETURNS": "A string containing the current record in a text file.",
    "DESCRIPTION": "This function returns a line of text read from the file in the\ncurrently selected text file workarea.  Text lines are delimited\nwith a CRLF/LF.  The record pointer is not moved.\n\nCurrently the maximum record size is 4096 characters.  You may\nincrease the maximum record size by changing the value of\n`#define BUFFSIZE` in the C source and recompiling, however you should\nconsider the performance implications if you do (all read and writes\nuse this buffer size, including ft_FSkip()'s and ft_FGoto()'s).\n\nIf a read error occurs ft_FError() will contain the error code.\n\nA text file \"record\" is a line of text terminated by a CRLF/LF.",
    "EXAMPLES": "// display each record of a text file\n\nft_FUse( \"test.txt\" )\nDO WHILE ! ft_FEof()\n   ? ft_FReadLn()\n   ft_FSkip()\nENDDO",
    "SEEALSO": "ft_FUse(), ft_FWriteLn(), ft_FRecNo(), ft_FGoTop()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/fttext.txt",
    "NAME": "ft_FDelete()",
    "CATEGORY": "File I/O",
    "ONELINER": "Deletes a line from the currently selected text file",
    "SYNTAX": "ft_FDelete( [ <nLines> ] ) --> lSuccess",
    "ARGUMENTS": "<nLines> is the number of lines to be eliminated, beginning with\nthe current record position.\n\nIf <nLines> is omitted, the current record is deleted only.",
    "RETURNS": "TRUE if successful, otherwise check ft_FError() for error code.",
    "DESCRIPTION": "This function deletes one or several lines of text from the file\nin the currently selected text file workarea.  Text lines are\ndelimited with a CRLF/LF.  The record pointer is not moved,\nunless the deleted lines occur at the end of the file, in which\ncase ft_FRecNo() will equal ft_FLastRe() and ft_FEof()\nwill be set to TRUE.",
    "EXAMPLES": "// delete the next 4 lines from a file\nft_FUse( \"test.txt\" )\n? ft_FDelete( 4 )",
    "SEEALSO": "ft_FAppend(), ft_FRecNo(), ft_FInsert()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/fttext.txt",
    "NAME": "ft_FInsert()",
    "CATEGORY": "File I/O",
    "ONELINER": "Inserts a line in the currently selected text file",
    "SYNTAX": "ft_FInsert( [ <nLines> ] ) --> lSuccess",
    "ARGUMENTS": "<nLines> is the number of lines that should be inserted at the\ncurrent record position.\n\nIf <nLines> is omitted, one record is inserted.",
    "RETURNS": "<lSuccess> is TRUE if the insert succeeded, FALSE if not.  If\nfalse check the return value of ft_FError() for the reason.",
    "DESCRIPTION": "This function inserts a line of text in the file in the currently\nselected text file workarea.  Text lines are delimited with a\nCRLF/LF.\n\nThe record pointer is not moved.\n\nA text file \"record\" is a line of text terminated by a CRLF/LF.\nEach line inserted with this function will be empty.",
    "EXAMPLES": "// add a couple of blank lines of text to a file\nft_FUse( \"test.txt\" )\nft_FGoto( 10 )\n? ft_FInsert( 5 )",
    "SEEALSO": "ft_FAppend(), ft_FRecNo(), ft_FDelete(), ft_FLastRe()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/fttext.txt",
    "NAME": "ft_FAppend()",
    "CATEGORY": "File I/O",
    "ONELINER": "Appends a line to the currently selected text file",
    "SYNTAX": "ft_FAppend( [ <nLines> ] ) --> NIL",
    "ARGUMENTS": "<nLines> is the number of lines that should be appended to the\nend of the currently selected text file.\n\nIf <nLines> is omitted, one record is appended.",
    "RETURNS": "<lSuccess>.  If FALSE, check ft_FError() for the error code.",
    "DESCRIPTION": "This function appends a line of text to the file in the currently\nselected text file workarea.  Text lines are delimited with a\nCRLF/LF.  The record pointer is moved to the last appended\nrecord.\n\nMultiple lines may be appended with one call to ft_FAppend().\n\nA text file \"record\" is a line of text terminated by a CRLF/LF.\nEach line appended with this function will be empty.\n\nNOTE:  Occasionally a text file may contain a non-CRLF/LF terminated\nline, at the end of the file (\"stragglers\").  This function assumes\nthese stragglers to be the last line of the file, and begins\nappending the new lines after this line.  In other words, if the\nlast line in the text file is not terminated with a CRLF/LF prior\nto calling ft_FAppend(), the function will terminate that last line\nbefore appending any new lines.",
    "EXAMPLES": "// add a blank line of text to a file\nft_FUse( \"test.txt\" )\n\nft_FGoBot()\n? ft_FRecNo()\n\nft_FAppend()\n\nft_FGoBot()\n? ft_FRecNo()",
    "SEEALSO": "ft_FRecNo(), ft_FDelete(), ft_FInsert(), ft_FLastRe()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/fttext.txt",
    "NAME": "ft_FWriteLn()",
    "CATEGORY": "File I/O",
    "ONELINER": "Write a line to the currently selected text file",
    "SYNTAX": "ft_FWriteLn( <cData>, [ <lInsert> ] ) --> lSuccess",
    "ARGUMENTS": "<cData> is a string of data to write to the file at the current\n record position.\n\n<lInsert> is a logical indicating whether the contents\nof the current record are to be preserved, that is, if <lInsert>\nevaluates to .T., the a new record is inserted at the current\nposition.  The current record then is pushed down to ft_FRecNo()+1.\n\nIf <lInsert> is .F. or omitted, the current record is replaced by\n<cData>.",
    "RETURNS": "TRUE if successful, otherwise check ft_FError() for error code.",
    "DESCRIPTION": "This function writes a line of text to the file in the currently\nselected text file workarea.  Text lines are delimited with a\nCRLF/LF.  The record pointer is not moved.\n\nThe contents of the current record are updated to reflect the new\nnew line written, unless the Insert option is selected.\n\nWriting a null string has the effect of clearing the current line\nif in overstrike mode, else inserting a new line (same as\nft_FInsert()).\n\nA text file \"record\" is a line of text terminated by a CRLF/LF.",
    "EXAMPLES": "// write a line of text to a file\n\nft_FUse( \"test.txt\" )\n\nDO WHILE ! hb_LeftEqI( ft_FReadLn(), \"===\" ) .AND. ! ft_FEof()\n   ft_FSkip()\nENDDO\n\n? ft_FWriteLn( \"FILES=30\", ft_FEof() )",
    "SEEALSO": "ft_FReadLn(), ft_FRecNo(), ft_FInsert(), ft_FDelete()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/fttext.txt",
    "NAME": "ft_FLastRe()",
    "CATEGORY": "File I/O",
    "ONELINER": "Get the no. of records in the currently selected text file",
    "SYNTAX": "ft_FLastRe() --> nLastRecordNum",
    "ARGUMENTS": "None",
    "RETURNS": "An integer containing the number of records in the text file in\nthe currently selected text file workarea, or zero if no file\nis currently open in the workarea.",
    "DESCRIPTION": "This function returns the number of the last record in a text file.\n\nA text file \"record\" is a line of text terminated by a CRLF/LF.",
    "EXAMPLES": "ft_FUse( \"test.txt\" )\n\n? ft_FLastRe()",
    "SEEALSO": "ft_FUse(), ft_FRecNo()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/fttext.txt",
    "NAME": "ft_FEof()",
    "CATEGORY": "File I/O",
    "ONELINER": "Determine if end of text file has been encountered",
    "SYNTAX": "ft_FEof() --> lResult",
    "ARGUMENTS": "None",
    "RETURNS": ".T. if an attempt was made to skip past the last record of\nthe currently selected text file, otherwise .F.",
    "DESCRIPTION": "This function is similar to the CLIPPER Eof() function.\n\nA text file \"record\" is a line of text terminated by a CRLF/LF.",
    "EXAMPLES": "ft_FUse( \"test.txt\" )\n\n? ft_FEof()  // --> .F.\n\nft_FSkip()\n\n? ft_FEof()  // --> .T.",
    "SEEALSO": "ft_FUse(), ft_FSkip()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/fttext.txt",
    "NAME": "ft_FBof()",
    "CATEGORY": "File I/O",
    "ONELINER": "Determine if attempt to skip past beginning of text file",
    "SYNTAX": "ft_FBof() --> lResult",
    "ARGUMENTS": "None",
    "RETURNS": ".T. if an attempt was made to skip past the first record of\nthe currently selected text file, otherwise .F.",
    "DESCRIPTION": "This function is similar to the Clipper Bof() function.\n\nA text file \"record\" is a line of text terminated by a CRLF/LF.",
    "EXAMPLES": "ft_FUse( \"test.txt\" )\n\nft_FGoTop()\n\n? ft_FBof()  // --> .F.\n\nft_FSkip( -1 )\n\n? ft_FBof()  // --> .T.",
    "SEEALSO": "ft_FSkip(), ft_FEof(), ft_FGoTop()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/fttext.txt",
    "NAME": "ft_FGoto()",
    "CATEGORY": "File I/O",
    "ONELINER": "Move record pointer to specific record in a text file",
    "SYNTAX": "ft_FGoto( nLine ) --> NIL",
    "ARGUMENTS": "<nLine> is the record number to go to.",
    "RETURNS": "NIL",
    "DESCRIPTION": "This function moves the record pointer to a specific record\nin the file in the currently selected text file workarea.  If\nthe record number requested is greater than the number of records\nin the file, the record pointer will be positioned at the last\nrecord.\n\nInternally, the function operates differently depending on how\nyou invoke it.  Passing a value for <nLine> results in what\nis effectively a skip operation, which is fairly quick.  However\nif you pass 0 for <nLine>, e.g. `ft_FGoto( 0 )`, the function\ninternally goes to the top of the file, then skips down the\nrequired number of records.  Hence if your file is relatively\nlarge and the current record is a high number, you may see some\ndelay as `ft_FGoto( 0 )` skips through the file.\n\nA text file \"record\" is a line of text terminated by a CRLF/LF.",
    "EXAMPLES": "// read 5th line of text from file\n\nft_FUse( \"test.txt\" )\n\nft_FGoto( 5 )\n\n? ft_FReadLn()",
    "SEEALSO": "ft_FRecNo(), ft_FGoTop(), ft_FReadLn()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/gcd.txt",
    "NAME": "ft_GCD()",
    "CATEGORY": "Math",
    "ONELINER": "Calculate greatest common divisor of two numbers",
    "SYNTAX": "ft_GCD( <nNumber1>, <nNumber2> ) --> nGCD",
    "ARGUMENTS": "<nNumber1> is the first number to find the GCD of.\n\n<nNumber2> is the second number to find the GCD of.",
    "RETURNS": "The greatest common divisor of the 2 numbers, or 0 if either is 0.",
    "DESCRIPTION": "This function calculates the greatest common divisor between 2 numbers,\ni.e., the largest number that will divide into both numbers evenly.  It\nwill return zero (0) if either number is zero.",
    "EXAMPLES": "? ft_GCD( 10, 15 )   // --> 5\n? ft_GCD( 108, 54 )  // --> 54\n? ft_GCD( 102, 54 )  // --> 6\n? ft_GCD( 111, 17 )  // --> 1"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/getenvrn.txt",
    "NAME": "ft_GetE()",
    "CATEGORY": "Environment",
    "ONELINER": "Return the entire current environment",
    "SYNTAX": "ft_GetE( [ @<xReceiveVar> ] ) --> nNumStrings",
    "ARGUMENTS": "<xReceiveVar> is the variable to receive the environment data.\n\n<xReceiveVar> can be a character type variable, in which case\nthe function will place all environment strings in the variable\nseparated by carriage return/line feeds (`Chr( 13 ) + Chr( 10 )`).\n\n<xReceiveVar> can be an array type, in which case the function\nwill place each string in an array element.  The array MUST be\ndeclared with the proper number of elements prior to passing it\nto the function.  This can be done by calling ft_GetE() without\nparameters first to get the number of strings in the environment.\n\nNote that the argument MUST be passed by reference. Since arrays\nare by nature passed by reference, the \"@\" symbol is optional when\npassing an array.\n\nIf no argument is passed, ft_GetE() merely returns the number\nof strings in the environment.",
    "RETURNS": "ft_GetE() returns the total number of strings found in the\ncurrent program's environment.",
    "DESCRIPTION": "This function stores ALL of the current program's environment\nvariables in either a block of text lines or in an array.  It is\nuseful for looking at the entire environment at once, or recording\na snapshot of it to a file for later inspection, such as when a\nprogram error occurs.  If the value of _one specific_ variable is\ndesired, use Clipper's built-in GetE() function.",
    "EXAMPLES": "// Get the environment in text form and browse it:\n\nLOCAL cEnvBlock := \"\"\nLOCAL nNumStrings := ft_GetE( @cEnvBlock )\nLOCAL aEnvArray\n\n@ 0, 0 TO MaxRow() - 1, MaxCol()\n@ MaxRow(), 0 SAY 'Browse strings, press <Esc> to exit...'\nhb_MemoWrit( cEnvBlock, 1, 1, MaxRow() - 2, MaxCol() - 1, .F. )\n\n// Get the environment in text form and write it to a file:\n\ncEnvBlock := \"\"\nft_GetE( @cEnvBlock )\nhb_MemoWrit( \"environ.txt\", cEnvBlock )\n\n// Get the environment in Array form:\naEnvArray := Array( ft_GetE() )\nft_GetE( aEnvArray )\n? aEnvArray[ 1 ]\n? aEnvArray[ 2 ]"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/hex2dec.txt",
    "NAME": "ft_Hex2Dec()",
    "CATEGORY": "Conversion",
    "ONELINER": "Convert a hex number to decimal",
    "SYNTAX": "ft_Hex2Dec( <cHexNum> ) --> nDecNum",
    "ARGUMENTS": "<cHexNum> is a character string representing a hex number.",
    "RETURNS": "A decimal number.",
    "DESCRIPTION": "Converts a hexadecimal number to a BASE 10 decimal number.\nUseful for using ft_int86().",
    "EXAMPLES": "// Converts 21h, the MS-DOS Interrupt, to its decimal equivalent,\n// 33, for use by ft_int86().\n\n? ft_Hex2Dex( \"21\" )  // --> 33"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/iamidle.txt",
    "NAME": "ft_IAmIdle()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Inform the operating system that the application is idle.",
    "SYNTAX": "ft_IAmIdle() --> lSuccess",
    "ARGUMENTS": "None",
    "RETURNS": ".T. if supported, .F. otherwise.",
    "DESCRIPTION": "Some multitasking operating environments (e.g. Windows or OS/2) can\nfunction more efficiently when applications release the CPU during\nidle states.  This function allows you \"announce\" to the operating\nsystem that your application is idle.\n\nNote that if you use this function in conjunction with ft_OnIdle(),\nyou can cause Clipper to automatically release the CPU whenever\nClipper itself detects an idle state.",
    "EXAMPLES": "#include \"inkey.ch\"\n\nDO WHILE Inkey() != K_ESC\n   ft_IAmIdle()  // Wait for ESC and announce idleness\nENDDO\n\n// Here's another way to do it:\n\nft_OnIdle( {|| ft_IAmIdle() } )\n\nInkey( 0 )       // Automatically reports idleness until key is pressed!",
    "SEEALSO": "ft_OnIdle()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/idle.txt",
    "NAME": "ft_Idle()",
    "CATEGORY": "Event",
    "ONELINER": "Generate an idle event to allow incremental garbage collection.",
    "SYNTAX": "ft_Idle()",
    "ARGUMENTS": "None",
    "RETURNS": "NIL",
    "DESCRIPTION": "During memory-intensive operations that do not generate much in\nthe way of idle states, the Clipper runtime may not get a chance to\nperform garbage collection of discarded memory.  This can eventually\nlead to any of a variety of memory-related internal errors.\n\nThis function attempts to alleviate the problem by providing a\nmechanism by which an idle event can be artificially generated at\nwill.  The idle event will cause the CA-Cl*pper runtime to perform\nan incremental memory scavenge.\n\nThis function makes use of an undocumented internal routine.  If this\nthis fact makes you uncomfortable then don't use this function, you\nmiserable jello-spined lump of human debris.",
    "EXAMPLES": "// FIXME\nDO WHILE Whatever       // Some batch process\n   Something()          // Create 'n' discard a bunch of stuff\n   ft_Idle()            // Take out the garbage\nENDDO",
    "SEEALSO": "ft_OnIdle()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/inp.txt",
    "NAME": "ft_inp()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Retrieve a byte from a specified I/O port",
    "SYNTAX": "ft_inp( <nPort> ) --> nValue",
    "ARGUMENTS": "<nPort> is the port from which to retrieve the byte.  If it is\ninvalid in any way, the function will return zero.",
    "RETURNS": "The byte retrieved.",
    "DESCRIPTION": "It may sometimes be useful to read a byte from a port without having\nto resort to C or assembler.  This function allows you to do so.",
    "EXAMPLES": "? ft_inp( 100 )  // read a byte from port 100 (0x64)",
    "SEEALSO": "ft_outp()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/invclr.txt",
    "NAME": "ft_InvClr()",
    "CATEGORY": "Conversion",
    "ONELINER": "Get the inverse of a color",
    "SYNTAX": "ft_InvClr( [ <cDsrdColor> ] ) --> cColor",
    "ARGUMENTS": "<cDsrdColor> is the color to get the inverse of.  Defaults to\ncurrent color.",
    "RETURNS": "The inverse of the passed color.",
    "DESCRIPTION": "This function inverts a passed color (in the Clipper format: `??/??`),\ne.g., `\"W/N\"` is converted to `\"N/W\"`.",
    "EXAMPLES": "? ft_InvClr()          // Get Inverse of Current Color\n? ft_InvClr( \"GR/B\" )  // Get Inverse of cErrorColor"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/isbit.txt",
    "NAME": "ft_IsBit()",
    "CATEGORY": "String",
    "ONELINER": "Test the status of an individual bit",
    "SYNTAX": "ft_IsBit( <cByte>, <nBitPos> ) --> lResult",
    "ARGUMENTS": "<cByte> is a character from `hb_BChar( 0 )` to `hb_BChar( 255 )`.\n\n<nBitPos> is a number from 0 to 7 conforming to standard right-to-left\n          bit-numbering convention and representing the position of the\n          bit within the byte.",
    "RETURNS": ".T. if designated bit is set (1), .F. if not set (0), NIL if\n invalid parameters.",
    "DESCRIPTION": "Tests for status of any selected bit in the byte passed as a parameter.\nByte must be presented in hb_BChar() form, as a literal constant, or as\nthe one-byte character result of an expression.\n\nThis function is presented to illustrate that bit-wise operations\nare possible with Clipper code.  For greater speed, write `.c`\nversion and use the Clipper Extend system.",
    "EXAMPLES": "// This code tests whether bit 3 is set in the byte represented by\n// hb_BChar( 107 ):\n\nLOCAL lBitflag := ft_IsBit( hb_BChar( 107 ), 3 )\n? lBitflag            // --> .T.\n\n// This code tests whether bit 5 is set in the byte represented by ASCII\n// 65 (letter \"A\")\n\n? ft_IsBit( \"A\", 5 )  // --> .F.",
    "SEEALSO": "ft_BitSet(), ft_BitClr()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/isbiton.txt",
    "NAME": "ft_IsBitOn()",
    "CATEGORY": "String",
    "ONELINER": "Determine the state of individual bits in a number",
    "SYNTAX": "ft_IsBitOn( <nNumber>, <nBit> ) --> lResult",
    "ARGUMENTS": "<nNumber> is an integer for which a bit state needs to be checked.\n\n<nBit> is a number from 0 to 15 that indicates which bit to test.",
    "RETURNS": ".T. if the specified bit was on., .F. if off.",
    "DESCRIPTION": "This function is useful when dealing with binary integers.  It will\ncome in very handy if you use the ft_int86() function, because the\nCPU flags are returned as a series of bits.  Using this function, you\ncan determine the state of each CPU flag.",
    "EXAMPLES": "LOCAL nCPUFlags := 0xaa\n\nIF ft_IsBitOn( nCPUFlags, 0 )\n   ? \"The carry flag was set.\"\nENDIF\n\nIF ft_IsBitOn( nCPUFlags, 7 )\n   ? \"The sign flag was set.\"\nENDIF"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/isprint.txt",
    "NAME": "ft_IsPrint()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Check printer status",
    "SYNTAX": "ft_IsPrint( [ <cDevice> ] ) --> lResult",
    "ARGUMENTS": "<cDevice> is optional and is the device to test (LPT2, COM1, etc.).\nIf omitted, the function will default to the PRN device.",
    "RETURNS": ".T.  if device is ready for output.\n.F.  if one of the following conditions occurs:\n     1)  The device is not ready.\n     2)  The device does not exist.\n     3)  DOS couldn't open the device for some reason\n         (such as no file handles available).",
    "DESCRIPTION": "The Clipper IsPrinter() function is somewhat limited because it only\nworks with LPT1.  Furthermore, it talks directly to the hardware, so\nif you have redirected LPT1 via the DOS MODE command, the IsPrinter()\nfunction will return erroneous results.\n\nThis function offers a better alternative.  Instead of talking to the\nhardware, it issues a DOS call that checks to see if the device is\nready or not.  That gives DOS an opportunity to deal with any\nredirections, and since you pass the device name as a parameter, you\ncan test any device, not just LPT1 (note that the function defaults\nto PRN if you fail to pass a valid parameter).\n\nThe function also temporarily traps the DOS critical error handler so\nyou don't get any nasty error messages if the device isn't ready.  It\nrestores the old critical error handler before exiting.\n\nNote that although this function is mainly designed for testing\nprinters, you can also check to see if a drive is ready.  Since DOS\nthinks the NUL device exists on every drive, you can pass a drive\nletter followed by NUL as a parameter.  If DOS is able to open the\nNUL device, then the drive is ready, otherwise the door is open or\nsomething else is wrong.",
    "EXAMPLES": "IF ! ft_IsPrint()\n   ? \"PRN is not ready!\"\nENDIF\n\nIF ! ft_IsPrint( \"COM2\" )\n   ? \"Check the device on COM2.  Something is wrong.\"\nENDIF\n\nIF ! ft_IsPrint( \"/dev/lp0\" )\n   ? \"Oops, not available.\"\nENDIF"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/isshare.txt",
    "NAME": "ft_IsShare()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Determine if DOS \"Share\" is installed",
    "SYNTAX": "ft_IsShare() --> nRetCode",
    "ARGUMENTS": "None",
    "RETURNS": "<nRetcode> will be set as follows on exit:\n<table-noheader>\n   0 if SHARE not loaded but ok to load\n   1 if SHARE not loaded and not ok to load\n 255 if SHARE loaded\n</table>",
    "DESCRIPTION": "Uses DOS interrupt 2Fh (MultiPlex interrupt), service 10h\nto determine if DOS SHARE.COM is loaded.",
    "EXAMPLES": "IF ft_IsShare() != 255\n   ? \"SHARE must be loaded!\"\nENDIF",
    "SEEALSO": "ft_int86()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/kspeed.txt",
    "NAME": "ft_SetRate()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Set the keyboard delay and repeat rate on PC/AT & PS/2",
    "SYNTAX": "ft_SetRate( [ <nDelayTime> ] [, <nRepeatRate> ] ) --> NIL",
    "ARGUMENTS": "<nDelayTime> is the keyboard delay time.\n\n<table>\n nDelayTime      DELAY\n\n     0           250ms\n     1 (default) 500ms\n     2           750ms\n     3          1000ms\n</table>\n\n<nRepeatRate> is the keyboard repeat rate.\n\n<table>\n RepeatRate      SPEED\n\n    0           30.0cps\n    1           26.7cps\n    2           24.0cps\n    3           21.8cps\n    4           20.0cps\n    5           18.5cps\n    6           17.1cps\n    7           16.0cps\n    8           15.0cps\n    9           13.3cps\n   10           12.0cps\n   11           10.9cps\n   12 (default) 10.0cps\n   13            9.2cps\n   14            8.6cps\n   15            8.0cps\n   16            7.5cps\n   17            6.7cps\n   18            6.0cps\n   19            5.5cps\n   20            5.0cps\n   21            4.6cps\n   22            4.3cps\n   23            4.0cps\n   24            3.7cps\n   25            3.3cps\n   26            3.0cps\n   27            2.7cps\n   28            2.5cps\n   29            2.3cps\n   30            2.1cps\n   31            2.0cps\n</table>",
    "RETURNS": "NIL",
    "DESCRIPTION": "This routine is used to adjust the IBM PC/AT and PS/2 \"typematic\"\nrepeat and delay feature.  This is used to allow the users of your\napplication to adjust these speeds to the most comfortable level.",
    "EXAMPLES": "ft_SetRate( 0, 0 )   // Set keyboard to fastest possible settings\nft_SetRate()         // Set keyboard to AT defaults (10.9cps, 500ms delay)\nft_SetRate( 11, 1 )  // Set keyboard to PS/2 defaults (10cps, 500ms delay)"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/lastday.txt",
    "NAME": "ft_LDay()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Return last day of the month",
    "SYNTAX": "ft_LDay( [ <dDateToChk> ] ) --> dLastDay",
    "ARGUMENTS": "<dDateToChk> is a date within a month for which you want to find\nthe last date of that month.  If not passed or is an incorrect\ntype, defaults to current system date.",
    "RETURNS": "A Clipper date value representing the last date of the month.",
    "DESCRIPTION": "This function will return the last day of the month of the date\npassed, or the last day of the current month if no argument is\nsupplied.",
    "EXAMPLES": "? ft_LDay( 0d19900915 )  // --> 1990-09-30\n? ft_LDay()              // --> 1991-03-31  (current month)",
    "SEEALSO": "ft_FDay()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/linked.txt",
    "NAME": "ft_Linked()",
    "CATEGORY": "Environment",
    "ONELINER": "Determine if a function was linked in",
    "SYNTAX": "ft_Linked( <cString> ) --> lResult",
    "ARGUMENTS": "<cString> is a character string containing one or more function\n          calls",
    "RETURNS": ".T. if all functions within the string are currently linked into\nthe application, .F. if one or more aren't.  See below for a\ndefinition of \"function.\"",
    "DESCRIPTION": "This function would be used in data driven application to determine\nwhether or not a macro compiled function was linked in.\n\nSeveral functions can be passed, and nested, in <cString>.\n\nCaveat: Some function calls are converted by the preprocessor\ninto other function calls. You cannot have these types of\nfunctions in a macro compiled string as they never exist at\nruntime. ft_Linked() will correctly tell you that they are invalid.\n\nFor instance: there is no function called \"SORT()\" in any of the\nNantucket Libraries, but it is a valid CLIPPER command because the\npreprocessor will convert it to other function calls.",
    "EXAMPLES": "LOCAL cString := \"ft_GoodFunc( BadFunc( 3, 2 ) )\"\nIF ft_Linked( cString )\n   Eval( &( \"{||\" + cString + \"}\" ) )\nELSE\n   ? \"Error:\", cString, \"was not linked in. Called by ft_Linked()\"\nENDIF"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/madd.txt",
    "NAME": "ft_MAdd()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Add or subtract months to/from a date",
    "SYNTAX": "ft_MAdd( [ <dGivenDate> ], [ <nAddMonths> ], [ <lMakeEOM> ] )\n    --> dDate",
    "ARGUMENTS": "<dGivenDate> is any valid date in any date format. Defaults to\ncurrent system date if not supplied.\n\n<nAddMonths> is the number of months to be added or subtracted.\nDefaults to 0 if not supplied.\n\n<lMakeEOM> is a logical variable indicating whether or not to\nforce the returned date to the last date of the month.  It only\naffects the returned date if <dGivenDate> is an end-of-month date.",
    "RETURNS": "A date.",
    "DESCRIPTION": "ft_MAdd() adds or subtracts months to/from a given date.\n\nIf <lMakeEOM> is passed and <dGivenDate> is the last day of a month,\nit will return the `EOM` of calculated month.  Otherwise it will\nreturn the same day as the day of the passed date.",
    "EXAMPLES": "LOCAL dDate\n\ndDate := 0d19900915\n? ft_MAdd( dDate, 1 )       // --> 1990-10-15\n? ft_MAdd( dDate, -2 )      // --> 1990-07-15\n\n// force EOM\ndDate := 0d19910430\n? ft_MAdd( dDate, 1 )       // --> 1991-05-30\n? ft_MAdd( dDate, 1, .T. )  // --> 1991-05-31  forced EOM\n? ft_MAdd( dDate, 2 )       // --> 1991-06-30\n? ft_MAdd( dDate, 2, .T. )  // --> 1991-06-30  June only has 30 days\n? ft_MAdd( dDate, 3 )       // --> 1991-07-30\n? ft_MAdd( dDate, 3, .T. )  // --> 1991-07-31  forced EOM",
    "SEEALSO": "ft_DayOfYr(), ft_DayToBoW()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/menu1.txt",
    "NAME": "ft_Menu1()",
    "CATEGORY": "Menus/Prompts",
    "ONELINER": "Pulldown menu system",
    "SYNTAX": "ft_Menu1( <acBarNames>, <acOptions>, <acAction>,\n          <acColors> [, <nTopRow> ], [ <lShadow> ] ) --> NIL",
    "ARGUMENTS": "<acBarNames> is a character array containing the names to appear\non the menu bar.\n\n<acOptions> is a multi-dimensional array with one element for each\nselection to appear on the pulldown menus.\n\n<acColors> is an array containing the colors for the menu groups.\n\n<nTopRow> is a numeric value that determines the row for the menu\nbar.  If omitted, it defaults to 0.\n\n<lShadow> is a logical variable.  If true (.T.) or omitted, it\nuses ft_Shadow() to add a transparent shadow to the each\npulldown menu.  If false (.F.), the menu is drawn without\nthe shadow.\n\nAll arguments except <nTopRow> and <lShadow> are required.",
    "RETURNS": "NIL",
    "DESCRIPTION": "ft_Menu1() is a function that displays a pulldown menu for each item\non the menu bar and executes the corresponding function for the item\nselected.  When a called function returns false, ft_Menu1() returns\ncontrol to the calling program.\n\nValid keystrokes and their corresponding actions:\n<table-noheader>\n Home             -  Activates Pulldown for first item on the menu bar\n End              -  Activates Pulldown for last item on the menu bar\n Left             -  Activates next Pulldown to the left\n Right            -  Activates next Pulldown to the right\n Tab              -  Same as Right Arrow\n Shift-Tab        -  Same as Left Arrow\n PgUp             -  Top item on current Pulldown menu\n PgDn             -  Bottom item on current Pulldown menu\n Enter            -  Selects current item\n Alpha Character  -  Moves to closest match and selects\n Alt-<Key>        -  Moves to corresponding menu bar item\n Esc              -  Prompts for confirmation and either returns to\n                     the calling routine or resumes\n<table>",
    "EXAMPLES": "// Declare arrays\nLOCAL aColors  := {}\nLOCAL aBar     := { \" ENTER/EDIT \", \" REPORTS \", \" DISPLAY \" }\n\n// Include the following two lines of code in your program, as is.\n// The first creates aOptions with the same length as aBar.  The\n// second assigns a three-element array to each element of aOptions.\nLOCAL aOptions := Array( Len( aBar ) )\nAEval( aBar, {| x, i | aOptions[ i ] := { {}, {}, {} } } )\n\n// fill color array\n// Box Border, Menu Options, Menu Bar, Current Selection, Unselected\naColors := iif( IsColor(), ;\n   { \"W+/G\", \"N/G\", \"N/G\", \"N/W\", \"N+/G\" }, ;\n   { \"W+/N\", \"W+/N\", \"W/N\", \"N/W\", \"W/N\" } )\n\n// array for first pulldown menu\nft_Fill( aOptions[ 1 ], \"A. Execute A Dummy Procedure\" , {|| Alert( \"hello\" ) }, .T. )\nft_Fill( aOptions[ 1 ], \"B. Enter Daily Charges\"       , {|| .T. }, .F. )\nft_Fill( aOptions[ 1 ], \"C. Enter Payments On Accounts\", {|| .T. }, .T. )\n\n// array for second pulldown menu\nft_Fill( aOptions[ 2 ], \"A. Print Member List\"         , {|| .T. }, .T. )\nft_Fill( aOptions[ 2 ], \"B. Print Active Auto Charges\" , {|| .T. }, .T. )\n\n// array for third pulldown menu\nft_Fill( aOptions[ 3 ], \"A. Transaction Totals Display\", {|| .T. }, .T. )\nft_Fill( aOptions[ 3 ], \"B. Display Invoice Totals\"    , {|| .T. }, .T. )\nft_Fill( aOptions[ 3 ], \"C. Exit To DOS\"               , {|| .F. }, .T. )\n\n// Call ft_Fill() once for each item on each pulldown menu, passing it\n// three parameters:\n//\n//   ft_Fill( <cMenuSelection>, <bCodeBlock>, <lSelectable> )\n\n// <cMenuSelection> is a character string which will be displayed on\n// the pulldown menu.\n\n// <bCodeBlock> should contain one of the following:\n\n//   A function name to execute, which in turn should return .T. or .F.\n//   ft_Menu1() WILL RETURN CONTROL TO THE CALLING PROGRAM IF .F. IS\n//   RETURNED OR CONTINUE IF .T. IS RETURNED.\n\n//   .F. WHICH WILL CAUSE ft_Menu1() TO RETURN CONTROL TO THE CALLING\n//   PROGRAM.\n\n//   .T. WHICH WILL DO NOTHING.  THIS ALLOWS THE DEVELOPER TO DESIGN A\n//   SKELETON MENU STRUCTURE PRIOR TO COMPLETING ALL OF THE SUBROUTINES.\n\nft_Menu1( aBar, aOptions, aColors, 0 )\n\n// NOTE: ft_Menu1() disables <Alt-C> and <Alt-D> in order to make them\n//       available for the menu bar.  It enables <Alt-D> and resets\n//       <Alt-C> to its previous state prior to calling each function.",
    "SEEALSO": "ft_Fill()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/menu1.txt",
    "NAME": "ft_Fill()",
    "CATEGORY": "Menus/Prompts",
    "ONELINER": "Declare menu options for ft_Menu1()",
    "SYNTAX": "ft_Fill( <aSubArrayName>, <cMenuSelection>, <bFunction>,\n         <lSelectable> ) --> NIL",
    "ARGUMENTS": "<aSubArrayName> is a sub-array of <acOptions> in ft_Menu1()\ndenoting the group in which to include the selection --\ne.g., `acOptions[ 1 ]`\n\n<cMenuSelection> is the character string that will appear on\nthe menu.\n\n<bFunction> is the code block to be executed when that menu\noption is selected.  i.e. {|| MyFunction() } would execute\nthe function called MyFunction().  {|| .F. } would exit the\nft_Menu1() and return to the calling routine.  {|| .T. } would\ndo nothing.\n\n<lSelectable> is a logical variable that determines whether\nthe corresponding menu option is selectable or not.",
    "RETURNS": "NIL",
    "DESCRIPTION": "ft_Fill() is a function used to set up the menu options prior\nto calling ft_Menu1().",
    "EXAMPLES": "LOCAL aOptions := Array( 4 )\n\nft_Fill( aOptions[ 1 ], \"A. Execute A Dummy Procedure\" , {|| Alert( \"hello\" ) }, .T. )\n\n// The above would be added to the sub-menu associated with the\n// first menu bar item, would execute the function FUBAR() when\n// that option was selected, and would be selectable.\n\n\nft_Fill( aOptions[ 3 ], \"B. Enter Daily Charges\"       , {|| .T. }, .F. )\n\n// The above would be added to the sub-menu associated with the\n// third menu bar item, and would be unselectable.\n\n\nft_Fill( aOptions[ 2 ], \"C. Enter Payments On Accounts\", {|| .T. }, .T. )\n\n// The above would be added to the sub-menu associated with the\n// second menu bar item, and would be selectable, but would do\n// nothing when selected.\n\n\nft_Fill( aOptions[ 4 ], \"C. Exit\"                      , {|| .F. }, .T. )\n\n// The above would be added to the sub-menu associated with the\n// fourth menu bar item, and would be selectable, and would exit\n// ft_Menu1() when chosen.",
    "SEEALSO": "ft_Menu1()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/menutonf.txt",
    "NAME": "ft_Prompt()",
    "CATEGORY": "Menus/Prompts",
    "ONELINER": "Define a menu item for use with ft_MenuTo()",
    "SYNTAX": "#include \"ftmenuto.ch\"\n\n@ <nRow>, <nCol> PROMPT <cPrompt>                     ;\n                 [COLOR <cColor>]                     ;\n                 [MESSAGE <cMessage>]                 ;\n                 [MSGROW <nMsgRow>]                   ;\n                 [MSGCOL <nMsgCol>]                   ;\n                 [MSGCOLOR <cMsgColor>]               ;\n                 [TRIGGER <nTrigger>]                 ;\n                 [TRIGGERCOLOR <cTriggerColor>]       ;\n                 [HOME <nHome>]                       ;\n                 [END <nEnd>]                         ;\n                 [UP <nUp>]                           ;\n                 [DOWN <nDown>]                       ;\n                 [LEFT <nLeft>]                       ;\n                 [RIGHT <nRight>]                     ;\n                 [EXECUTE <bExec>]                    ;\n",
    "ARGUMENTS": "<nRow> is the row at which the prompt is to appear.\n\n<nCol> is the column at which the prompt will appear.\n\n<cPrompt> is the menu item string.\n\n<cColor> is optional and is the color attribute of the prompt.  Note\nthat two colors are required; one for the standard setting and one\nfor the enhanced setting (i.e. the light bar color).  See the example\nbelow if this isn't clear.  If <cColor> is not specified then the\ncurrent SetColor() value is used by default.\n\n<cMessage> is optional and is the message associated with the\nprompt. If not specified, then no message will be displayed.\n\n<nMsgRow> is optional and is the row at which the message, if any,\nwill appear.  If not specified, the default is the current setting\nof the `SET MESSAGE TO` command.\n\n<nMsgCol> is optional and is the column at which the message, if\nany, will appear.  If not specified, the default is either zero or\ncentered, depending on the current setting of the CENTER option of\nthe `SET MESSAGE TO` command.\n\n<cMsgColor> is optional and is the color attribute of the message.\nIf not specified, the default is the same as the prompt color.\n\n<nTrigger> is optional and is the position within the prompt string\nwhere the trigger character is located.  If not specified, the\ndefault is one.\n\n<cTriggerColor> is optional and is the color attribute of the trigger\ncharacter.  Note that two colors are required; one for the standard\nsetting and one for the enhanced setting (i.e. the light bar color).\nSee the example below if this isn't clear.  If <cTriggerColor> is not\nspecified then the default is the same color as the rest of the\nprompt.\n\n<nHome> is optional and specifies which prompt becomes active\nwhen the home key is pressed.  If not specified, the default is\nthe first prompt.\n\n<nEnd> is optional and specifies which prompt becomes active\nwhen the end key is pressed.  If not specified, the default is\nthe last prompt.\n\n<nUp> is optional and specifies which prompt becomes active\nwhen the up arrow key is pressed.  If not specified, the\ndefault is the previous prompt.  The current setting of\n`SET WRAP TO` is obeyed.\n\n<nDown> is optional and specifies which prompt becomes\nactive when the down arrow key is pressed.  If not\nspecified, the default is the next prompt.  The current\nsetting of `SET WRAP TO` is obeyed.\n\n<nRight> is optional and specifies which prompt becomes\nactive when the right arrow key is pressed.  If not\nspecified, the default is the next prompt.  The current\nsetting of `SET WRAP TO` is obeyed.\n\n<nLeft> is optional and specifies which prompt becomes\nactive when the left arrow is pressed.  If not specified,\nthe default is the previous prompt.  The current setting of\n`SET WRAP TO` is obeyed.\n\n<bExec> is optional and is a code block to evaluate whenever\nthe menu item to which it belongs is selected.",
    "DESCRIPTION": "Clipper's `@...PROMPT` and `MENU TO` commands are fine as far as\nthey go.  But many times you need more flexibility.  As\nyou'll no doubt notice if you read the argument list, this\nfunction is almost completely flexible. You can adjust\nlocations and colors for every part of the prompt and its\nassociated message.  In addition, since you can control the\neffect of the arrow keys, you can allow both horizontal and\nvertical movement, or even disable certain arrow keys if you\nso desire.  Support for nested menus is also available, since\nthe prompts are stored in stack-based static arrays.\n\nNote that this command can also be called using function-style\nsyntax.  See the entry for ft_Prompt() for further details.\n\nThis enhanced version of `@...PROMPT` requires the inclusion of\nthe header file ftmenuto.ch in any source file that uses it.\nIt is may be used in place of the standard Clipper `@...PROMPT`\ncommand.  However, in the interests of functionality it is *not*\n100% compatible.  No whining!  If compatibility is such a big\ndeal then use the standard Clipper commands.\n",
    "EXAMPLES": "#include \"ftmenuto.ch\"\n\n// Simple prompt\n@  1, 1 PROMPT \"Menu choice #1\"\n\n// Prompt with color\n@  3, 1 PROMPT \"Menu choice #2\" COLOR \"W+/R,W+/B\"\n\n// Prompt with a message\n@  5, 1 PROMPT \"Menu choice #3\" MESSAGE \"Go to lunch\"\n\n// Prompt with pinpoint message control\n@  7, 1 PROMPT \"Menu choice #4\" MESSAGE \"Drop Dead\" ;\n   MSGROW 22 MSGCOL 4 MSGCOLOR \"GR+/N\"\n\n// Prompt with a trigger character (\"#\" character)\n@ 11, 1 PROMPT \"Menu choice #6\" TRIGGER 13\n\n// Prompt with trigger character color control\n@ 13, 1 PROMPT \"Menu Choice #7\" TRIGGER 13 TRIGGERCOLOR \"R+/BG,G+/N\"\n\n// Prompt with right and left arrow keys disabled\n@ 15, 1 PROMPT \"Menu Choice #8\" RIGHT 8 LEFT 8",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/menutonf.txt",
    "NAME": "ft_MenuTo()",
    "CATEGORY": "Menus/Prompts",
    "ONELINER": "Execute light bar menu using prompts created with `@...PROMPT`",
    "SYNTAX": "#include \"ftmenuto.ch\"\n\nMENU TO <var> [COLD]",
    "ARGUMENTS": "<var> is the name of the variable to which the result of the menu\nselection should be assigned.\n\n`COLD` is optional and if specified indicates that trigger characters\nshould be treated as \"cold,\" i.e. rather than causing the menu item\nto be selected it only causes the light bar to move to that selection.",
    "DESCRIPTION": "This enhanced version of `MENU TO` requires the inclusion of the header\nfile ftmenuto.ch in any source file that uses it.  It may be used in\nplace of the standard Clipper `MENU TO` command.  However, in the\ninterests of functionality it is *not* 100% compatible (in particular,\nyou should make sure that the target memvar exists before executing\nthe menu -- the Clipper version will create a PRIVATE memvar for you\nif it does not already exist, but this version does not).  No whining!\nIf compatibility is such a big deal then use the standard Clipper\ncommand.\n\nNote that this command can also be called using function-style\nsyntax.  See the entry for ft_MenuTo() for further details.",
    "EXAMPLES": "// FIXME\n#include \"ftmenuto.ch\"\n\n// Simple command\nMENU TO memvar",
    "SEEALSO": "ft_Prompt()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/metaph.txt",
    "NAME": "ft_Metaph()",
    "CATEGORY": "String",
    "ONELINER": "Convert a character string to MetaPhone format",
    "SYNTAX": "ft_Metaph( <cName> [, <nSize> ] ) --> cMetaPhone",
    "ARGUMENTS": "<cName> is the character string to convert\n\n<nSize> is the length of the character string to be returned.\n        If not specified the default length is 4 bytes.",
    "RETURNS": "A phonetically spelled character string",
    "DESCRIPTION": "This function is a character function use to index and search for\nsound-alike or phonetic matches.  It is an alternative to\nthe SoundEx() function, and addresses some basic pronunciation\nrules, by looking at surrounding letters to determine how parts of\nthe string are pronounced.  ft_Metaph() will group sound-alikes\ntogether, and forgive shortcomings in spelling ability.",
    "EXAMPLES": "// FIXME\nUSE test\nINDEX ON ft_Metaph( field->last ) TO lastname\nSEEK ft_Metaph( \"Philmore\" )\n? Found(), field->last  // --> .T.  Philmore\nSEEK ft_Metaph( \"Fillmore\" )\n? Found(), field->last  // --> .T.  Philmore"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/miltime.txt",
    "NAME": "ft_Mil2Min()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Convert time in military format to number of minute of day.",
    "SYNTAX": "ft_Mil2Min( <cMilTime> ) --> nMinOfDay",
    "ARGUMENTS": "<cMilTime>  character string of form hhmm, where 0<=hh<24.",
    "RETURNS": "<nMinOfDay>  numeric value representing minute of day.",
    "DESCRIPTION": "Converts time in military format to number of minute of the day.",
    "EXAMPLES": "? ft_Mil2Min( \"1729\" )  // --> 1049",
    "SEEALSO": "ft_Min2Mil(), ft_Civ2Mil(), ft_Mil2Civ(), ft_Sys2Mil()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/miltime.txt",
    "NAME": "ft_Min2Mil()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Convert minute of day to military format time.",
    "SYNTAX": "ft_Min2Mil( <nMINUTE> ) --> cMILTIME",
    "ARGUMENTS": "<nMINUTE>  numeric integer representing minute of day.",
    "RETURNS": "<cMILTIME>  character string of form hhmm, where 0<=hh<24.",
    "DESCRIPTION": "Converts minute of the day to military format time.",
    "EXAMPLES": "? ft_Min2Mil( 279 )  // --> \"0439\"",
    "SEEALSO": "ft_Mil2Min(), ft_Mil2Civ(), ft_Civ2Mil(), ft_Sys2Mil()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/miltime.txt",
    "NAME": "ft_Mil2Civ()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Convert time in military format to civilian format.",
    "SYNTAX": "ft_Mil2Civ( <cCIVTIME> ) --> cMILTIME",
    "ARGUMENTS": "<cMILTIME>  character string of form hhmm, where 0<=hh<24.",
    "RETURNS": "<cCIVTIME>  character string of form hh:mm (am,pm,n or m),\n   where 0<hh<12.",
    "DESCRIPTION": "Converts time from military to civilian format",
    "EXAMPLES": "? ft_Mil2Civ( \"1640\" )  // --> \" 4:40 pm\"\n? ft_Mil2Civ( \"0440\" )  // --> \" 4:40 am\"\n? ft_Mil2Civ( \"1200\" )  // --> \"12:00 n\"\n? ft_Mil2Civ( \"0000\" )  // --> \"12:00 m\"\n? ft_Mil2Civ( \"2400\" )  // --> \"12:00 m\"\n\n// Caution: leading blanks are irrelevant.",
    "SEEALSO": "ft_Civ2Mil(), ft_Sys2Mil(), ft_Mil2Min(), ft_Min2Mil()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/miltime.txt",
    "NAME": "ft_Civ2Mil()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Convert usual civilian format time to military time.",
    "SYNTAX": "ft_Civ2Mil( <cCIVTIME> ) --> cMILTIME",
    "ARGUMENTS": "<cCIVTIME>  character string of form hh:mm (am,pm,n or m),\n   where 0<hh<12.",
    "RETURNS": "<cMILTIME>  character string of form hhmm, where 0<=hh<24.",
    "DESCRIPTION": "Converts time from 12-hour civilian format to military.",
    "EXAMPLES": "? ft_Civ2Mil( \" 5:40 pm\" )  // --> \"1740\"\n? ft_Civ2Mil( \" 5:40 am\" )  // --> \"0540\"\n? ft_Civ2Mil( \"12:00 n\" )   // --> \"1200\"\n? ft_Civ2Mil( \"12:00 m\" )   // --> \"0000\"\n\n// Caution: leading blanks are irrelevant; p,a,n,m must be preceded by\n//          one and only one space.",
    "SEEALSO": "ft_Mil2Civ(), ft_Sys2Mil(), ft_Mil2Min(), ft_Min2Mil()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/miltime.txt",
    "NAME": "ft_Sys2Mil()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Convert system time to military time format.",
    "SYNTAX": "ft_Sys2Mil() --> cMILTIME",
    "ARGUMENTS": "none",
    "RETURNS": "<cMILTIME>  character string of form hhmm, where 0<=hh<24.",
    "DESCRIPTION": "Return current system time as character string in military format.",
    "EXAMPLES": "? ft_Sys2Mil()  // --> \"1623\"",
    "SEEALSO": "ft_Mil2Civ(), ft_Civ2Mil()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/min2dhm.txt",
    "NAME": "ft_Min2Dhm()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Convert numeric minutes to days, hours and minutes.",
    "SYNTAX": "ft_Min2Dhm( <nMinutes> ) --> aDHM_",
    "ARGUMENTS": "<nMinutes>  the number of minutes.",
    "RETURNS": "<aDHM_>\n   where:\n      aDHM_[ 1 ] = cDAYS, aDHM_[ 2 ] = cHours, aDHM_[ 3 ] = cMinutes",
    "DESCRIPTION": "Converts numeric minutes into a character array containing\ndays, hours & minutes.",
    "EXAMPLES": "LOCAL aDHM_ := ft_Min2Dhm( 16789 )\n? aDHM_[ 1 ]  // --> \"11\"\n? aDHM_[ 2 ]  // --> \"15\"\n? aDHM_[ 3 ]  // --> \"49\""
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mkdir.txt",
    "NAME": "ft_MkDir()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Create a subdirectory",
    "SYNTAX": "ft_MkDir(  <cDirName> ) --> nResult",
    "ARGUMENTS": "<cDirName> is the name of the directory to create.",
    "RETURNS": "0   if successful\n3   if Path Not Found\n5   if Access Denied or directory already exists\n99  if invalid parameters passed",
    "DESCRIPTION": "Use this function to create the subdirectories needed by your\napplication.  It might be especially useful in an installation\nprogram.",
    "EXAMPLES": "? ft_MkDir( \"mydir\" )\n? ft_MkDir( hb_DirSepToOS( \"/mydir\" ) )\n? ft_MkDir( hb_DirSepToOS( \"./mydir\" ) )\n? ft_MkDir( hb_DirSepToOS( \"../mydir\" ) )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/month.txt",
    "NAME": "ft_Month()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Return Calendar or Fiscal Month Data",
    "SYNTAX": "ft_Month( [ <dGivenDate> ], [nMonthNum] ) --> aDateInfo",
    "ARGUMENTS": "<dGivenDate> is any valid date in any date format.  Defaults\nto current system date if not supplied.\n\n<nMonthNum> is a number from 1 to 12 signifying a month.\nDefaults to current month if not supplied.",
    "RETURNS": "A three element array containing the following data:\n\n   aDateInfo[ 1 ] - The year and month as a character string \"YYYYMM\"\n   aDateInfo[ 2 ] - The beginning date of the month\n   aDateInfo[ 3 ] - The ending date of the month",
    "DESCRIPTION": "ft_Month() returns an array containing data about the month\ncontaining the given date.\n\nNormally the return data will be based on a year beginning\non January 1st with weeks beginning on Sunday.\n\nThe beginning of year date and/or beginning of week day can be\nchanged by using ft_DateCnfg(), which will affect all subsequent\ncalls to ft_Month() until another call to ft_DateCnfg().\n\nThe beginning of year date and beginning of week day may be reset\nto January 1 and Sunday by calling ft_DateCnfg() with no\nparameters.",
    "EXAMPLES": "LOCAL aDateInfo\n\n// get info about month containing 1990-09-15\naDateInfo := ft_Month( 0d19900915 )\n? aDateInfo[ 1 ]  // --> 199009      (9th month)\n? aDateInfo[ 2 ]  // --> 1990-09-01  beginning of month 9\n? aDateInfo[ 3 ]  // --> 1990-09-30  end of week month 9\n\n// get info about month 5 in year containing 1990-09-15\naDateInfo := ft_Month( 0d19900915, 5 )\n? aDateInfo[ 1 ]  // --> 199005\n? aDateInfo[ 2 ]  // --> 1990-05-01  beginning of month 5\n? aDateInfo[ 3 ]  // --> 1990-05-31  end of month 5\n\n// get info about month 5 in current year (1991)\naDateInfo := ft_Month( , 5 )\n? aDateInfo[ 1 ]  // --> 199105\n? aDateInfo[ 2 ]  // --> 1991-05-01  beginning of month 5\n? aDateInfo[ 3 ]  // --> 1991-05-31  end of month 5",
    "SEEALSO": "ft_DateCnfg(), ft_Week(), ft_Qtr(), ft_Year()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MInit()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Initialize the mouse driver, vars and return status of mouse",
    "SYNTAX": "ft_MInit() --> lMouseStatus",
    "ARGUMENTS": "NONE",
    "RETURNS": "An logical representing the mouse status (.F. == mouse not installed)",
    "DESCRIPTION": "Initializes the mouse drive, associated variables and returns mouse\nstatus. It checks to see if the mouse has been previously initialized\nand if so it does not reinitialize. The row and column limits of mouse\nmovement is set to the maximum for the current video mode.\nUse ft_MShowCrs() to display the mouse cursor.",
    "EXAMPLES": "IF ! ft_MInit()\n   ? \"No mouse driver is installed\"\nENDIF",
    "SEEALSO": "ft_MReset()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MMickeys()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Get mickeys",
    "SYNTAX": "ft_MMickeys( @<nX>, @<nY> ) --> NIL",
    "ARGUMENTS": "<nX> is a variable that will receive the vertical mickey count.\n\n<nY> is a variable that will receive the horizontal mickey count.",
    "RETURNS": "NIL",
    "DESCRIPTION": "<nX> and <nY> must be passed by reference to receive\nthe mouse position in Mickeys.",
    "EXAMPLES": "LOCAL nX, nY\nft_MMickeys( @nX, @nY )\n? nX, nY"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MDblClk()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Return true if a double click was detected",
    "SYNTAX": "ft_MDblClk( [ <nClick> [, <nButton> [, <nInterval> [, <nRow> [, <nCol> ;\n            [, <nTime> ] ] ] ] ] ] ) --> lIsDoubleClk",
    "ARGUMENTS": "<nClick> is a numeric value.  If it is zero ft_MDblClk() will not\n         check for the first press but rather will simply wait the\n         specified period for a single press. This is useful if this\n         routine is called from one which in turn responded to a button\n         press. If it is not present or not equal to 0, then ft_MDblClk()\n         will wait for two presses of the specified button.\n\n<nButton> is the mouse button number\n           0 - Left   Button\n           1 - Right  Button\n           2 - Middle Button [if applicable]\n\n<nInterval> is the interval to wait for the first click if requested\n       and the time to wait for the second. If not present then defaults\n       to 0.5 second.\n\n<nRow> is the row number for the mouse cursor location for a double click\n       to be valid. If not present then the current position is taken as\n       the valid location.\n\n<nCol> is the column number for the mouse cursor location for a double\n       click to be valid. If not present, then the current position is\n       taken as the valid location.\n\n<nTime> is an optional start time for the waiting period for the first\n       click (of either one or two requested). If not given then the\n       time is set at entry into this routine. This is useful when this\n       routine is called from another routine which was called in\n       response to a mouse click but needs to know if a double click\n       has occurred",
    "RETURNS": ".T. if a double click was detected.",
    "DESCRIPTION": "This is a mouse meta function that checks for the presence\nof a double click.",
    "EXAMPLES": "IF ft_MInRegion( 10, 10, 11, 20 ) .AND. ;\n   ft_MDblClk( 0, 1,, ft_MGetX(), ft_MGetY() )  // double click, right button\n                                                // at current location with\n                                                // default interval\n   // MnuItem1()\nENDIF",
    "SEEALSO": "ft_MButPrs(), ft_MButRel()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MCOnOff()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Turn mouse cursor off if in specified region",
    "SYNTAX": "ft_MCOnOff( <nTop>, <nLeft>, <nBottom>, <nRight> )",
    "ARGUMENTS": "<nTop>, <nLeft> <nBottom> <nRight> are the four corners of the\n      screen region in row and column coordinates.",
    "RETURNS": "NIL",
    "DESCRIPTION": "This function tells the mouse driver to hide the cursor if it is in\nthe given region. The driver hides the cursor by decrementing the cursor\nflag. A call to ft_MShowCrs() is required to turn the cursor back on.\nCalling ft_MShowCrs() also disables this function.\n\nSee ft_MShowCrs() for a discussion of the cursor display flag.",
    "EXAMPLES": "ft_MCOnOff( 10, 10, 11, 20 )",
    "SEEALSO": "ft_MShowCrs(), ft_MHideCrs(), ft_MXLimit(), ft_MYLimit(), ft_MInRegion()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MInRegion()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Test if the mouse cursor is in the passed region",
    "SYNTAX": "ft_MInRegion( <nT>, <nL>, <nB>, <nR> ) --> lInRegion",
    "ARGUMENTS": "<nT>, <nL> <nB> <nR> are the four corners of the screen region.",
    "RETURNS": ".T. if mouse is in specified region.",
    "DESCRIPTION": "This function will check to see if the mouse cursor is\nwithin the confines of the specified region.",
    "EXAMPLES": "LOCAL nChoice\nIF ft_MInRegion( 10, 10, 11, 20 )\n   nChoice := 1\nENDIF",
    "SEEALSO": "ft_MXLimit(), ft_MYLimit(), ft_MInRegion()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MSetSens()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Set the mouse sensitivity parameters",
    "SYNTAX": "ft_MSetSens( <nHoriz>, <nVert>, <nDouble> ) --> NIL",
    "ARGUMENTS": "<nHoriz>  is the sensitivity of the mouse on the horizontal axis. This\n          value is the integer percentage of highest sensitivity and\n          thus has a range of 1 to 100. The default value is 50 and at\n          this setting about 3.2 inches of mouse movement will move\n          the mouse cursor across the screen. If NIL, the current\n          value is used.\n<nVert>   is the relative sensitivity of the mouse on the vertical axis.\n          The value is an integer percentage of the highest sensitivity\n          and thus has a range of 1 to 100. The default value is 50 and\n          requires about 2 inches of mouse movement will move from top\n          to bottom of the screen.If NIL, the current value is used.\n<nDouble> is the relative sensitivity of the mouse to doubling the ratio\n          of cursor movement to mouse movement. The default\n          value is 50. If NIL, the current value is used.",
    "RETURNS": "NIL",
    "DESCRIPTION": "This function allows one to control the mouse movement sensitivity. The\nfirst two arguments control the amount of movement necessary to move\nthe cursor a given amount. The values are the percentage of full\nsensitivity and the default values after installing the mouse driver\nis 50 which represents approximately 3.2 inches of horizontal\nand 2 inches of vertical mouse movement to cover the entire screen.\nA value of 100 requires about 0.9 inches of horizontal mouse movement to\ncover the screen from one side to the other.\n\nThe third argument changes the threshold above which the mouse moves at\ntwice the normal speed. The value is a percentage of full sensitivity\nwith the default (50) providing doubling at 64 mickeys per second.\n\nNOTE: These values are NOT restored after resetting the mouse driver/\nhardware. A well behaved application should reset them to the\noriginal value upon exiting.\n\nNOTE: The above description is counter to all of the documentation\nI have available. However, it does not work the way it is documented\nwith Microsoft drivers versions 6.16, 6.24, 7.04 and 8.20. The above\nmovement values are documented to be the number of mickeys per 8\npixels and the double speed value as the number mickeys per second\nrequired to double the speed. Each of these values should range from 1\nto 32000 but the driver forces a maximum of 100. Also the documentation\nstates that resetting the mouse will reset these values. This is not\nthe case.",
    "EXAMPLES": "ft_MSetSens( 75, 75, 50 )  // a little less mouse movement necessary.",
    "SEEALSO": "ft_MGetSens()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MGetSens()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Get the mouse sensitivity parameters",
    "SYNTAX": "ft_MGetSens( <@nHoriz>, <@nVert>, <@nDouble> ) --> NIL",
    "ARGUMENTS": "<nHoriz>  is the percentage of maximum horizontal sensitivity.\n          *Passed by reference*.\n<nVert>   is the percentage of maximum vertical sensitivity.\n          *Passed by reference*.\n<nDouble> is the percentage of maximum sensitivity for doubling the\n          mouse cursor's speed on the screen. *Passed by reference*.",
    "RETURNS": "NIL",
    "DESCRIPTION": "This function returns the current values of the mouse movement\nsensitivity parameters. The first two arguments control the amount of\nmovement necessary to move the cursor a given amount. The third argument\ndetermines the threshold above which the mouse moves at twice the normal\nspeed. For further discussion of these values see ft_MSetSens()",
    "EXAMPLES": "LOCAL nHoriz, nVert, nDouble\nft_MGetSens( @nHoriz, @nVert, @nDouble )\n? nHoriz, nVert, nDouble",
    "SEEALSO": "ft_MSetSens()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MVersion()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Get the mouse driver version",
    "SYNTAX": "ft_MVersion( <@nMinor>, <@nType>, <@nIRQ>  ) --> nMajor",
    "ARGUMENTS": "<nMinor>  is the Minor version number. *Passed by reference*.\n<nType>   is the Mouse type. *Passed by reference*.\n              1 = Bus Mouse\n              2 = Serial Mouse\n              3 = InPort Mouse\n              4 = PS/2 Mouse\n              5 = HP Mouse\n<nIRQ>    is the IRQ number used for the mouse. *Passed by reference*.\n              0 = PS/2\n              2,3,4,5 or 7 = IRQ number",
    "RETURNS": "<nMajor> which is the major version number of the mouse driver.",
    "DESCRIPTION": "This function returns the current values of the mouse driver version\nnumber and type. The major version would be 6 and the minor version\nwould be 10 if the driver were version 6.10. The mouse type and IRQ\nnumbers are also returned.\n\nNOTE: It appears that the values reported when one starts the mouse\ndriver actually have the minor version in hexadecimal! Thus on boot-up\nmy screen showed 6.24 but this routine returned 30 for the minor version\nnumber!",
    "EXAMPLES": "LOCAL nMinor\nLOCAL nMajor := ft_MVersion( @nMinor )\nIF ( nMajor + nMinor / 100 ) < 7.2\n   ? \"Sorry mouse driver version too old\"\nENDIF\n? nMajor, nMinor",
    "SEEALSO": "ft_MSetSens()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MSetPage()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Set the display page for the mouse pointer",
    "SYNTAX": "ft_MSetPage( <@nPage> ) --> NIL",
    "ARGUMENTS": "<nPage> is the desired display page.",
    "RETURNS": "NIL",
    "DESCRIPTION": "This function sets the display page for the mouse cursor. The valid\nvalues of <nPage> is dependent upon the display mode. See ft_SetVPg()\nfor changing the current video page",
    "EXAMPLES": "ft_MSetPage( 1 )  // Sets the mouse cursor to page 1",
    "SEEALSO": "ft_MGetPage()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MGetPage()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Get the display page for the mouse pointer",
    "SYNTAX": "ft_MGetPage() --> nPage",
    "ARGUMENTS": "None",
    "RETURNS": "<nPage>  is the display page on which the mouse is currently being\n     displayed",
    "DESCRIPTION": "This function gets the display page for the mouse cursor. The valid\nvalues of <nPage> is dependent upon the display mode. See ft_SetVPg()\nfor changing the current video page",
    "EXAMPLES": "? ft_MGetPage( )  // Gets the mouse cursor display page",
    "SEEALSO": "ft_MSetPage()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MReset()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Reset mouse driver and return status of mouse",
    "SYNTAX": "ft_MReset() --> nMouseStatus",
    "ARGUMENTS": "NONE",
    "RETURNS": "An integer representing the mouse status (0 == mouse not installed)",
    "DESCRIPTION": "Resets the mouse driver and returns mouse status. Use ft_MShowCrs()\nto display the mouse cursor. The mouse is set to allow it to cover the\ncomplete screen (as defined by MaxCol() and MaxRow()). This is necessary\nbecause at least some versions of the mouse drivers do not operate\naccording to the documentation when confronted with a 43 or 50 line\nscreen.\n\nNormally, ft_MInit() should be used to initialize the mouse since it\nwill not reinitialize if already done.",
    "EXAMPLES": "IF ft_MReset() == 0\n   ? \"No mouse driver is installed\"\nENDIF",
    "SEEALSO": "ft_MInit(), ft_MShowCrs()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MCursor()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Set the mouse cursor",
    "SYNTAX": "ft_MCursor( [ <lState> ] ) --> lCursorState",
    "ARGUMENTS": "<lState> is a logical indicating whether to set the mouse cursor on.\n         .T. - set mouse cursor on\n         .F. - set mouse cursor off\n         If omitted, no change is made to cursor state",
    "RETURNS": "A logical indicating the previous mouse cursor state.",
    "DESCRIPTION": "This function works like most Clipper state functions.  If no value\nis sent to ft_MCursor() it will return the state of the mouse cursor.",
    "EXAMPLES": "IF ! ft_MCursor()\n   ft_MCursor( .T. )\nENDIF"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MShowCrs()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Increment internal cursor flag and display mouse cursor",
    "SYNTAX": "ft_MShowCrs() --> NIL",
    "ARGUMENTS": "NONE",
    "RETURNS": "NIL",
    "DESCRIPTION": "Displays the mouse cursor. Make sure to turn the mouse cursor off\nwhen redrawing screens.  The mouse cursor dutifully saves the screen\nunder it, so if you draw over the mouse cursor it will create a \"hole\"\nin your screen when you move the mouse cursor.\n\nNote: A call to ft_MHideCrs() decrements a mouse driver variable\nwhich indicates whether the cursor is shown. The cursor is visible\nonly when the variable = 0. Thus multiple calls to ft_MHideCrs()\nrequire an equal number of calls to ft_MShowCrs() before the cursor\nwill again be visible. Once the variable is 0 calls to ft_MShowCrs()\ndoes not increment the variable above 0.",
    "EXAMPLES": "ft_MShowCrs()",
    "SEEALSO": "ft_MHideCrs(), ft_MCOnOff()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MHideCrs()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Decrement internal mouse cursor flag and hide mouse cursor",
    "SYNTAX": "ft_MHideCrs() --> NIL",
    "ARGUMENTS": "NONE",
    "RETURNS": "NIL",
    "DESCRIPTION": "Hides the mouse cursor. Make sure to turn the mouse cursor off when\nredrawing screens.  The mouse cursor dutifully saves the screen\nunder it, so if you draw over the mouse cursor it will create a\n\"hole\" in your screen when you move the mouse cursor.\n\nNote: A call to ft_MHideCrs() decrements a mouse driver variable\nwhich indicates whether the cursor is shown. The cursor is visible\nonly when the variable = 0. Thus multiple calls to ft_MHideCrs()\nrequire an equal number of calls to ft_MShowCrs() before the cursor\nwill again be visible. Once the variable is 0 calls to ft_MShowCrs()\ndoes not increment the variable above 0.",
    "EXAMPLES": "ft_MHideCrs()\n@ 10, 10 TO 20, 20\nft_MShowCrs()",
    "SEEALSO": "ft_MShowCrs(), ft_MCOnOff()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MGetPos()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Get mouse cursor position and button status",
    "SYNTAX": "ft_MGetPos( @<nX>, @<nY> ) --> nButtonStatus",
    "ARGUMENTS": "<nX> is a variable that will receive the mouse X position in virtual\nscreen coordinates.  It must be passed by reference.\n\n<nY> is a variable that will receive the mouse Y position in virtual\nscreen coordinates.  It must be passed by reference.",
    "RETURNS": "an integer representing button status\n<table-noheader>\n 0 - no button pressed\n 1 - left pressed\n 2 - right pressed\n 3 - left and right pressed\n 4 - middle pressed\n 5 - left and middle pressed\n 6 - right and middle pressed\n 7 - all three buttons pressed\n</table>",
    "DESCRIPTION": "Loads cursor position into x and y coordinates passed by reference and\nreturns the button status. The coordinate system in text mode has\neight virtual coordinates per character cell. Thus x=16 means that you\nare in the Row 2. The values returned by this routine when in text mode\nand with mouse driver versions 6 and above are multiples of 8. We have\nexperience with drivers prior to that version",
    "EXAMPLES": "LOCAL nX, nY\nLOCAL nButton := ft_MGetPos( @nX, @nY )\n? \"Mouse Row    :\", nX\n? \"Mouse Column :\", nY\n? \"Button Status:\", nButton",
    "SEEALSO": "ft_MGetCoord(), ft_MSetPos(), ft_MDefCrs(), ft_MGetX(), ft_MGetY()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MGetX()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Get mouse cursor row position",
    "SYNTAX": "ft_MGetX() --> nRowPos",
    "ARGUMENTS": "NONE",
    "RETURNS": "<nRowPos> which is the row position of mouse in virtual screen\n          coordinates.",
    "DESCRIPTION": "Retrieves mouse's row position in virtual screen coordinates. The\nvalues returned are multiples of 8 when in text mode and with at least\nMicrosoft drivers 6 and above.",
    "EXAMPLES": "? ft_MGetX()",
    "SEEALSO": "ft_MGetCoord(), ft_MDefCrs(), ft_MGetPos(), ft_MGetY()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MGetY()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Get mouse cursor column position",
    "SYNTAX": "ft_MGetY() --> nColPos",
    "ARGUMENTS": "NONE",
    "RETURNS": "<nColPos> Column position of mouse in virtual screen coordinates",
    "DESCRIPTION": "Retrieves mouse's column position in virtual screen coordinates. The\nvalues returned are multiples of 8 when in text mode and with at least\nMicrosoft drivers 6 and above.",
    "EXAMPLES": "? ft_MGetY()",
    "SEEALSO": "ft_MGetCoord(), ft_MDefCrs(), ft_MGetPos(), ft_MGetX()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MSetPos()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Position the mouse cursor using virtual screen coordinates",
    "SYNTAX": "ft_MSetPos( <nX>, <nY> ) --> NIL",
    "ARGUMENTS": "<nX> is the desired mouse row.\n\n<nY> is the desired mouse column.",
    "RETURNS": "NIL",
    "DESCRIPTION": "Positions mouse cursor on screen. The virtual coordinate system in text\nmode has eight virtual coordinates per character cell. Thus x=16 means\nthat you are in the Row 2.",
    "EXAMPLES": "ft_MSetPos( 10, 20 )  // position mouse cursor at row 10, col 20\n                      // in virtual screen coordinates",
    "SEEALSO": "ft_MGetPos(), ft_MGetCoord(), ft_MSetCoord(), ft_MGetX(), ft_MGetY()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MSetCoord()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Position the mouse cursor using text screen coordinates",
    "SYNTAX": "ft_MSetPos( <nX>, <nY> ) --> NIL",
    "ARGUMENTS": "<nX> is the desired mouse row.\n\n<nY> is the desired mouse column.",
    "RETURNS": "NIL",
    "DESCRIPTION": "Positions mouse cursor on screen using text (normal row and column)\ncoordinates.",
    "EXAMPLES": "ft_MSetCoord( 10, 20 )  // position mouse cursor at row 10, col 20\n                        // in text screen coordinates",
    "SEEALSO": "ft_MGetPos(), ft_MGetCoord(), ft_MSetPos(), ft_MDefCrs(), ft_MGetX(), ft_MGetY()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MXLimit()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Set vertical bounds of mouse using virtual screen coord.",
    "SYNTAX": "ft_MXLimit( <nX1>, <nX2> ) --> NIL",
    "ARGUMENTS": "<nX1> is the top row limit.\n\n<nX2> is the bottom row limit.",
    "RETURNS": "NIL",
    "DESCRIPTION": "Set maximum vertical bounds of mouse using virtual screen coordinates.",
    "EXAMPLES": "ft_MXLimit( 10, 20 )",
    "SEEALSO": "ft_MYLimit(), ft_MInRegion()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MYLimit()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Set horizontal bounds of mouse using virtual screen coordinates",
    "SYNTAX": "ft_MYLimit( <nY1>, <nY2> ) --> NIL",
    "ARGUMENTS": "<nY1> is the left column limit.\n\n<nY2> is the right column limit.",
    "RETURNS": "NIL",
    "DESCRIPTION": "Set maximum horizontal bounds of mouse using virtual screen coordinates.",
    "EXAMPLES": "ft_MYLimit( 10, 20 )",
    "SEEALSO": "ft_MXLimit(), ft_MInRegion()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MButPrs()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Retrieve button press status",
    "SYNTAX": "ft_MButPrs( <nButton> [, @nButPrs [, @nX [, @nY] ] ] ) --> nButStatus",
    "ARGUMENTS": "<nButton> is the mouse button number:\n\n           0 - Left   Button\n           1 - Right  Button\n           2 - Middle Button [if applicable]\n\n<nButPrs> is the number of times the specified button was pressed\n          since the last call to this routine. *Passed by reference*.\n<nX> is the X position of the cursor when the last press occurred.\n          *Passed by reference*.\n<nY> is the Y position of the cursor when the last press occurred.\n          *Passed by reference*.\n",
    "RETURNS": "An integer representing the button status:\n<table-noheader>\n 0 - no buttons pressed\n 1 - left button pressed\n 2 - right button pressed\n 3 - left and right pressed\n 4 - middle pressed\n 5 - left and middle pressed\n 6 - middle and right buttons pressed\n 7 - all 3 buttons pressed\n</table>",
    "DESCRIPTION": "Retrieves the mouse button status and the position of the cursor when\na button was last pressed.",
    "EXAMPLES": "IF ft_MButPrs( 1 ) == 0\n   ? \"No Item selected\"\nENDIF",
    "SEEALSO": "ft_MButRel(), ft_MDblClk()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MButRel()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Get mouse button release information",
    "SYNTAX": "ft_MButRel( nButton [, @nButRel [, @nX [, @nY] ] ]) --> nBStat",
    "ARGUMENTS": "<nButton> is the mouse button number\n          0 - Left   Button\n          1 - Right  Button\n          2 - Middle Button [if applicable]\n\n<nButRel> is the number of times the specified button was released\n          since the last call to this routine. *Passed by reference*.\n\n<nX> is the X position of the cursor when the last release occurred.\n          *Passed by reference*.\n\n<nY> is the Y position of the cursor when the last release occurred.\n          *Passed by reference*.",
    "RETURNS": "<nBStat>  - an integer representing button release status\n            0 - None\n            1 - Left\n            2 - Right\n            3 - Middle",
    "DESCRIPTION": "This function returns the release status of the mouse buttons and the\ncoordinates of the last release.",
    "EXAMPLES": "IF ft_MButRel( 0 ) == 1\n   ? \"Left button released\"\nENDIF",
    "SEEALSO": "ft_MButPrs(), ft_MDblClk()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MDefCrs()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Define the mouse cursor",
    "SYNTAX": "ft_MDefCrs( <nCrsType>, <nScrMask>, <nCrsMask> ) --> NIL",
    "ARGUMENTS": "<nCrsType> is the cursor type. A value of 0 indicates the software cursor\n           (the default) and a value of 1 indicates the hardware cursor.\n\n<nScrMask> is the screen mask for the software cursor or the first scan\n           line of the hardware cursor. See the description for more\n           information.\n\n<nCrsMask> is the cursor mask for the software cursor of the last scan\n           line of the hardware cursor. See the description for more\n           information.",
    "RETURNS": "NIL",
    "DESCRIPTION": "In text mode the mouse cursor can either be a software generated or\nthe actual hardware cursor. This routine allows one choose between them.\nThe software cursor is the default and its effect on the character it\ncovers is determined by the screen mask and the cursor mask. Both of\nthese masks are 16-bit values (which in Clipper are passed as standard\nnumerical values). The 16-bit masks are arranged in a manner identical\nto the way information is stored for each character cell on the screen.\nThe low order 8 bits represent the actual character displayed while the\nhigh order bits represent the display attributes such as blinking,\nintensity and foreground and background colors. The mask is represented in\nthe diagram below:\n```\nBit:     15    14      1211       10       87       0\nFunction:blink backgroundintensityforegroundcharacter\n```\nBlinking and high intensity are on when the bit is 1. The background and\nforeground indicate which colors are used for each. The software mouse\ncursor uses these two values by taking the mask from the screen cell it\nis on and performing a logical AND on each bit with the screen mask\nvalue. The result is then logically XOR'ed with the cursor mask value.\nThus to keep the character the same but invert the foreground and\nbackground colors the following values would be used:\n```\nBit:     15    14      1211       10       87       0\nFunction:blink backgroundintensityforegroundcharacter\nscreen:    0      111        0       111    11111111  =30719\ncursor:    0      111        0       111    00000000  =30464\n```\nThe hardware cursor is the text cursor provided by the video board. One\nspecifies the range of scan lines which are on using <nScrMask> and\n<nCrsMask>. The range of values is dependent upon the type of monitor.\nThe first scan line is 0."
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/mouse1.txt",
    "NAME": "ft_MGetCoord()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Get mouse cursor position (text coord.) and button status",
    "SYNTAX": "ft_MGetPos( @<nX>, @<nY> ) --> nButtonStatus",
    "ARGUMENTS": "<nX> is a variable that will receive the mouse X position in text\nscreen coordinates.  It must be passed by reference.\n\n<nY> is a variable that will receive the mouse Y position in text\nscreen coordinates.  It must be passed by reference.",
    "RETURNS": "an integer representing button status\n<table-noheader>\n 0 - no button pressed\n 1 - left pressed\n 2 - right pressed\n 3 - left and right pressed\n 4 - middle pressed\n 5 - left and middle pressed\n 6 - right and middle pressed\n 7 - all three buttons pressed\n</table>",
    "DESCRIPTION": "Loads cursor position into x and y coordinates passed by reference and\nreturns the button status.",
    "EXAMPLES": "LOCAL nX, nY\nLOCAL nButton := ft_MGetCoord( @nX, @nY )\n? \"Mouse Row    :\", nX\n? \"Mouse Column :\", nY\n? \"Button Status:\", nButton",
    "SEEALSO": "ft_MGetPos(), ft_MSetPos(), ft_MDefCrs(), ft_MGetX(), ft_MGetY()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/n2color.txt",
    "NAME": "ft_N2Color()",
    "CATEGORY": "String",
    "ONELINER": "Returns the string complement of a Clipper color number",
    "SYNTAX": "ft_Color2N( <nColor> ) --> cColor",
    "ARGUMENTS": "<nColor> a number representing a Clipper color",
    "RETURNS": "The string complement of a number representing a Clipper or a\nnull string if the parameter is invalid",
    "DESCRIPTION": "This function is useful for converting a number to a Clipper color\nstring.",
    "EXAMPLES": "? ft_Color2N( \"*+w/gr\" )  // --> 239",
    "SEEALSO": "ft_N2Color()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/netpv.txt",
    "NAME": "ft_NetPV()",
    "CATEGORY": "Math",
    "ONELINER": "Calculate net present value",
    "SYNTAX": "ft_NetPV( <nInitialInvestment>, <nInterestRate>, <aCashFlow> ;\n          [, <nNoOfCashFlows> ] ) --> nNetPV",
    "ARGUMENTS": "<nInitialInvestment> is the amount of cash invested for purposes\nof generating the cash flows.\n\n<nInterestRate> is the annual interest rate used to discount\nexpected cash flows (10.5% = 10.5, not .105).\n\n<aCashFlow> is an array of the expected cash receipts each year.\n\n<nNoOfCashFlows> is the number of years cash flows are expected\n(optional, `Len( aCashFlow )` ).",
    "RETURNS": "The difference between the initial investment and the discounted\ncash flow in dollars.",
    "DESCRIPTION": "This function calculates the net present value, the difference\nbetween the cost of an initial investment and the present value\nof the expected cash flow(s) from the investment.  The present\nvalue of the expected cashflow(s) is calculated at the specified\ninterest rate, which is often referred to as the \"cost of capital\".\n\nThis function can be used to evaluate alternative investments.\nThe larger the NPV, the more profitable the investment.  See\nalso the FutureValue and PresentValue for further explanations.\nThe formula to calculate the net present value is:\n```\nNetPresentValue := SUM( CashFlow[ i ] / ( ( 1 + InterestRate ) ^ i ) )\nFOR i := 1 TO NoOfCashFlows\n   //\nNEXT\n```",
    "EXAMPLES": "? ft_NetPV( 10000, 10, { 10000, 15000, 16000, 17000 } )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/nooccur.txt",
    "NAME": "ft_NoOccur()",
    "CATEGORY": "String",
    "ONELINER": "Find the number of times one string occurs in another",
    "SYNTAX": "ft_NoOccur( <cCheckFor>, <cCheckIn> ;\n            [, <lIgnoreCase> ] ) --> nOccurrences",
    "ARGUMENTS": "<cCheckFor> is the string to search for\n\n<cCheckIn> is the string to search\n\n<lIgnoreCase> is a boolean variable to force case sensitivity\n(optional, defaults to .T.).",
    "RETURNS": "The number of times <cCheckFor> appears in <cCheckIn>",
    "DESCRIPTION": "This function finds the number of times a string occurs in a\n   second string.",
    "EXAMPLES": "LOCAL cMemoString := hb_MemoRead( \"test.txt\" )\n\n// Find the number of times \"the\" appears in cMemoString, case\n// insensitive\n? ft_NoOccur( \"the\", cMemoString )\n\n// Find the number of times \"the\" appears in cMemoString, case\n// sensitive\n? ft_NoOccur( \"the\", cMemoString, .F. )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/ntow.txt",
    "NAME": "ft_NToW()",
    "CATEGORY": "Conversion",
    "ONELINER": "Translate numeric value to words",
    "SYNTAX": "ft_NToW( <nNumber> ) --> cWords",
    "ARGUMENTS": "<nNumber>  An integer to translate",
    "RETURNS": "A text string representing <nNumber>",
    "DESCRIPTION": "Translates numeric input to a text string.\n\nft_NToW() is intended to be used with integers only.  Since I don't\nknow what your application will be, I cannot assume the type of\nfraction you want returned (ninety nine cents, 99/100, .99, etc).\nIf you want the fraction in words, just pass it as an integer.\n\nDo not pass a negative number!  Handle negative numbers any way\nyou need to in your code.  (i.e.: CR, DB, Negative, Minus, etc.)\n\nAlso, numeric 0 is returned as a null string.  You will need to\nmake a decision how to output it (zero dollars, no dollars, etc).",
    "EXAMPLES": "LOCAL x, cents, string\n\n? ft_NToW( 999 )   // --> \"Nine Hundred Ninety Nine\"\n? ft_NToW( 1000 )  // --> \"One Thousand\"\n\n? ft_NToW( 23 ) + \" Dollars and \" + ft_NToW( 99 ) + \" Cents\"\n   // --> Twenty Three Dollars and Ninety Nine Cents\n\n? ft_NToW( 23 ) + \" Dollars and \" + \"99/100\"\n   // --> Twenty Three Dollars and 99/100\n\nx      := -23.99\ncents  := Str( ( x - Int( x ) ) * 100, 2, 0 ) + \"/100\"\nx      := Int( x )\nstring := iif( x < 0, \"Credit of \", \"Debit of \" )\n? string + ft_NToW( Abs( x ) ) + \" Dollars and \" + \"99/100\"\n   // --> Credit of Twenty Three Dollars and 99/100"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/numlock.txt",
    "NAME": "ft_NumLock()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Return status of NumLock key",
    "SYNTAX": "ft_NumLock( [ <lNewSetting> ] ) --> lCurrentSetting",
    "ARGUMENTS": "<lNewSetting> is optional and if supplied is the new setting\nfor the CapLock key.  Specify .T. to turn CapLock on, or .F. to\nturn it off.",
    "RETURNS": "`lValue` is .T. if <NumLock> is set, .F. if it isn't set.  The value\nreturned represents the setting in effect prior to any changes that\nmight by made by <lNewSetting>.",
    "DESCRIPTION": "This function is useful if you need to know or set the status of the\n<NumLock> key for some reason.",
    "EXAMPLES": "#include \"inkey.ch\"\n\nIF ft_NumLock()\n   ? \"NumLock is active\"\nENDIF\n\n// Another one, slightly strange, courtesy of Glenn Scott:\n\nnumBlink()\n\nSTATIC FUNCTION numBlink()\n\n   LOCAL lOldNum := ft_NumLock()\n\n   DO WHILE Inkey( 0.5 ) != K_ESC\n      ft_NumLock( ! ft_NumLock() )\n   ENDDO\n\n   RETURN ft_NumLock( lOldNum )",
    "SEEALSO": "ft_CapLock(), ft_Ctrl(), ft_PrtScr(), ft_Shift(), ft_Alt()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/nwlstat.txt",
    "NAME": "ft_NWLStat()",
    "CATEGORY": "NetWare",
    "ONELINER": "Return the current Novell NetWare logical station number",
    "SYNTAX": "ft_NWLStat() --> nStatNum",
    "ARGUMENTS": "None",
    "RETURNS": "A numeric corresponding to the current logical station number\nassigned by NetWare.",
    "DESCRIPTION": "In order to find out information about a particular node logged\nin to a NetWare server, you will need the logical\nstation number, also known as a \"connection number.\"  This\nfunction will return that number.  This will be a number from 1 to 100\nunder NetWare 286, or from 1 to 250 under NetWare 386.  This is _not_\nthe same as a physical station number.\n\nThis function requires ft_int86().\n\nThis function does _not_ test for the existence of the NetWare shell.\nThe behavior is undefined if no shell is loaded.",
    "EXAMPLES": "? \"Logical station:\", ft_NWLStat()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/nwsem.txt",
    "NAME": "ft_NWSemOpen()",
    "CATEGORY": "NetWare",
    "ONELINER": "Open or create a NetWare semaphore",
    "SYNTAX": "ft_NWSemOpen( <cName>, <nInitVal>, <@nHandle>, <@nOpenCnt> ) --> nRc",
    "ARGUMENTS": "<cName> is the semaphore name, maximum length is 127 characters.\n\n<nInitVal> is the initial value for the semaphore.  It must start\nas a positive number, to a maximum of 127.\n\n<@nHandle> is the semaphore handle.  *This must be passed by\nreference!*  On exit, <nHandle> will contain a numeric value that\nrefers to the opened semaphore.  You will need it to pass to\nother semaphore functions!  *Pass it by reference!*\n\n<@nOpenCnt> is the number of stations that have opened the\nsemaphore.  *This must be passed by reference!* On exit, <nOpenCnt>\nwill contain a numeric value.",
    "RETURNS": "<nRc>, a numeric result code, as follows:\n<table-noheader>\n   0 - success\n 254 - Invalid semaphore name length\n 255 - Invalid semaphore value\n</table>\n<nHandle> will contain the semaphore handle, and\n<nOpenCnt> will contain the number of stations that have opened\nthe semaphore.",
    "DESCRIPTION": "A semaphore is simply a label that indirectly controls network\nactivity.  There is a semaphore name, which can be up to 127\ncharacters, and an associated value, which can range from 0 to\n127.\n\nA semaphore can be used for many things, but is most often used\nto limit the number of users in an application, and to control\naccess to a network resource.\n\nA semaphore essentially allows you to place locks on resources\nother than files.\n\nAn application begins the process by calling ft_NWSemOpen().\nIf the semaphore doesn't exist, NetWare will create it.\nft_NWSemOpen() returns a handle that is used in other semaphore\ncalls.\n\nApplications use ft_NWSemWait() to wait for a semaphore to\nbecome available.  ft_NWSemWait() decrements the semaphore's\nvalue by 1.  If the value > 0, then the application should\nbe allowed to access the semaphore's resource.  If the value\ngoes negative, then the application is placed in a queue.\nHow long your app is in the queue is determined by how you\nset the timeout parameter.  If you cannot get the resource in\nthe time you allot, you're let out of the queue and the\nvalue increments by 1 again.\n\nWhen an application finishes with a semaphore, it should\ncall ft_NWSemSig() to increment the value, and then\nft_NWSemClose() to close the semaphore.  When the semaphore's\nopen count goes to 0, NetWare deletes it.\n\nft_NWSemEx() can be used to examine the value and open count\nwithout affecting them.\n\nFor an interesting discussion on the operating system aspects\nof semaphores, check \"Operating Systems Design and Implementation\"\nby A. Tanenbaum, page 60.  For more details on NetWare's\nsemaphore facilities, refer to Charles Rose's \"Programmer's\nGuide to NetWare\".  The \"Programmer's Guide\" will make an\nexcellent companion guide to the source code for all NetWare\nfunctions in the Nanforum Toolkit.",
    "EXAMPLES": "LOCAL nHandle, nOpenCnt\nLOCAL nInitVal := 2\nLOCAL nRc := ft_NWSemOpen( \"Semaphore Test\", nInitVal, ;\n                           @nHandle, @nOpenCnt )\nIF nRc != 0\n   ? \"Error:\", nRc\nENDIF",
    "SEEALSO": "ft_NWSemEx(), ft_NWSemWait(), ft_NWSemSig(), ft_NWSemClose(), ft_NWSemLock()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/nwsem.txt",
    "NAME": "ft_NWSemEx()",
    "CATEGORY": "NetWare",
    "ONELINER": "Examine a NetWare semaphore's value and open count",
    "SYNTAX": "ft_NWSemEx( <nHandle>, <@nValue>, <@nOpenCnt> ) --> nRc",
    "ARGUMENTS": "<nHandle> is the semaphore handle, returned from a previous call\nto ft_NWSemOpen().\n\n<@nValue> will get the current semaphore value.\n*This numeric argument must be passed by reference!*\n\n<@nOpenCnt> will get the current number of workstations\nthat have opened the semaphore.\n*This numeric argument must be passed by reference!*",
    "RETURNS": "<nRc>, a numeric, as follows:\n<table-noheader>\n   0 - success\n 255 - invalid semaphore handle\n</table>\nIn addition, <nValue> will be set to the semaphore's current value,\nand <nOpenCnt> will be set to the number of stations that have\nopened the semaphore.",
    "DESCRIPTION": "See the description for ft_NWSemOpen().",
    "EXAMPLES": "LOCAL nInitVal := 2\nLOCAL nHandle  := 0\nLOCAL nOpenCnt := 0\nLOCAL nValue   := 0\n\nft_NWSemOpen( \"Semaphore Test\", nInitVal, @nHandle, @nOpenCnt )\n\nIF ft_NWSemWait( nHandle ) == 254\n   ? \"All slots for this resource are currently in use\"\n   RETURN\nENDIF\n\nft_NWSemEx( nHandle, @nValue, @nOpenCnt )\n? \"Semaphore test -> Open at [\" + ;\n   hb_ntos( nOpenCnt ) + ;\n   \"] stations, value is [\" + ;\n   hb_ntos( nValue ) + \"]\"",
    "SEEALSO": "ft_NWSemOpen(), ft_NWSemWait(), ft_NWSemSig(), ft_NWSemClose(), ft_NWSemLock()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/nwsem.txt",
    "NAME": "ft_NWSemWait()",
    "CATEGORY": "NetWare",
    "ONELINER": "Wait on a NetWare semaphore (decrement)",
    "SYNTAX": "ft_NWSemWait( <nHandle> [, nTimeout ] ) --> nRc",
    "ARGUMENTS": "<nHandle> is the semaphore handle, returned from a previous call\nto ft_NWSemOpen().\n\n<nTimeOut> is an optional parameter telling how long you wish to\nwait on this semaphore.  This is a numeric indicating the number\nof clock ticks (approx 1/18 sec) to wait.  A zero (the default)\nmeans \"don't wait.\"",
    "RETURNS": "<nRc>, a numeric, as follows:\n<table-noheader>\n   0 - success\n 254 - timeout failure\n 255 - invalid semaphore handle\n</table>",
    "DESCRIPTION": "See the description for the ft_NWSemOpen() function.",
    "EXAMPLES": "LOCAL nHandle, nOpenCnt\nLOCAL nInitVal := 2\n\nft_NWSemOpen( \"Semaphore Test\", nInitVal, @nHandle, @nOpenCnt )\n\nIF ft_NWSemWait( nHandle ) == 254\n   ? \"All slots for this resource are currently in use\"\nENDIF",
    "SEEALSO": "ft_NWSemOpen(), ft_NWSemEx(), ft_NWSemSig(), ft_NWSemClose(), ft_NWSemLock()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/nwsem.txt",
    "NAME": "ft_NWSemSig()",
    "CATEGORY": "NetWare",
    "ONELINER": "Signal a NetWare semaphore (increment)",
    "SYNTAX": "ft_NWSemSig( nHandle ) --> nRc",
    "ARGUMENTS": "<nHandle> is the semaphore handle, returned from a previous call\nto ft_NWSemOpen().",
    "RETURNS": "<nRc>, a numeric, as follows\n<table-noheader>\n   0 - success\n   1 - semaphore overflow ( value > 127 )\n 255 - invalid semaphore handle\n</table>",
    "DESCRIPTION": "Use ft_NWSemSig() when your app has finished with the resource\nlocked by a semaphore.  This will increase the value (thus\nmaking a slot available to another app).\n\nFor more information, see the description under ft_NWSemOpen().",
    "EXAMPLES": "LOCAL nHandle := 0\n? \"Signal returns:\", ft_NWSemSig( nHandle )",
    "SEEALSO": "ft_NWSemOpen(), ft_NWSemEx(), ft_NWSemWait(), ft_NWSemClose(), ft_NWSemLock()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/nwsem.txt",
    "NAME": "ft_NWSemClose()",
    "CATEGORY": "NetWare",
    "ONELINER": "Close a NetWare semaphore",
    "SYNTAX": "ft_NWSemClose( <nHandle> ) --> nRc",
    "ARGUMENTS": "<nHandle> is the semaphore handle, returned from a previous call\nto ft_NWSemOpen().",
    "RETURNS": "<nRc>, a numeric, as follows:\n<table-noheader>\n   0 - success\n 255 - invalid semaphore handle\n</table>",
    "DESCRIPTION": "Call ft_NWSemClose() when the app is finished.  This decrements\nthe open count for the semaphore.  If the open count hits zero,\nthe semaphore is deleted by NetWare.",
    "EXAMPLES": "LOCAL nHandle := 0\n? \"Close returns:\", ft_NWSemClose( nHandle )",
    "SEEALSO": "ft_NWSemOpen(), ft_NWSemEx(), ft_NWSemWait(), ft_NWSemSig(), ft_NWSemLock()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/nwsem.txt",
    "NAME": "ft_NWSemLock()",
    "CATEGORY": "NetWare",
    "ONELINER": "Perform a semaphore \"lock\"",
    "SYNTAX": "ft_NWSemLock( <cSemaphore>, <@nHandle> ) --> lRet",
    "ARGUMENTS": "<cSemaphore> is the name of a semaphore you want to \"lock.\"\n<nHandle> is the semaphore's handle, if you get the lock.\n*This must be passed by reference!*",
    "RETURNS": "<lRet> == .T. if you get the lock, .T. if you don't.\nIf the lock succeeds, <nHandle> will contain the semaphore\nhandle.  If it fails, the value of <nHandle> is undefined.",
    "DESCRIPTION": "ft_NWSemLock() uses the Nanforum Toolkit's NetWare Semaphore API\nfunctions in order to provide a general purpose \"lock\" you can use in\na NetWare environment.\n\nAn interesting byproduct of NetWare's semaphore functions is\nthe \"open count\" which tells you how many connections have this\nsemaphore open.  This is different from the semaphore's _value_,\nwhich is set when the semaphore is opened and changed with\nSignal() and wait().\n\nThe point of semaphores is that you don't care how many users\nare using the resource; you merely wait on a semaphore until\nthe resource becomes available or you give up.  When you're done,\nyou signal it and off you go.\n\nBack to the open count.  ft_NWSemLock() opens the semaphore\nas named in <cSemaphore>.  After it is opened, the open count\nis checked.  If it is anything other than 1, that means someone\nelse has it (or you failed in your open) so the semaphore is\nclosed and the \"lock\" is refused.  If the value is 1, then your\napp is that 1 station so the \"lock\" is granted.\n\nYou can use a semaphore lock to control access to anything\nthat Clipper's RLock() and FLock() cannot help you with, such\nas text files written with the low-level file I/O functions,\netc.",
    "EXAMPLES": "LOCAL nHandle := 0\nIF ft_NWSemLock( \"error.log\", @nHandle )\n   // Note, you aren't actually LOCKING this file, you are\n   // just locking a semaphore by the same name.  As long as\n   // all apps that might be using this file are cooperating\n   // with the same kind of semaphore lock, you can effectively\n   // control access to the file.\nELSE\n   ? \"Couldn't lock file.\"\nENDIF\n// Processing, then:\nft_NWSemUnlock( nHandle )",
    "SEEALSO": "ft_NWSemOpen(), ft_NWSemEx(), ft_NWSemWait(), ft_NWSemSig(), ft_NWSemUnlock()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/nwsem.txt",
    "NAME": "ft_NWSemUnlock()",
    "CATEGORY": "NetWare",
    "ONELINER": "\"Unlock\" a semaphore locked by ft_NWSemLock()",
    "SYNTAX": "ft_NWSemUnlock( <nHandle> ) --> lRet",
    "ARGUMENTS": "<nHandle> is the semaphore handle returned from ft_NWSemLock()",
    "RETURNS": "<lRet> == .T. if you successfully unlock the semaphore, .F. if\nyou don't.  If this call fails, it could be that you're passing\nan invalid semaphore handle.",
    "DESCRIPTION": "This call unlocks a semaphore previously locked via ft_NWSemLock().\nIt is important that you get a valid semaphore handle from\nft_NWSemLock() before you use this call.  Make sure when you call\nft_NWSemLock() that you pass a numeric parameter in for the handle\n*by reference*.",
    "EXAMPLES": "LOCAL nHandle := 0\nIF ft_NWSemLock( \"error.log\", @nHandle )\n   // Note, you aren't actually LOCKING this file, you are\n   // just locking a semaphore by the same name.  As long as\n   // all apps that might be using this file are cooperating\n   // with the same kind of semaphore lock, you can effectively\n   // control access to the file.\nELSE\n   ? \"Couldn't lock file.\"\nENDIF\n// Processing, then:\nft_NWSemUnlock( nHandle )",
    "SEEALSO": "ft_NWSemOpen(), ft_NWSemEx(), ft_NWSemWait(), ft_NWSemSig(), ft_NWSemLock()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/nwuid.txt",
    "NAME": "ft_NWUID()",
    "CATEGORY": "NetWare",
    "ONELINER": "Return the current Novell NetWare User ID",
    "SYNTAX": "ft_NWUID( [ <nConnection> ] ) --> cUid",
    "ARGUMENTS": "<nConnection> is a connection number, or logical station number,\nto find a user id for.  Under NetWare 286, this number can be from\n1 to 100.  Under NetWare 386, 1-250.  If not supplied, ft_NWUID()\ndefaults to the current connection (i.e., the connection running\nthe application).",
    "RETURNS": "A string containing the user id, or \"login name.\"\nThe maximum length of this string, as defined by current\nversions of Novell NetWare, is 48 characters.",
    "DESCRIPTION": "ft_NWUID() returns the current NetWare user id, or \"login\nname.\"  This is useful for implementing security or audit\ntrail procedures within your programs.\n\nThere is no simple way a user can \"fool\" this function into\nretrieving an incorrect value, provided a NetWare shell is loaded.\n\nThis function requires ft_int86() and ft_NWLStat()\n\nThis function does _not_ test for the existence of the NetWare shell.\nThe behavior is undefined if no shell is loaded. You'll usually get\ngarbage.  This function has not been tested on NetWare 386.",
    "EXAMPLES": "LOCAL cUid, x\n\n? \"I am:\", ft_NWUID()\n\nFOR x := 1 TO 100\n   cUid := ft_NWUID( x )\n   IF ! cUid == \"\"\n      ? Str( x, 3 ), cUid\n   ENDIF\nNEXT"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/onidle.txt",
    "NAME": "ft_OnIdle()",
    "CATEGORY": "Event",
    "ONELINER": "Evaluate a designated code block during idle states.",
    "SYNTAX": "ft_OnIdle( [<bCode>] )",
    "ARGUMENTS": "<bCode> is the code block to evaluate.",
    "RETURNS": "NIL",
    "DESCRIPTION": "This function allows you to evaluate code blocks in the background\nwhile the foreground is in an idle state.\n\nTo halt the evaluation of the code block during idle states, call\nft_OnIdle() with no arguments.\n\nThis function makes heavy use of several undocumented internal\nroutines.  If this fact makes you uncomfortable then don't use\nthis function, you putrid pile of chicken excrement.",
    "EXAMPLES": "ft_OnIdle( {|| QOut( \"Hey, I'm not busy!\" ) } )\n\nInkey( 0 )  // Let the fun begin",
    "SEEALSO": "ft_Idle()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/ontick.txt",
    "NAME": "ft_OnTick()",
    "CATEGORY": "Event",
    "ONELINER": "Evaluate a designated code block at a designated interval.",
    "SYNTAX": "ft_OnTick( bCode, nInterval )",
    "ARGUMENTS": "<bCode> is the code block to evaluate.\n<nInterval> is the number of clock ticks to wait between\n            evaluations of the code block.",
    "RETURNS": "NIL",
    "DESCRIPTION": "This function effectively allows you to run tasks in the background\nby transparently and periodically calling a designated routine.\n\nTo halt the execution of the background function, call ft_OnTick()\nwith no arguments.\n\nThis function makes heavy use of several undocumented internal\nroutines.  If this fact makes you uncomfortable then don't use\nthis function, you quivering sack of cowardly slime.",
    "EXAMPLES": "// Set up a self-updating on-screen clock\n\nft_OnTick( @Clock(), 9 )\n\nSTATIC PROCEDURE Clock()\n\n   LOCAL nRow := Row()\n   LOCAL nCol := Col()\n\n   @ 0, 0 SAY Time()\n\n   SetPos( nRow, nCol )\n\n   RETURN",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/origin.txt",
    "NAME": "ft_Origin()",
    "CATEGORY": "Environment",
    "ONELINER": "Report the drive, path and filename of the current program",
    "SYNTAX": "ft_Origin() --> cString",
    "ARGUMENTS": "None",
    "RETURNS": "A string containing the full drive/directory/filename of\nthe currently executing file.",
    "DESCRIPTION": "Often users will install multiple copies of application software,\nespecially on networks and in situations where the user is trying\nto get around a copy protection scheme.\n\nThis function enables you to learn the name and source location\nof the currently executing file, so that you may take whatever\naction you need to.",
    "EXAMPLES": "IF ! hb_FNameNameExt( ft_Origin() ) == \"myapp.exe\"\n   ? \"Incorrect startup file. Please remove/rename and start again\"\nENDIF",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/outp.txt",
    "NAME": "ft_outp()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Write a byte to a specified I/O port",
    "SYNTAX": "ft_outp( <nPort>, <nValue> ) --> lResult",
    "ARGUMENTS": "<nPort> is the port from which to retrieve the byte.\n\n<nValue> is the value between 0 and 255 to write to the port.",
    "RETURNS": ".T. if all parameters were valid and the byte was written to\n    the port.\n.F. if invalid parameters were passed.",
    "DESCRIPTION": "It may sometimes be useful to write a byte to a port without having\nto resort to C or assembler.  This function allows you to do so.",
    "EXAMPLES": "? ft_outp( 0x64, 0 )  // send a hb_BChar( 0 ) to port 100 (0x64)",
    "SEEALSO": "ft_inp()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/page.txt",
    "NAME": "ft_SetVPg()",
    "CATEGORY": "Video",
    "ONELINER": "Set the current video page",
    "SYNTAX": "ft_SetVPg( <nPage> ) --> NIL",
    "ARGUMENTS": "<nMode> is a valid video page.",
    "RETURNS": "NIL",
    "DESCRIPTION": "Selects the video page.\n\nFor more information on graphics programming and video pages,\nconsult a reference such as \"Programmer's Guide to PC and PS/2\nVideo Systems\" (Microsoft Press).",
    "EXAMPLES": "// The following sets the current video page to 1\n\nft_SetVPg( 1 )",
    "SEEALSO": "ft_GetVPg()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/page.txt",
    "NAME": "ft_GetVPg()",
    "CATEGORY": "Video",
    "ONELINER": "Get the currently selected video page",
    "SYNTAX": "ft_GetVPg() --> nPage",
    "ARGUMENTS": "None.",
    "RETURNS": "The video page, as a numeric.",
    "DESCRIPTION": "Get the currently selected video page\n\nFor more information on graphics programming and video pages,\nconsult a reference such as _Programmer's Guide to PC and PS/2\nVideo Systems_ (Microsoft Press).\n",
    "EXAMPLES": "? ft_GetVPg()",
    "SEEALSO": "ft_SetVPg()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/pchr.txt",
    "NAME": "ft_PChr()",
    "CATEGORY": "String",
    "ONELINER": "Convert printer control codes",
    "SYNTAX": "ft_PChr( <cString> ) --> cPrinterFormat",
    "ARGUMENTS": "<cString> is the representation of the printer control codes in\ntext, numeric, hexadecimal, Epson command format, or any combination\nseparated by commas.",
    "RETURNS": "A character string of printer control codes.",
    "DESCRIPTION": "This function is useful for allowing the user to enter printer\ncontrol codes in text (enclosed in double quotes), numeric,\nhexadecimal, or Epson commands preceded by a slash and returns\nthe printer control code equivalent.\n\nNOTES:\n\n  - Combinations of text, numbers, hex, and commands must be\n     separated by commas (\"A\",27,&1B,/RESET).\n  - Text must be enclosed in double quotes (\"x\").\n  - Hexadecimal must be preceded by an ampersand (&1B).\n  - Epson commands, listed below, must be preceded by a forward\n     slash (/RESET).\n\n  Epson commands: (slash commands are specific to the Epson)\n\nJob Control:\n<table-noheader>\n /RESET or /INIT   Reset or initialize the printer\n /BELL  or /BEEP   Cause the printer's speaker to beep (not HS)\n /CAN              Clear print buffers (not MX)\n /SLOW             Set low speed mode (not CR, HS, MX)\n /FAST             Cancel low speed mode (not CR, HS, MX)\n /ONE              Select Unidirectional mode\n /TWO              Select Directional mode\n /ON               Activate printer\n /OFF              Turn off printer\n\n /FF or /EJECT     Form Feed\n\n Page Control:\n\n /1/6              Set 6 lines per inch\n /1/8              Set 8 lines per inch\n /SKIP             Set Skip perforation ON\n /SKIPOFF          Set Skip perforation OFF\n\n Font Selection and Manipulation:\n\n /ITALIC           Select italic char. set  (only FX86, EX, LX,\n                                                 no LQ-1500, SX)\n /GRAPHIC          Select graphic char. set (only FX86, EX, LX,\n                                                 no LQ-1500, SX)\n /ROMAN            Choose Roman font\n /SANS             Choose Sans Serif font\n /DRAFT            Choose draft\n /NLQ              Choose near letter quality\n /PICA             Choose 10 chars per inch\n /ELITE            Choose 12 chars per inch\n /COND or /SI      Choose 15 chars per inch\n /EMPH             Turn emphasize on\n /EMPHOFF          Turn emphasize off\n /SPANISH          Select Spanish international charset\n /USA              Select USA international charset\n</table>\n",
    "EXAMPLES": "LOCAL cSetUp := \"27,116,1\"\n\nSET PRINTER ON\n\n? ft_PChr( cSetUp )         // --> hb_BChar( 27 ) + hb_BChar( 116 ) + hb_BChar( 1 )\n                            //      <select Epson char. graphics>\n\n? ft_PChr( '27,\"x\",0' )     // --> hb_BChar( 27 ) + hb_BChar( 120 ) + hb_BChar( 0 )\n                            //      <Epson draft mode>\n\n? ft_PChr( '&1B,\"E\"'  )     // --> hb_BChar( 27 ) + hb_BChar( 69 )\n                            //      <HP reset>\n\n? ft_PChr( \"/ELITE,/NLQ\" )  // --> hb_BChar( 27 ) + hb_BChar( 77 ) + ;\n                            //     hb_BChar( 27 ) + hb_BChar( 120 ) + hb_BChar( 1 )\n                            //      <Epson elite & near letter quality>",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/peek.txt",
    "NAME": "ft_Peek()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Retrieve a byte from a specified memory location.",
    "SYNTAX": "ft_Peek( <nSegment>, <nOffset> ) --> nValue",
    "ARGUMENTS": "<nSegment> is the segment of the desired memory address.\n\n<nOffset>  is the offset of the desired memory address.",
    "RETURNS": "<nValue> will be a value from 0 to 255 if all parameters were valid and\n         the function was able to retrieve the desired byte.\n<nValue> will be -1 if invalid parameters were passed.",
    "DESCRIPTION": "Use this function if you have a need to examine a specific memory\nlocation.  The function will return the byte at the specified\naddress as a numeric value.  If you need this value as a character,\nuse the hb_BChar() function to convert it.",
    "EXAMPLES": "? ft_Peek( 0, 0x449 )  // Get the current video mode (MS-DOS)"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/pegs.txt",
    "NAME": "ft_Pegs()",
    "CATEGORY": "Game",
    "ONELINER": "PEGS GAME (all work and no play...)",
    "SYNTAX": "ft_Pegs() --> NIL",
    "ARGUMENTS": "None",
    "RETURNS": "NIL",
    "DESCRIPTION": "This function can be used to alleviate boredom.  The object is to\nremove all pegs except one.  This is done by jumping over adjacent\npegs.",
    "EXAMPLES": "ft_Pegs()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/pending.txt",
    "NAME": "ft_Pending()",
    "CATEGORY": "Menus/Prompts",
    "ONELINER": "Display same-line pending messages after a wait.",
    "SYNTAX": "ft_Pending( <cMsg>, [ <nRow> ], [ <nCol> ], ;\n                   [ <nWait> ], [ <cColor> ] ) --> NIL",
    "ARGUMENTS": "<cMsg> is the message string to display.\n\n<nRow> is an optional screen row for message display, default row 24.\n\n<nCol> is an optional screen col for message display, default col 0.\n\n<nWait> is an optional wait (sec) between messages, default 5 sec.\n\n<cColor> is an optional color string for displayed messages, default\n         is white text over red background.",
    "RETURNS": "NIL",
    "DESCRIPTION": "A good way to display information messages during the running\nof an application is to send them all to the _same_ line on the\nscreen where users are expected to look for them. In order to\ngive users a chance to read the current message before the next one\nis displayed we may need to insert a delay after each message.\n\nft_Pending() function displays messages by keeping track of\nthe time of the last message and providing a delay _only_ if the next\npending message is issued much too soon after the current one.\n",
    "EXAMPLES": "ft_Pending( \"Message one\", 20, 0, 3, \"W+/G\" )  // Displays \"Message one.\"\n                                               // sets row to 20, col to 0.\n                                               // wait to 3 and color to\n                                               // bright white over green.\nft_Pending( \"Message two\" )    // Displays \"Message two\", after 5 sec.\nft_Pending( \"Message three\" )  // Displays \"Message three\", after 5 sec.\n\n// Note that default row, col, wait time and color need to be set only\n// once in the very first call to ft_Pending() and only if the internal\n// default values are not appropriate."
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/pickday.txt",
    "NAME": "ft_PickDay()",
    "CATEGORY": "Menus/Prompts",
    "ONELINER": "Picklist of days of week",
    "SYNTAX": "ft_PickDay() --> cDayOfWeek",
    "ARGUMENTS": "None",
    "RETURNS": "Character string containing day of week",
    "DESCRIPTION": "This function is ideal if you need the user to select a day.",
    "EXAMPLES": "? ft_PickDay()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/poke.txt",
    "NAME": "ft_Poke()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Write a byte to a specified memory location",
    "SYNTAX": "ft_Poke( <nSegment>, <nOffset>, <nValue> ) --> lResult",
    "ARGUMENTS": "<nSegment> is the segment of the desired memory address.\n\n<nOffset>  is the offset of the desired memory address.\n\n<nValue>   is the value to write to the desired memory address.",
    "RETURNS": "<lResult> will be .T. if all parameters were valid and the function was\n          able to write the desired byte.\n<lResult> will be .F. if invalid parameters were passed.",
    "DESCRIPTION": "Use this function if you have a need to change the value at a specific\nmemory location.  The function will write the specified byte to the\nspecified address.  The value must be passed as a numeric; if the byte\nyou wish to use is stored as a character, use the hb_BCode() function\nto convert it.",
    "EXAMPLES": "? ft_Poke( 0, 0x417, 0x40 )  // Turn CapsLock on (MS-DOS)"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/popadder.txt",
    "NAME": "ft_Adder()",
    "CATEGORY": "Menus/Prompts",
    "ONELINER": "Pop up a simple calculator",
    "SYNTAX": "ft_Adder()",
    "ARGUMENTS": "None",
    "RETURNS": "NIL .... but optionally places Total of calculation in active\n         Get variable using `oGet:varPut()`",
    "DESCRIPTION": "ft_Adder() gives you an adding machine inside your Clipper 5.2\napplication. It has the basic functions add, subtract, multiply,\nand divide. You may move it from one side of the screen to the\nother. It even displays a scrollable tape, if you want it.\n\n\nThere are a few HOT Keys while using the Adder:\n\n       <D>ecimals - change # of decimals\n       <M>ove     - the Adder from right display to left\n       <T>ape     - turn the Tape Display On or Off\n       <S>croll   - the tape display\n       <DEL> ---+-- 1st Clear entry\n                +-- 2nd Clear *adder*\n       <ESC>      - Quit\n       <F10>      - return a *total* to the active get\n\n\nA couple of notes about the adder:\n\n\n1. It was designed to be used on an Enhanced keyboard with\n   separate <DEL> key. <DEL> is used to clear the adder.\n   However, it will still work on a Standard keyboard.\n\n2. You do not have to display the tape. You may turn it on\n   at any time by pressing <T>. You may *scroll* back through\n   the tape once there are more than 16 entries in the\n   adder, by pressing <S>.\n\n3. To Quit the Adder just press <ESC>. To return your Total\n   to the application press <F10>. The adder will place the\n   Total in the active GET variable using `oGet:varPut()`. The\n   adder will only return a Total to a numerical GET!\n\n4. There are many support functions that you might find\n   interesting. They are part of my personal library, but\n   are necessary to the operation of the adder.\n   You might want to pull these out to reduce the overall\n   size of the adder. Many are worth at least a little\n   time studying.\n\n5. To make ft_Adder() a Hot key from inside your application\n   at the beginning of your application add the line:\n\n          `SetKey( K_ALT_A, {|| ft_Adder() } )`\n\n   This will make <ALT+A> a key \"Hot\" and permit you to\n   Pop - Up the adder from anywhere in the application.\n\n6. If you use ft_SInkey(), you can even have active hotkeys\n   in an Inkey().\n",
    "EXAMPLES": "",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/proper.txt",
    "NAME": "ft_Proper()",
    "CATEGORY": "String",
    "ONELINER": "Convert a string to proper-name case",
    "SYNTAX": "ft_Proper( <cString> ) --> cProperName",
    "ARGUMENTS": "<cString> is the string to be converted.",
    "RETURNS": "A string of the same length as <cString>, only converted to\nproper name case (upper/lower case).",
    "DESCRIPTION": "ft_Proper() uses a brute-force algorithm to convert a string\nto propername case.  First, it capitalizes the first letter of\nall words starting after a blank, dash, or apostrophe.  This\ncatches most names, including special cases such as names\nbeginning with O' (O'Malley, O'Reilly) and hyphenated names\n(such as Susan Chia-Mei Lo).\n\nNext, it does a specific adjustment for words beginning in \"Mc\"\nIt finds the first 'Mc' and capitalizes the next character after\nit.  It does this for all occurrences of Mc.\n\nThe original ft_Proper() was written in Clipper by Glenn Scott\nand Mark Zechiel; it was re-written in C (and thus, optimized\nand enhanced) by Robert DiFalco.",
    "EXAMPLES": "? ft_Proper( \"hello world\" )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/prtesc.txt",
    "NAME": "ft_EscCode()",
    "CATEGORY": "Conversion",
    "ONELINER": "Convert Lotus style escape codes",
    "SYNTAX": "ft_EscCode( <cASCII> ) --> <cPrinterFormat>",
    "ARGUMENTS": "<cASCII> is the ASCII representation of the printer control\ncodes in Lotus 123 format (e.g. `\"\\027E\"` for `hb_BChar( 27 ) + \"E\"`)\n\n`\"\\nnn\"` will be converted to `hb_BChar( nnn )`\n`\"\\\\\"` will be converted to `\"\\\"`",
    "RETURNS": "The binary version of an ASCII coded printer setup string.",
    "DESCRIPTION": "This function is useful for allowing the user to enter printer\ncontrol codes in Lotus-style ASCII format, and then having\nthis function convert that code to the format that the printer\nneeds to receive.",
    "EXAMPLES": "// FIXME\nLOCAL cSetup := \"\\015\"   // default = Epson compressed print\nUserInput( @cSetup )     // Let user modify setup code\nSET DEVICE TO PRINTER    // get ready to print\n?? ft_EscCode( cSetup )  // Output the converted code"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/prtscr.txt",
    "NAME": "ft_PrtScr()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Enable or disable the Print Screen key",
    "SYNTAX": "ft_PrtScr( [ <lSetStat> ] ) --> lCurStat",
    "ARGUMENTS": "<lSetStat> set to .T. will enable the Print Screen key,\n.F. will disable it.  If omitted, leaves status as is.",
    "RETURNS": "The current state: .T. if enabled, .F. if disabled.",
    "DESCRIPTION": "This function is valuable if you have a need to disable the\n<PrintScreen> key.  It works by fooling the BIOS into thinking that\na printscreen is already in progress.  The BIOS will then refuse\nto invoke the printscreen handler.",
    "EXAMPLES": "ft_PrtScr( .F. )  // Disable the printscreen key\nft_PrtScr( .T. )  // Enable the printscreen key\n? ft_PrtScr()     // Get the current status",
    "SEEALSO": "ft_CapLock(), ft_Ctrl(), ft_NumLock(), ft_Shift(), ft_Alt()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/putkey.txt",
    "NAME": "ft_PutKey()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Stuff a keystroke into the keyboard buffer",
    "SYNTAX": "ft_PutKey( <nKeyValue> ) --> lResult",
    "ARGUMENTS": "<nKeyValue> is the Inkey() value of the keystroke to be stuffed.",
    "RETURNS": ".T. if the keystroke was put into the keyboard buffer.\n.F. if <nKeyValue> was invalid or the buffer was full.",
    "DESCRIPTION": "This function is similar to the KEYBOARD command, with a few\nexceptions. First, this function does not clear the keyboard buffer\nbefore inserting the keystroke.  In addition, since it uses the\nInkey() value, you can stuff any key, including function keys, into\nthe keyboard buffer. However, this also means that unlike the KEYBOARD\ncommand, you can only stuff one keystroke at a time.\n\nYou can easily create a User-Defined Command that makes this function\neven more like the KEYBOARD command.  For example,\n```\n#xcommand KEYSTROKE <key> => ft_PutKey( <key> )\n```\nwill create a command called KEYSTROKE that could be used as a\ncompanion command to KEYBOARD.  The only difference is that it would\ninsert a single keystroke instead of a string.\n\nBe aware that this function makes use of Clipper's internal event\nhandler.  If you don't like using internals, then don't use this\nfunction, you sniveling coward.",
    "EXAMPLES": "ft_PutKey( -9 )   // Stuff the <F10> key\nft_PutKey( 276 )  // Stuff the <Alt+T> key\nKEYBOARD 28       // Stuff the <F1> key using a User-Defined Command"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/pvid.txt",
    "NAME": "ft_PushVid()",
    "CATEGORY": "Video",
    "ONELINER": "Save current video states on internal stack.",
    "SYNTAX": "ft_PushVid() --> nStackSize",
    "ARGUMENTS": "None",
    "RETURNS": "The current size of the internal stack (i.e. the number of times\nft_PushVid() has been called).",
    "DESCRIPTION": "Menus, picklists, browses, and other video-intensive items often\nrequire you to save certain video states -- screen image, cursor\nposition, and so forth.  Constantly saving and restoring these items\ncan get very tedious.  This function attempts to alleviate this\nproblem.  When called, it saves the cursor position, color setting,\nscreen image, cursor style, blink setting, scoreboard setting, snow\nsetting, and maximum row and column to a series of static arrays.  All\nthat is needed to restore the saved settings is a call to ft_PopVid().",
    "EXAMPLES": "ft_PushVid()  // Save the current video states",
    "SEEALSO": "ft_PopVid()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/pvid.txt",
    "NAME": "ft_PopVid()",
    "CATEGORY": "Video",
    "ONELINER": "Restore previously saved video states.",
    "SYNTAX": "ft_PopVid() --> nStackSize",
    "ARGUMENTS": "None",
    "RETURNS": "The number of items remaining in the internal stack.",
    "DESCRIPTION": "This is the complementary function to ft_PushVid().  At some time\nafter saving the video states it will probably be necessary to restore\nthem.  This is done by restoring the settings from the last call to\nft_PushVid().  The number of items on the internal stack is then\nreduced by one.  Note that the use of stack logic means that items on\nthe stack are retrieved in Last In First Out order.",
    "EXAMPLES": "ft_PopVid()  // Restore video states",
    "SEEALSO": "ft_PushVid()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/qtr.txt",
    "NAME": "ft_Qtr()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Return Calendar or Fiscal Quarter Data.",
    "SYNTAX": "ft_Qtr( [ <dGivenDate> ], [ <nQtrNum> ] ) --> aDateInfo",
    "ARGUMENTS": "<dGivenDate> is any valid date in any date format.  Defaults\nto current system date if not supplied.\n\n<nQtrNum> is a number from 1 to 4 signifying a quarter.\nDefaults to current quarter if not supplied.",
    "RETURNS": "A three element array containing the following data:\n```\n   aDateInfo[ 1 ] - The year and quarter as a character string \"YYYYQQ\"\n   aDateInfo[ 2 ] - The beginning date of the quarter\n   aDateInfo[ 3 ] - The ending date of the quarter\n```",
    "DESCRIPTION": "ft_Qtr() returns an array containing data about the quarter\ncontaining the given date.\n\nNormally the return data will be based on a year beginning\non January 1st with weeks beginning on Sunday.\n\nThe beginning of year date and/or beginning of week day can be\nchanged by using ft_DateCnfg(), which will affect all subsequent\ncalls to ft_Qtr() until another call to ft_DateCnfg().\n\nThe beginning of year date and beginning of week day may be reset\nto January 1 and Sunday by calling ft_DateCnfg() with no\nparameters.",
    "EXAMPLES": "LOCAL aDateInfo\n\n// get info about quarter containing 1990-09-15\naDateInfo := ft_Qtr( 0d19900915 )\n? aDateInfo[ 1 ]  // --> 199003      (3rd quarter)\n? aDateInfo[ 2 ]  // --> 1990-07-01  beginning of quarter 3\n? aDateInfo[ 3 ]  // --> 1990-09-30  end of week quarter 3\n\n// get info about quarter 2 in year containing 1990-09-15\naDateInfo := ft_Qtr( 0d19900915, 2 )\n? aDateInfo[ 1 ]  // --> 199002\n? aDateInfo[ 2 ]  // --> 1990-04-01  beginning of quarter 2\n? aDateInfo[ 3 ]  // --> 1990-06-30  end of quarter 2\n\n// get info about quarter 2 in current year (1991)\naDateInfo := ft_Qtr( , 2 )\n? aDateInfo[ 1 ]  // --> 199102\n? aDateInfo[ 2 ]  // --> 1991-04-01  beginning of quarter 2\n? aDateInfo[ 3 ]  // --> 1991-06-30  end of quarter 2",
    "SEEALSO": "ft_DateCnfg(), ft_Week(), ft_Month(), ft_Year()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/rand1.txt",
    "NAME": "ft_Rand1()",
    "CATEGORY": "Math",
    "ONELINER": "Generate a random number",
    "SYNTAX": "ft_Rand1( <nMax> ) --> nRand",
    "ARGUMENTS": "<nMax>  Maximum limit of value to be produced.",
    "RETURNS": "<nRand> is a random number between 0 (inclusive) and <nMax> (exclusive).",
    "DESCRIPTION": "Generates a non-integer random number based on the Linear\nCongruential Method.\n\nIf you need a random number between 1 and <nMax> inclusive, Int()\nthe result and add 1.\n\nIf you need a random number between 0 and <nMax> inclusive,\nthen you should Round() the result.",
    "EXAMPLES": "? Int( ft_Rand1( 100 ) ) + 1   // 1 <= nResult <= 100\n? Round( ft_Rand1( 100 ), 0 )  // 0 <= nResult <= 100\n? ft_Rand1( 1 )                // 0 <= nResult < 1"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/reboot.txt",
    "NAME": "ft_Reboot()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Force a warm or cold boot",
    "SYNTAX": "ft_Reboot( <nBootType> ) --> NIL",
    "ARGUMENTS": "<nBootType> is used to indicate the type of reboot.  A value of zero\nwill cause a cold boot, while any other value will cause a warm boot.",
    "RETURNS": "NIL",
    "DESCRIPTION": "This function is valuable if you need to reboot the PC for some\nreason; e.g. an installation routine that modifies `CONFIG.SYS` or\n`AUTOEXEC.BAT`.",
    "EXAMPLES": "#define COLD  0\n#define WARM  1\n\nft_Reboot( WARM )  // Issue a warm boot"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/restsets.txt",
    "NAME": "ft_RestSets()",
    "CATEGORY": "Environment",
    "ONELINER": "Restore status of all SET command settings",
    "SYNTAX": "ft_RestSets( [ <aOldSets> ] ) --> NIL",
    "ARGUMENTS": "<aOldSets> is an array of SET settings created by ft_SaveSets()",
    "RETURNS": "NIL",
    "DESCRIPTION": "This function \"restores\" the SET Settings, i.e., it sets them to the\nvalues in the array <aOldSets>.  The following `SET`s are not currently\nsupported: FILTER, FORMAT, FUNCTION, INDEX, KEYS, MODE, ORDER,\nPROCEDURE, RELATION, TYPEAHEAD",
    "EXAMPLES": "// FIXME\nft_RestSets( aOldSets )",
    "SEEALSO": "ft_SaveSets(), ft_SetCentury()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/rmdir.txt",
    "NAME": "ft_RmDir()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Delete a subdirectory",
    "SYNTAX": "ft_RmDir( <cDirName> ) --> nResult",
    "ARGUMENTS": "<cDirName> is the name of the directory to delete.",
    "RETURNS": "<table-noheader>\n 0   if successful\n 3   if Path Not Found\n 5   if Access Denied (directory not empty)\n 16  if attempt to delete current directory.\n 99  if invalid parameters passed\n</table>",
    "DESCRIPTION": "This function is useful if you need to remove a subdirectory for\nsome reason.",
    "EXAMPLES": "? ft_RmDir( \"mydir\" )\n? ft_RmDir( hb_DirSepToOS( \"/mydir\" ) )\n? ft_RmDir( hb_DirSepToOS( \"./mydir\" ) )\n? ft_RmDir( hb_DirSepToOS( \"../mydir\" ) )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/round.txt",
    "NAME": "ft_Round()",
    "CATEGORY": "Math",
    "ONELINER": "Rounds a number to a specific place",
    "SYNTAX": "ft_Round( <nNumber> [, <nRoundToAmount>           ;\n          [, <cRoundType>  [, <cRoundDirection>   ;\n          [, <nAcceptableError> ] ] ] ] )           --> nNumber",
    "ARGUMENTS": "<nNumber> is the number to round\n\n<nRoundToAmount> is the fraction to round to or the number of places,\ndefault is 2.\n\n<cRoundType> is the type of rounding desired\n\n   \"D\" for Decimal       (3 for thousandth, 1/1000)  (default)\n   \"F\" for Fraction      (3 for thirds, 1/3)\n   \"W\" for Whole numbers (3 for thousand, 1000)\n\n<cRoundDirection> is the direction to round the number toward\n\n   \"U\" to round Up      1.31 -->  1.4\n                       -1.31 --> -1.4\n   \"D\" to round Down    1.36 -->  1.3\n                       -1.36 --> -1.3\n   \"N\" to round Normal  1.5  -->  2\n                       -1.5  --> -2\n                        1.49 -->  1\n                       -1.49 --> -1\n\n<nAcceptableError> is the amount that is considered acceptable\nto be within, i.e., if you're within this amount of the number\nyou don't need to round",
    "RETURNS": "The number, rounded as specified.",
    "DESCRIPTION": "This function will allow you to round a number.  The following can\nbe specified:\n  a. Direction (up, down or normal - normal is 4/5 convention)\n  b. Type (whole, decimal, fraction)\n  c. Amount (100's, 5 decimals, 16th, etc.)",
    "EXAMPLES": "LOCAL nVal := 1234.567\n\n#define NEAREST_DECIMAL       \"D\"\n#define NEAREST_FRACTION      \"F\"\n#define NEAREST_WHOLE_NUMBER  \"W\"\n#define ROUND_DOWN            \"D\"\n#define ROUND_NORMAL          \"N\"\n#define ROUND_UP              \"U\"\n\n// round normal to 2 decimal places\n? ft_Round( nVal )\n\n// round normal to 6 decimal places\n? ft_Round( nVal, 6 )\n\n// round to nearest thousands\n? ft_Round( nVal, 3, NEAREST_WHOLE_NUMBER )\n\n// round Up to nearest third\n? ft_Round( nVal, 3, NEAREST_FRACTION, ROUND_UP )\n\n// round down to 3 decimals Within .005\n? ft_Round( nVal, 3, , ROUND_DOWN, .005 )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/savearr.txt",
    "NAME": "ft_SaveArr()",
    "CATEGORY": "Array",
    "ONELINER": "Save Clipper array to a disc file.",
    "SYNTAX": "ft_SaveArr( <aArray>, <cFileName>, <nErrorCode> ) --> lRet",
    "ARGUMENTS": "<aArray> is any Clipper array except those containing\ncompiled code blocks.\n\n<cFileName> is a DOS file name.\n\n<nErrorCode> will return any DOS file error.\n\nAll arguments are required.",
    "RETURNS": ".F. if there was a DOS file error or the array contained\ncode blocks, otherwise returns .T.",
    "DESCRIPTION": "ft_SaveArr() saves any Clipper array, except those\ncontaining compiled code blocks, to a disc file.  The\narray can be restored from the disc file using\nft_RestArr().\n\n[1992-10-01 Librarian note:\n\nThis function does not appear to work with multi-dimensional\narrays.  If you'd care to modify it to support this feature,\nplease do and send it to Glenn Scott 71620,1521.]",
    "EXAMPLES": "LOCAL aArray := { ;\n   { \"Invoice 1\", 0d19910415, 1234.32, .T. }, ;\n   { \"Invoice 2\", Date(), 234.98, .F. }, ;\n   { \"Invoice 3\", Date() + 1, 0, .T. } }\nLOCAL nErrorCode := 0, aSave\nft_SaveArr( aArray, \"invoice.dat\", @nErrorCode )\nIF nErrorCode == 0\n   aSave := ft_RestArr( \"invoice.dat\", @nErrorCode )\n   IF nErrorCode != 0\n      ? \"Error restoring array\"\n   ENDIF\nELSE\n   ? \"Error writing array\"\nENDIF",
    "SEEALSO": "ft_RestArr()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/savearr.txt",
    "NAME": "ft_RestArr()",
    "CATEGORY": "Array",
    "ONELINER": "Restore a Clipper array from a disc file",
    "SYNTAX": "ft_RestArr( <cFileName>, <nErrorCode> ) --> aArray",
    "ARGUMENTS": "<cFileName> is a DOS file name.\n\n<nErrorCode> will return any DOS file error.\n\nAll arguments are required.",
    "RETURNS": "Return an array variable.",
    "DESCRIPTION": "ft_RestArr() restores an array which was saved to\na disc file using ft_SaveArr().\n\n[1992-10-01 Librarian note:\n\nThis function does not appear to work with multi-dimensional\narrays.  If you'd care to modify it to support this feature,\nplease do and send it to Glenn Scott 71620,1521.]",
    "EXAMPLES": "LOCAL aArray := { ;\n   { \"Invoice 1\", 0d19910415, 1234.32, .T. }, ;\n   { \"Invoice 2\", Date(), 234.98, .F. }, ;\n   { \"Invoice 3\", Date() + 1, 0, .T. } }\nLOCAL nErrorCode := 0, aSave\nft_SaveArr( aArray, \"invoice.dat\", @nErrorCode )\nIF nErrorCode == 0\n   aSave := ft_RestArr( \"invoice.dat\", @nErrorCode )\n   IF nErrorCode != 0\n      ? \"Error restoring array\"\n   ENDIF\nELSE\n   ? \"Error writing array\"\nENDIF",
    "SEEALSO": "ft_SaveArr()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/savesets.txt",
    "NAME": "ft_SaveSets()",
    "CATEGORY": "Environment",
    "ONELINER": "Save the status of all the SET command settings",
    "SYNTAX": "ft_SaveSets() --> aOldSets",
    "ARGUMENTS": "None",
    "RETURNS": "An array containing the values of the supported SETs.",
    "DESCRIPTION": "This function saves the SET Settings, i.e., it copies them into an\narray, <aOldSets>.  The following SETs are not currently supported:\nFILTER, FORMAT, FUNCTION, INDEX, KEYS, MODE, ORDER, PROCEDURE,\nRELATION, TYPEAHEAD",
    "EXAMPLES": "LOCAL aOldSets := ft_SaveSets()\n? hb_ValToExp( aOldSets )",
    "SEEALSO": "ft_RestSets(), ft_SetCentury()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/scancode.txt",
    "NAME": "ft_ScanCode()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Wait for key-press and return keyboard scan code",
    "SYNTAX": "ft_ScanCode() --> cCode",
    "ARGUMENTS": "None",
    "RETURNS": "A two-character string, corresponding to the keyboard scan code.",
    "DESCRIPTION": "ft_ScanCode() enables you to distinguish the different scan-codes\nof similar keys (such as Grey minus versus regular minus), thus\nincreasing the number of keys your input routine can recognize.\n\nIt works like Inkey(), in that it waits for a key to be pressed.\nThe scan code consists of two bytes, which are returned as a\ntwo-character string.\n\nFor example, calling ft_ScanCode() and pressing the Grey-minus\nkey will return a two character string:\n```\nhb_BChar( 45 ) + hb_BChar( 74 )\n```\nLastKey() is not updated by ft_ScanCode(), so don't try to\ntest LastKey() to see what was pressed during an ft_ScanCode()\ncall.  Simply assign the return value to a variable and test\nthat (see the test driver below).\n\n*  This was adapted from a short C routine posted by John Kaster on\n   NANFORUM.  It was written in Clipper to help demonstrate the\n   ft_int86() function of the Nanforum Toolkit.\n\nThis program requires ft_int86().",
    "EXAMPLES": "? ft_ScanCode()\n\n// <grey-> --> hb_BChar( 45 ) + hb_BChar( 74 )\n// <->     --> hb_BChar( 45 ) + hb_BChar( 12 )\n// <grey+> --> hb_BChar( 43 ) + hb_BChar( 78 )\n// <+>     --> hb_BChar( 43 ) + hb_BChar( 13 )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/scregion.txt",
    "NAME": "ft_SavRgn()",
    "CATEGORY": "Video",
    "ONELINER": "Save a screen region for later display",
    "SYNTAX": "ft_SavRgn( <nTop>, <nLeft>, <nBottom>, <nRight> ) --> cScreen",
    "ARGUMENTS": "<nTop>, <nLeft>, <nBottom>, and <nRight> define the portion of the\nscreen to save.  Allowable values are 0 through 255.",
    "RETURNS": "ft_SavRgn() returns the saved screen region and its coordinates\nas a character string.",
    "DESCRIPTION": "ft_SavRgn() is similar to Clipper's SaveScreen(), but it saves the\nscreen coordinates as well as the display information.  The saved\narea can be restored by passing the returned string to ft_RstRgn().\n\nNote that the strings returned from ft_SavRgn() and Clipper's\nSaveScreen() are not interchangeable.  A screen region saved with\nwith ft_SavRgn() must be restored using ft_RstRgn().\n\nft_SavRgn() calls Clipper's SaveScreen().  Refer to the Clipper\ndocumentation for more information regarding this function.",
    "EXAMPLES": "// The following example uses ft_SavRgn() and ft_RstRgn() to save\n// and restore a portion of the screen.\nLOCAL cScreen\n\n@ 0, 0, 24, 79 BOX \"111111111\"          // fill the screen with 1's\ncScreen := ft_SavRgn( 10, 10, 20, 30 )  // save a region\n@ 0, 0, 24, 79 BOX \"222222222\"          // fill the screen with 2's\nft_RstRgn( cScreen )                    // restore the 1's region",
    "SEEALSO": "ft_RstRgn(), ft_RgnStack()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/scregion.txt",
    "NAME": "ft_RstRgn()",
    "CATEGORY": "Video",
    "ONELINER": "Restore region of the screen saved with ft_SavRgn()",
    "SYNTAX": "ft_RstRgn( <cScreen>, [ <nTop> ], [ <nLeft> ] ) --> NIL",
    "ARGUMENTS": "<cScreen> is a screen region previously returned from ft_SavRgn().\n\n<nTop> and <nLeft> are optional parameters that define a new location\nfor the upper left corner of the screen area contained in <cScreen>.\nAllowable values are 0 through 255.",
    "RETURNS": "ft_RstRgn() returns NIL.",
    "DESCRIPTION": "ft_RstRgn() restores a screen region previously saved with\nft_SavRgn().  Calling ft_RstRgn() with <cScreen> as the only\nparameter will restore the saved region to its original location.\n<nTop> and <nLeft> may be used to define a new location for the\nupper left corner of the saved region.\n\n<nTop> and <nLeft> are dependent upon each other. You may not\nspecify one without the other.\n\nft_RstRgn() calls Clipper's RestScreen().  Refer to the Clipper\ndocumentation for more information regarding this function.",
    "EXAMPLES": "// The following example uses ft_RstRgn() to restore a saved portion\n// of the screen to different locations.\nLOCAL cScreen\n\n@ 0, 0, 24, 79 BOX \"111111111\"          // fill the screen with 1's\ncScreen := ft_SavRgn( 10, 10, 20, 30 )  // save a region\n@ 0, 0, 24, 79 BOX \"222222222\"          // fill the screen with 2's\nft_RstRgn( cScreen )                    // restore the 1's region\n@ 0, 0, 24, 79 BOX \"222222222\"          // fill the screen with 2's\nft_RstRgn( cScreen, 15, 15 )            // restore to a different location\n@ 0, 0, 24, 79 BOX \"222222222\"          // fill the screen with 2's\nft_RstRgn( cScreen, 20, 60 )            // restore to a different location",
    "SEEALSO": "ft_SavRgn(), ft_RgnStack()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/scregion.txt",
    "NAME": "ft_RgnStack()",
    "CATEGORY": "Video",
    "ONELINER": "Push or pop a saved screen region on or off the stack",
    "SYNTAX": "ft_RgnStack( <cAction>, [ <nTop> ], [ <nLeft> ], [ <nBottom> ],\n   [ <nRight> ] ) --> NIL",
    "ARGUMENTS": "<cAction> determines what action ft_RgnStack() will take.  The\nallowable values for this parameter are \"push\", \"pop\", and \"pop all\".\nIf the function is called with any other string as the first parameter\nno action is performed.\n\n<cAction> with a value of \"push\" will push a saved screen region onto\nthe stack.  A value of \"pop\" will restore the most recently pushed\nscreen region.  \"pop all\" tells the function to restore all screen\nimages which are currently on the stack.\n\nThe use of <nTop>, <nLeft>, <nBottom>, and <nRight> depends on the\n<cAction> parameter.  If <cAction> is \"push\", the next four parameters\ndefine the screen region to save.  If <cAction> is \"pop\" or \"pop all\"\nthe following four parameters are ignored.",
    "RETURNS": "ft_RgnStack() returns NIL.",
    "DESCRIPTION": "ft_RgnStack() allows multiple screens to be saved and restored from\na stack.  The stack is implemented with Clipper static array that is\nvisible only to ft_RgnStack().\n\nThe purpose of ft_RgnStack() is to allow multiple screen regions to be\nmanaged without the need to remember the original coordinates or to\ncreate variables for each one.\n\nWhen called with \"push\", ft_RgnStack() places the saved screen area\nat the end of the static array.  The array size is incremented by one\nto accommodate the new screen area.\n\nWhen called with \"pop\", the function restores the screen image stored\nin the last element of the array, and the array size is decremented by\none.  If \"pop all\" is specified, all the saved screens are restored\nuntil the array is empty.\n\nft_RgnStack() calls ft_SavRgn() and ft_RstRgn().  Refer to the\ndocumentation for these two functions for more information.",
    "EXAMPLES": "// The following example uses ft_RgnStack() to save and restore various\n// sections of the screen.\n\nLOCAL GetList := {}\n@ 0, 0, 24, 79 BOX \"111111111\"         // fill the screen with 1's\nft_RgnStack( \"push\", 10,  5, 15, 15 )  // push a region\n@ 0, 0, 24, 79 BOX \"222222222\"         // fill the screen with 2's\nft_RgnStack( \"push\", 10, 20, 15, 30 )  // push a region\n@ 0, 0, 24, 79 BOX \"333333333\"         // fill the screen with 3's\nft_RgnStack( \"push\", 10, 35, 15, 45 )  // push a region\n@ 0, 0, 24, 79 BOX \"444444444\"         // fill the screen with 4's\nft_RgnStack( \"push\", 10, 50, 15, 60 )  // push a region\n@ 0, 0, 24, 79 BOX \"555555555\"         // fill the screen with 5's\nft_RgnStack( \"push\", 10, 65, 15, 75 )  // push a region\nCLEAR\nft_RgnStack( \"pop\" )      // restore the 5's region\nft_RgnStack( \"pop\" )      // restore the 4's region\nft_RgnStack( \"pop all\" )  // restore the 3's, 2's and 1's regions",
    "SEEALSO": "ft_SavRgn(), ft_RstRgn()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/setdate.txt",
    "NAME": "ft_SetDate()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Set the DOS system date",
    "SYNTAX": "ft_SetDate( <dDate> ) --> lResult",
    "ARGUMENTS": "<dDate> is a Clipper date variable that you want to set the current\nOS system date to.\n\nIt is up to you to send in a valid date.  The\nyear must be within the range 1980 through 2099.  If the OS\nthinks the date is not valid, it won't change the date.",
    "RETURNS": "<lResult> is simply the result of ft_int86(), passed back\nto your program.",
    "DESCRIPTION": "ft_SetDate() uses NANFOR.LIB's ft_int86() function to invoke\nthe DOS Set Date service (Interrupt 33, service 43).",
    "EXAMPLES": "// The following program takes a date from the command-line and sets\n// the OS system date:\nLOCAL dDate := Date() + 1\n? \"Setting date to:\", dDate\nft_SetDate( dDate )\n? \"Today is now:\", Date()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/setlastk.txt",
    "NAME": "ft_LastKey()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Force LastKey() to return a programmer-defined value.",
    "SYNTAX": "ft_LastKey( <nKey> ) --> NIL",
    "ARGUMENTS": "<nKey> is the Inkey() value of the desired key.",
    "RETURNS": "NIL",
    "DESCRIPTION": "It is occasionally useful to force LastKey() to return a known value.\nThis is easily accomplishing by using the KEYBOARD command, but this\nhas undesirable side effects (the keyboard buffer is cleared, and\nthe keystroke is processed whether you needed it to be or not).  This\nfunction accomplishes the same task but without the side effects.  It\ndoes so by directly modifying the memory location where Clipper stores\nthe LastKey() value.\n\nSome highly unorthodox programming techniques, not to mention rather\nstrange use of Clipper internals, was necessary to make this function\nwork.  If this makes you uncomfortable, then don't use this function,\nyou worthless crybaby.",
    "EXAMPLES": "#include \"inkey.ch\"\n\nhb_keyPut( K_ESC )\n? LastKey()  // --> 27 (K_ESC)\n\nft_LastKey( K_F1 )\n? LastKey()  // --> 28 (K_F1)"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/settime.txt",
    "NAME": "ft_SetTime()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Set the DOS system time",
    "SYNTAX": "ft_SetTime( <cTime> ) --> lResult",
    "ARGUMENTS": "<cTime> is a string in the form <hh:mm:ss> that you want to set\nthe current DOS system time to.\n\nUse 24-hour time.  It is up to you to send in a valid time.  If\nDOS doesn't think it is valid, it won't reset the time anyway.",
    "RETURNS": "<lResult> is simply the result of ft_int86(), passed back\nto your program.\n",
    "DESCRIPTION": "ft_SetTime() uses NANFOR.LIB's ft_int86() function to invoke\nthe DOS Set Time service (Interrupt 33, service 45).\n",
    "EXAMPLES": "// The following program takes a time string from the command-line and sets\n// the DOS system time:\nLOCAL cTime := Time()\n? \"Setting time to:\", cTime + \"... \"\nft_SetTime( cTime )\n? \"Time is now:\", Time()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/shadow.txt",
    "NAME": "ft_Shadow()",
    "CATEGORY": "Video",
    "ONELINER": "Draw a non-destructive shadow on the screen",
    "SYNTAX": "ft_Shadow( <nTop>, <nLeft>, <nBottom>, <nRight> [ ,<nAttr>] ) --> NIL",
    "ARGUMENTS": "<nTop>    is the top row of the shadow area.\n<nLeft>   is the upper left column of the shadow area.\n<nBottom> is the bottom row of the shadow area.\n<nRight>  is the lower right column of the shadow area.\n<nAttr>   is optional and is the screen attribute to use for drawing\n          the shadow.  If not specified, the default is 8.",
    "RETURNS": "NIL",
    "DESCRIPTION": "This function allows you to implement the popular \"shadow effect.\"  It\ndraws a shadow using the specified screen coordinates.  The shadow\nis drawn along the bottom and right side of the specified region.",
    "EXAMPLES": "ft_Shadow( 10, 10, 15, 50, 8 )   // draw a dim shadow\nft_Shadow( 10, 10, 15, 40, 47 )  // draw a green shadow"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/shift.txt",
    "NAME": "ft_Shift()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Determine status of shift key",
    "SYNTAX": "ft_Shift() --> lValue",
    "ARGUMENTS": "None",
    "RETURNS": ".T. if a shift key is pressed, .F. if otherwise.",
    "DESCRIPTION": "This function is useful for times you need to know whether or not the\nshift key is pressed, such as during a MemoEdit().",
    "EXAMPLES": "IF ft_Shift()\n   @ 0, 0 SAY \"Shift\"\nELSE\n   @ 0, 0 SAY \"     \"\nENDIF",
    "SEEALSO": "ft_CapLock(), ft_Ctrl(), ft_NumLock(), ft_PrtScr(), ft_Alt()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/sinkey.txt",
    "NAME": "ft_SInkey()",
    "CATEGORY": "Keyboard/Mouse",
    "ONELINER": "Replacement for Inkey() that tests for `SET KEY` procedures",
    "SYNTAX": "ft_SInkey( [ <nWaitTime> ] ) --> nKey",
    "ARGUMENTS": "<nWaitTime> is the number of seconds to wait.  If zero,\nft_SInkey() will wait indefinitely for a key-press.  If not\npassed, ft_SInkey() does not wait for a key-press.  If NIL,\nit is treated the same as 0.",
    "RETURNS": "The Inkey() value of the key pressed.",
    "DESCRIPTION": "ft_SInkey() is similar to the function provided by Nantucket in\nkeyboard.prg, with one significant difference: you can pass NIL\nto Inkey(), which will be treated as a zero (i.e., wait indefinitely\nfor key-press).  Therefore, it is necessary to differentiate between\nan explicit NIL and one that is a result of a formal parameter _not_\nbeing received.\n\nft_SInkey() differs from the standard Inkey() in that it will\nrespond to any keys set with `SET KEY TO` or SetKey().",
    "EXAMPLES": "#include \"inkey.ch\"\nSetKey( K_F1, {| n, l, r | HELP( n, l, r ) } )\n? ft_SInkey( 0 )        // HELP() will be called if <F1> pressed\nSTATIC PROCEDURE HELP( n, l, r )\n   ? n, l, r\n   RETURN"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/sleep.txt",
    "NAME": "ft_Sleep()",
    "CATEGORY": "Menus/Prompts",
    "ONELINER": "Wait for a specified amount of time",
    "SYNTAX": "ft_Sleep( <nSeconds>, [<nInitial>] ) --> NIL",
    "ARGUMENTS": "<nSeconds> is the number of seconds to pause\n\n<nInitial> is an optional clock value (from a call to Seconds())\n           from which the <nSeconds> seconds are to elapse. Useful\n           for setting a minimum time between the start of events\n           which could take a variable amount of time due to the\n           execution of intervening code.",
    "RETURNS": "NIL",
    "DESCRIPTION": "This routine will wait a specified period of time. It provides\nresolution based upon the execution of the Seconds() function.\nIt does not use an input state such as Inkey(). The specified time\nis the minimum time sleeping and will usually be slightly longer.\n\nThe second optional argument allows one to begin timing an event\nprior to executing some operation. This is useful when, for example,\nyou input a key or mouse click and wish to do something but still want\nto note if the user double entered (mouse or key) within a certain time\nwhich in turn may have meaning within your program's context.\n\nThe routine correctly handles passing through midnight but will not\nwork for more than 24 hours.",
    "EXAMPLES": "LOCAL nTime\n// Example 1:\nft_Sleep( 10.0 )    // Sleep for 10.0 seconds\n// Example 2:\nnTime := Seconds()  // usually after some interrupt from mouse or\n                    // keyboard\n\n// ... intervening code ...\n\n// ft_Sleep( 0.5, nTime )  // Sleep until the system clock is\n                           // nTime + 0.5 seconds."
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/sqzn.txt",
    "NAME": "ft_Sqzn()",
    "CATEGORY": "Conversion",
    "ONELINER": "Compress a numeric value into a character string",
    "SYNTAX": "ft_Sqzn( <nValue> [, <nSize> [, <nDecimals> ] ] ) --> cCompressed",
    "ARGUMENTS": "<nValue>       - The numeric value to be compressed\n<nSize>        - Optional size of numeric field, defaults to 10\n<nDecimals>    - Optional number of decimal places, defaults to 0",
    "RETURNS": "<cCompressed>  - Compressed string, 50% the size of <nSize>",
    "DESCRIPTION": "The ft_Sqzn() function allows a numeric value to be compressed when\nstored in the database.  The compression is 50% the storage space\nof the original number.  The companion function, ft_Unsqzn() returns\nthe original number from the compressed string.",
    "EXAMPLES": "? hb_StrToHex( ft_Sqzn( 12345678, 8 ) )\n? hb_StrToHex( ft_Sqzn( 123.45, 12, 2 ) )",
    "SEEALSO": "ft_Unsqzn()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/sqzn.txt",
    "NAME": "ft_Unsqzn()",
    "CATEGORY": "Conversion",
    "ONELINER": "Uncompress a numeric compressed by ft_Sqzn()",
    "SYNTAX": "ft_Unsqzn( <cCompressed>, <nSize> [, <nDecimals> ] ) --> nValue",
    "ARGUMENTS": "<cCompressed>  - Compressed string, obtained from ft_Sqzn()\n\n<nSize>        - Size of numeric field\n\n<nDecimals>    - Optional number of decimal places",
    "RETURNS": "<nValue>       - Uncompressed numeric value",
    "DESCRIPTION": "The ft_Unsqzn() function returns the numeric value from the compressed\nstring.  The compression is 50% the storage space of the original\nnumber.  The original number must have been compressed using the\nft_Sqzn() function.\n\nThis function, along with ft_Sqzn() can be used to reduce disk storage\nrequirements for numeric fields in a database file.",
    "EXAMPLES": "? ft_Unsqzn( ft_Sqzn( 12345678, 8 ), 8 )\n? ft_Unsqzn( ft_Sqzn( 123.45, 12, 2 ), 12, 2 )",
    "SEEALSO": "ft_Sqzn()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/stod.txt",
    "NAME": "ft_SToD()",
    "CATEGORY": "Conversion",
    "ONELINER": "Convert a date string to a Clipper date data type",
    "SYNTAX": "ft_SToD( <cDateStr> ) --> dDateType",
    "ARGUMENTS": "<cDateStr> is a Clipper string in the format \"CCYYMMDD\".",
    "RETURNS": "A Clipper date type.",
    "DESCRIPTION": "This function allows the programmer to hard code a date into the\nprogram without knowing what the current date type is.  This\nfunction is the converse of the Clipper DToS() function.",
    "EXAMPLES": "? ft_SToD( \"19901127\" )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/sysmem.txt",
    "NAME": "ft_SysMem()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Determine the amount of conventional memory installed",
    "SYNTAX": "ft_SysMem() --> nMemSize",
    "ARGUMENTS": "None",
    "RETURNS": "A numeric corresponding to the number of KiB memory.",
    "DESCRIPTION": "ft_SysMem() simply reports the amount of conventional memory\ninstalled.",
    "EXAMPLES": "? \"Conventional memory:\", hb_ntos( ft_SysMem() ), \"KiB installed\""
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/tbwhile.txt",
    "NAME": "ft_BrwsWhl()",
    "CATEGORY": "Menus/Prompts",
    "ONELINER": "Browse an indexed database limited to a while condition",
    "SYNTAX": "ft_BrwsWhl( <aFields>, <bWhileCond>, <cKey>,                  ;\n            [ <nFreeze> ], [ <lSaveScrn> ], [ <cColorList> ], ;\n            [ <cColorShadow> ], [ <nTop> ], [ <nLeft> ],      ;\n            [ <nBottom> ], [ <nRight> ] ) --> nRecno",
    "ARGUMENTS": "<aFields> is array of field blocks of fields you want to display.\n   Example to set up last name and first name in array:\n   ```\n   aFields := {}\n   AAdd( aFields, { \"Last Name\" , {|| Names->Last }  } )\n   AAdd( aFields, { \"First Name\", {|| Names->First } } )\n   ```\n\n<bWhileCond> is the limiting WHILE condition as a block.\n   Example 1: `{|| Names->Last == \"JONES\" }`\n   Example 2: `{|| Names->Last == \"JONES\" .AND. Names->First == \"A\"  }`\n\n<cKey> is the key to find top condition of WHILE.\n   ```\n   cLast  := \"JONES     \"\n   cFirst := \"A\"\n   ```\n   Example 1: `cKey := cLast`\n   Example 2: `cKey := cLast + cFirst`\n\n<nFreeze> is number of fields to freeze in TBrowse().  Defaults\nto 0 if not passed.\n\n<lSaveScrn> is a logical indicating whether or not you want to\nsave the screen from the calling program.  Defaults to .T. if\nnot passed.\n\n<cColorList> is a list of colors for the TBrowse() columns.\nThe 1st color is used as SAY/TBrowse() Background and the\n3rd and 4th colors are used as part of `column:defColor := { 3, 4 }`\n\nThus if you pass a <cColorList>, you _must_ pass at least 4 colors.\nDefaults to `N/W, N/BG, B/W, B/BG, B/W, B/BG, R/W, B/R` if not passed.\n\n<cColorShad> is the color of the TBrowse box shadow.  Defaults\nto \"N/N\" if not passed.\n\n<nTop>, <nLeft>, <nBottom>, <nRight> are the coordinates of\nthe area to display the TBrowse() in.  Defaults to\n`2, 2, MaxRow() - 2, MaxCol() - 2` with shadowed box, i.e. full screen.",
    "RETURNS": "nRecno is the number of the record selected by the <Enter> key.\n0 is returned if there are either no records matching the WHILE\ncondition or an <Esc> is pressed instead of an <Enter>",
    "DESCRIPTION": "This is a demonstration of TBrowse() with a WHILE condition for an\nindexed database.",
    "EXAMPLES": "// This example will only show those people with last name of \"JONES\"\n// in the test.dbf which contains at least the fields:\n// Last, First, City AND is indexed on Last + First.\nLOCAL nRecSel    := 0\nLOCAL aFields    := {}\nLOCAL bWhile     := {|| field->last = \"JONES\" }\nLOCAL cKey       := \"JONES\"\nLOCAL nFreeze    := 1\nLOCAL lSaveScrn  := .T.\nLOCAL cColorList := \"N/W, N/BG, B/W, B/BG, B/W, B/BG, R/W, B/R\"\nLOCAL cColorShad := \"N/N\"\n\nUSE test NEW  // indexed on Last + First\nINDEX ON field->last + field->first TO test\n\n// Pass Heading as character and Field as Block including Alias\n// To eliminate the need to use FieldWBlock() function in ft_BrwsWhl()\nAAdd( aFields, { \"Last Name\" , {|| field->last }  } )\nAAdd( aFields, { \"First Name\", {|| field->first } } )\nAAdd( aFields, { \"City\"      , {|| field->city }  } )\n\nIF ft_BrwsWhl( aFields, bWhile, cKey, nFreeze, lSaveScrn, ;\n   cColorList, cColorShad, 3, 6, MaxRow() - 2, MaxCol() - 6 ) == 0\n   ? \"Sorry, No records were selected\"\nELSE\n   ? \"You Selected:\", field->last, field->first, field->city\nENDIF"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/tempfile.txt",
    "NAME": "ft_TempFil()",
    "CATEGORY": "DOS/BIOS",
    "ONELINER": "Create a file with a unique name",
    "SYNTAX": "ft_TempFil( [ <cPath> ] [, <lHide> ] ) --> cFileSpec",
    "ARGUMENTS": "<cPath> is the directory where you want to create the temporary\nfile.  If you omit this argument, the root of the current drive\nis assumed.\n\nIf <lHide> is .T., then the file will be created with the hidden\nattribute set.  The default is .F.",
    "RETURNS": "<cFileSpec> should be your path, including the name of the newly\ncreated unique file.  You are safe to create a new file with\nthis filename.\n\nIf a DOS error occurred when trying to create the file, a\nnull string will be returned.\n",
    "DESCRIPTION": "This function uses DOS Interrupt 21, service 5Ah (Create temporary\nfile) to create a unique filename in a directory you specify.\nThere will be no extension.  After the file is created, you may\ndo any I/O you need (see the test driver in the source code).\n\nThis function requires ft_int86().",
    "EXAMPLES": "// Create a unique file in the root of the current drive:\n? ft_TempFil()\n\n// Create a unique file in the current directory and hide it:\n? ft_TempFil( \".\", .T. )\n\n// Create a unique file on another directory, but do not hide it:\n? ft_TempFil( \"mytempdir\" )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/vertmenu.txt",
    "NAME": "ft_Menu2()",
    "CATEGORY": "Menus/Prompts",
    "ONELINER": "Vertical lightbar menu",
    "SYNTAX": "ft_Menu2( <aMenuarray> [, <cColors> ] ) --> NIL",
    "ARGUMENTS": "<aMenuarray> is an array of menu options, messages, and action\n blocks.\n\nEach element in this array is a nested array with the structure:\n<table-noheader>\nelement[ x ][ 1 ] = menu option\nelement[ x ][ 2 ] = message to be displayed when option is highlighted\nelement[ x ][ 3 ] = code block to be executed when option is selected\n</table>\n<cColors> is a string containing colors for the prompts, in the same\nformat as that returned by `Set( _SET_COLOR )`.  If not supplied,\ncolors default to the current color setting.",
    "RETURNS": "NIL",
    "DESCRIPTION": "This function greatly simplifies the process of displaying light-bar\nmenus.  All prompts are padded out with spaces so they are the same\nlength, a box is drawn around the prompts, the box is automatically\ncentered on the screen, and the underlying screen is restored after\na menu selection has been made.\n\nAdditionally, because you can tie action blocks to each menu\noption, you can save on a lot of `DO CASE` or `IF..ELSEIF` code in your\nmain program.  See the test code for a succinct demonstration.",
    "EXAMPLES": "// FIXME\nLOCAL mainmenu := { ;\n   { \"Data Entry\",  \"Enter data\",    {|| ft_Menu2( datamenu )  } }, ;\n   { \"Reports\",     \"Hard copy\",     {|| ft_Menu2( repmenu )   } }, ;\n   { \"Maintenance\", \"Reindex files\", {|| ft_Menu2( maintmenu ) } }, ;\n   { \"Quit\", \"See ya later\" } }\nft_Menu2( mainmenu )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/vidcur.txt",
    "NAME": "ft_SetVCur()",
    "CATEGORY": "Video",
    "ONELINER": "Set the cursor position on a specified video page",
    "SYNTAX": "ft_SetVCur( [ <nPage> ], [ <nRow> ], [ <nCol> ] ) --> NIL",
    "ARGUMENTS": "<nPage> is the video page (defaults to current page, determined\n        by ft_GetVPg()\n\n<nRow>  is the row coordinate (defaults to 0 )\n\n<nCol>  is the column coordinate (defaults to 0 )",
    "RETURNS": "NIL",
    "DESCRIPTION": "ft_SetVCur() sets the cursor position on a specific video page.\nIt uses ft_int86() to invoke interrupt 10h, function 2.\n\nFor more information on graphics programming, cursors, and video\npages, refer to Richard Wilton's _Programmer's Guide to PC and\nPS/2 Video Systems_ (Microsoft Press).\n",
    "EXAMPLES": "// Set the position to row 5, column 10 on video page 1:\nft_SetVCur( 1, 5, 10 )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/vidcur.txt",
    "NAME": "ft_GetVCur()",
    "CATEGORY": "Video",
    "ONELINER": "Return info about the cursor on a specified video page",
    "SYNTAX": "ft_GetVCur( [<nPage>] ) --> aCurInfo",
    "ARGUMENTS": "<nPage> is the video page to get the cursor information for.\nDefaults to the current page, as returned by ft_GetVPg().",
    "RETURNS": "A four-element array (<aCurInfo>), set up as follows:\n\naCurInfo[ 1 ] = Top line of cursor\naCurInfo[ 2 ] = Bottom line of cursor\naCurInfo[ 3 ] = Character row\naCurInfo[ 4 ] = Character column\n",
    "DESCRIPTION": "ft_GetVCur() uses ft_int86() to invoke interrupt 10h, function\n3, to return the character cursor location for the specified\nvideo page.\n\nThe top line and bottom line of cursor are set depending on\nthe current cursor mode, and are only meaningful in alphanumeric\nvideo modes.\n\nFor more information on graphics programming, cursors, and\ncursor modes, refer to Richard Wilton's _Programmer's Guide to\nPC and PS/2 Video Systems_ (Microsoft Press).\n",
    "EXAMPLES": "LOCAL aCurInfo := ft_GetVCur( 1 )  // Get info on cursor pos in page 1\n? \"Row:\", aCurInfo[ 3 ]\n? \"Col:\", aCurInfo[ 4 ]\n? hb_ValToExp( aCurInfo )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/video1.txt",
    "NAME": "ft_VidStr()",
    "CATEGORY": "Video",
    "ONELINER": "Display string on screen in specified attribute",
    "SYNTAX": "ft_VidStr( <nRow>, <nCol>, <cString> [, <nColor> ] ) --> NIL",
    "ARGUMENTS": "<nRow> and <nCol> are the screen coordinates.\n\n<cString> is the string to be printed on the screen.\n\n<nColor> is an integer representing the color attribute.\nThe formula is:\n\n  nFore + ( nBack * 16 )\n\nft_VidStr() will display the string in the current color if\n<nColor> is not passed.",
    "RETURNS": "NIL",
    "DESCRIPTION": "This is a high speed function to display a string of any ASCII\ncharacters on screen in a specified color attribute.  This function\nis useful for constructing screens with a lot of text or repetitive\nscreen prints where speed is important.",
    "EXAMPLES": "ft_VidStr( 10, 20, \"Enter Name :\", 165 )\n\n// This example will print the specified text at coordinates 10, 20\n// in bright white on top of Magenta."
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/video1.txt",
    "NAME": "ft_WrtChr()",
    "CATEGORY": "Video",
    "ONELINER": "Display character on screen",
    "SYNTAX": "ft_WrtChr( <nRow>, <nCol>, <cChar>, <nColor> ) --> NIL",
    "ARGUMENTS": "<nRow> and <nCol> are the screen coordinates.\n\n<cChar> is the single character to print on the screen.\n\n<nColor> is an integer representing the color attribute.\nThe formula is:\n\n   nFore + ( nBack * 16 )",
    "RETURNS": "NIL",
    "DESCRIPTION": "This is a high speed function to display a single ASCII character\non screen in a specified color attribute.  This function is useful\nfor constructing screens with a lot of text or repetitive screen prints\nwhere speed is important.  It is faster and requires less memory than\nft_VidStr().",
    "EXAMPLES": "LOCAL nX, nY\n\nFOR nX := 1 TO MaxRow()\n   FOR nY := 1 TO MaxCol()\n      ft_WrtChr( nX, nY, \"\", ( nX - 1 ) + ( nY * 16 ) )\n   NEXT\nNEXT\n\n// This example will write the ASCII character 249 to every location\n// `ON SCREEN` in every possible COLOR combination.  It will recognize\n// the status of SetBlink().  It uses direct video writes FOR speed."
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/video1.txt",
    "NAME": "ft_CLS()",
    "CATEGORY": "Video",
    "ONELINER": "Clear screen",
    "SYNTAX": "ft_CLS( <nTRow>, <nLCol>, <nBRow>, <nRCol>, <nColor> ) --> NIL",
    "ARGUMENTS": "<nTRow>, <nLCol>, <nBRow> and  <nRCol> are the screen coordinates\nto clear.\n\n<nColor> is an integer representing the color attribute.\nThe formula is:\n\n  nFore + ( nBack * 16 )\n\nThe default is black.",
    "RETURNS": "NIL",
    "DESCRIPTION": "This is a high speed function to clear the screen at the given\ncoordinates with the given color attribute.  This does not change\nClipper's color settings.  It uses direct video writes for speed.\n",
    "EXAMPLES": "ft_CLS( 0, 0, MaxRow(), MaxCol(), 165 )\n\n// This example will clear the entire screen with the colors\n// bright white on magenta."
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/video1.txt",
    "NAME": "ft_SetAttr()",
    "CATEGORY": "Video",
    "ONELINER": "Change color attributes of screen region",
    "SYNTAX": "ft_SetAttr( <nTRow>, <nLCol>, <nBRow>, <nRCol>, <nColor> ) --> NIL",
    "ARGUMENTS": "<nTRow>, <nLCol>, <nBRow>, and <nRCol> are the coordinates of the\nscreen region.\n\n<nColor> is an integer representing the new color attribute.\nThe formula is:\n\n    nFore + ( nBack * 16 )",
    "RETURNS": "NIL",
    "DESCRIPTION": "This is a high speed function to change the colors of a specified\nregion of the screen without disturbing any text.  Uses direct\nvideo writes.",
    "EXAMPLES": "ft_SetAttr( 0, 0, MaxRow(), MaxCol(), 95 )\n\n// This example will change the entire screen's colors to bright white on\n// magenta without changing or overwriting any text on the screen."
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/video1.txt",
    "NAME": "ft_RevAttr()",
    "CATEGORY": "Video",
    "ONELINER": "Reverse colors of specified screen coordinates",
    "SYNTAX": "ft_RevAttr( <nTRow>, <nLCol>, <nBRow>, <nRCol> ) --> NIL",
    "ARGUMENTS": "<nTRow>, <nLCol>, <nBRow>, and <nRCol> are the coordinates of the\nscreen region.",
    "RETURNS": "NIL",
    "DESCRIPTION": "This is a high speed function to reverse the color of a specified\nscreen region without disturbing any text on the screen.  This\nfunction will correctly reverse the color attributes in a region\ncontaining multiple color combinations.",
    "EXAMPLES": "ft_RevAttr( 0, 0, MaxRow(), MaxCol() )\n\n// This example will change the entire screen's colors to their reverse\n// attributes without changing  or overwriting any text."
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/video1.txt",
    "NAME": "ft_RevChr()",
    "CATEGORY": "Video",
    "ONELINER": "Reverse the color of a single character on the screen",
    "SYNTAX": "ft_RevChr( <nTRow>, <nLCol> ) --> NIL",
    "ARGUMENTS": "<nTRow>, <nLCol> are the screen coordinates of the character.",
    "RETURNS": "NIL",
    "DESCRIPTION": "This is a high speed function to reverse the color of a single\ncharacter on the screen without changing the character itself.\nThis function is the same as ft_RevAttr() except that it changes\nonly one character on screen and hence is faster and uses less memory.",
    "EXAMPLES": "ft_RevChr( 10, 20 )\n\n// This example will change the text and background at 10, 20 to it's\n// reverse color attributes without changing or overwriting the\n// character itself."
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/vidmode.txt",
    "NAME": "ft_SetMode()",
    "CATEGORY": "Video",
    "ONELINER": "Set the video mode",
    "SYNTAX": "ft_SetMode( <nMode> ) --> NIL",
    "ARGUMENTS": "<nMode> is one of the DOS video modes.",
    "RETURNS": "NIL",
    "DESCRIPTION": "Use this function to put your display adapter into a video mode.\nUses DOS interrupt 10h to set the mode.  For a table of modes\navailable on various graphics adapters, refer to a book such\nas Wilton's \"Programmer's Guide to PC & PS/2 Video Systems\"\n(Microsoft Press)",
    "EXAMPLES": "ft_SetMode( 1 )\n? \"Video mode is:\", ft_GetMode()",
    "SEEALSO": "ft_Adapter()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/vidmode.txt",
    "NAME": "ft_GetMode()",
    "CATEGORY": "Video",
    "ONELINER": "Get the video mode",
    "SYNTAX": "ft_GetMode() --> nVMode",
    "ARGUMENTS": "None.",
    "RETURNS": "The video mode, as a numeric.",
    "DESCRIPTION": "Use this function to find out what mode your display adapter is in.\nUses DOS interrupt 10h to get the mode.  For a table of modes\navailable on various graphics adapters, refer to a book such\nas Wilton's \"Programmer's Guide to PC & PS/2 Video Systems\"\n(Microsoft Press)",
    "EXAMPLES": "ft_SetMode( 1 )\n? \"Video mode is:\", ft_GetMode()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/wda.txt",
    "NAME": "ft_AddWkDy()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Return true number of days to add given number of workdays",
    "SYNTAX": "ft_AddWkDy( <dStart>, <nWorkDays> ) --> nTrueDays",
    "ARGUMENTS": "<dStart> = date to start adding from\n<nWorkDays> = number of workdays to add",
    "RETURNS": "<nTrueDays> = Number of actual days to add to <dStart> in\n              order to add the required <nWorkDays>",
    "DESCRIPTION": "Let's say you are given the problem:\n\n   \"All invoices are due 10 working days from the date they\n   are printed.  Please display the due date on the invoice.\"\n\nWhen is the due date?  Assuming you are printing the invoices\ntoday, your answer is:\n```\ndDueDate := Date() + ft_addWkDay( Date(), 10 )\n```\nA work day is defined as Monday through Friday.  Unfortunately\nthis routine does _not_ account for holidays.\n\nThis documentation was written by Glenn Scott so if it's wrong,\nblame him.\n",
    "EXAMPLES": "LOCAL dPost := 0d19910101\n// Postdate 5 working days from the first of January\ndPost += ft_AddWkDy( dPost, 5 )  // returns 7 true days\n? dPost                          // --> 1991-01-08",
    "SEEALSO": "ft_Workdays()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/week.txt",
    "NAME": "ft_Week()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Return calendar or fiscal week data",
    "SYNTAX": "ft_Week( [ <dGivenDate> ], [ <nWeekNum> ] ) --> aDateinfo",
    "ARGUMENTS": "<dGivenDate> is any valid date in any date format.  Defaults\nto current system date if not supplied.\n\n<nWeekNum> is a number from 1 to 53 signifying a week.\nDefaults to current week if not supplied.",
    "RETURNS": "A three element array containing the following data:\n\n   aDateInfo[ 1 ] - The year and week as a character string \"YYYYWW\"\n   aDateInfo[ 2 ] - The beginning date of the week\n   aDateInfo[ 3 ] - The ending date of the week",
    "DESCRIPTION": "ft_Week() returns an array containing data about the week\ncontaining the given date.\n\nNormally the return data will be based on a year beginning\non January 1st with weeks beginning on Sunday.\n\nThe beginning of year date and/or beginning of week day can be\nchanged by using ft_DateCnfg(), which will affect all subsequent\ncalls to ft_Week() until another call to ft_DateCnfg().\n\nThe beginning of year date and beginning of week day may be reset\nto January 1 and Sunday by calling ft_DateCnfg() with no\nparameters.",
    "EXAMPLES": "LOCAL aDateInfo\n\n// get info about week containing 1990-09-15\naDateInfo := ft_Week( 0d19900915 )\n? aDateInfo[ 1 ]  // --> 199037      (37th week)\n? aDateInfo[ 2 ]  // --> 1990-09-09  beginning of week 37\n? aDateInfo[ 3 ]  // --> 1990-09-15  end of week 37\n\n// get info about week 25 in year containing 1990-09-15\naDateInfo := ft_Week( 0d19900915, 25 )\n? aDateInfo[ 1 ]  // --> 199025\n? aDateInfo[ 2 ]  // --> 1990-06-17  beginning of week 25\n? aDateInfo[ 3 ]  // --> 1990-06-23  end of week 25\n\n// get info about week 25 in current Year( 1991 )\naDateInfo := ft_Week( , 25 )\n? aDateInfo[ 1 ]  // --> 199025\n? aDateInfo[ 2 ]  // --> 1991-06-16  beginning of week 25\n? aDateInfo[ 3 ]  // --> 1991-06-22  end of week 25",
    "SEEALSO": "ft_DateCnfg(), ft_Month(), ft_Qtr(), ft_Year(), ft_DayToBoW()"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/workdays.txt",
    "NAME": "ft_Workdays()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Return number of work days between two dates",
    "SYNTAX": "ft_Workdays( [ <dStart> ], [ <dStop> ] ) --> nDays",
    "ARGUMENTS": "<dStart> is the beginning value for the date range.\n\n<dStop> is the ending value for the date range.",
    "RETURNS": "The number of work days (Monday through Friday) between two dates.",
    "DESCRIPTION": "ft_Workdays() returns a number indicating the number of work days\nbetween two dates.  Work days are considered Monday through Friday.\n(The five day work week none of us Clipper programmers have.)",
    "EXAMPLES": "? ft_Workdays( 0d19910516, 0d19910520 )  // --> 3  (Th - Mo)\n? ft_Workdays( 0d19910518, 0d19910519 )  // --> 0  (Sa - Su)\n? ft_Workdays( 0d19910517, 0d19910517 )  // --> 1  (Fr - Fr)",
    "SEEALSO": ""
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/woy.txt",
    "NAME": "ft_WoY()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Find number of week within year",
    "SYNTAX": "ft_WoY( <dDate> ) --> nResult",
    "ARGUMENTS": "<dDate> is a date in the form `\"mm/dd/yy\"` or `\"mm/dd/yyyy\"`",
    "RETURNS": "Return numeric position of week within the year or NIL if\nparameter does not conform.",
    "DESCRIPTION": "Considers a full week as starting on Sunday, ending on Saturday.\nFirst week of year (week 1) may start on any day, and thus\n  contain any number of days.\nFinal week of year (week 53) may contain any number of days.\nHandles dates with `CENTURY ON`|`OFF`, to allow for 21st century.\nDate validation must be external to this function.",
    "EXAMPLES": "LOCAL dDate, GetList := {}\n\n// These code fragments find the week number, given a date.\n\n// literal character date\n? ft_WoY( 0d19910101 )  // --> 1\n\n// presume OS date to be 1991-01-06\n? ft_WoY( Date() )      // --> 2\n\n// date input\ndDate := 0d0\n@ 4, 10 GET cDate       // input 1991-07-04\nREAD\n? ft_WoY( dDate )       // --> 27\n\n// last day of year\n? ft_WoY( 0d19911231 )  // --> 53"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/woy.txt",
    "NAME": "ft_DoY()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Find number of day within year",
    "SYNTAX": "ft_DoY( <dDate> ) --> nResult",
    "ARGUMENTS": "<dDate> is a date in the form `\"mm/dd/yy\"` or `\"mm/dd/yyyy\"`",
    "RETURNS": "Return numeric position of day within the year.\nReturn NIL if parameter does not conform.",
    "DESCRIPTION": "Finds the day number, considering 01/01 as day 1\nHandles dates with `CENTURY ON`|`OFF`, to allow for 21st century.\nDate validation must be external to this function.",
    "EXAMPLES": "LOCAL dDate, GetList := {}\n\n// These code fragments find the day number, given a date.\n\n// literal character date\n? ft_DoY( 0d19910101 )  // --> 1\n\n// presume OS date to be 1991-01-06\n? ft_DoY( Date() )      // --> 6\n\n// date input\ndDate := 0d0\n@ 4, 10 GET cDate       // input 1991-07-04\nREAD\n? ft_DoY( dDate )       // --> 185\n\n// last day of year\n? ft_DoY( 0d19911231 )  // --> 365"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/xbox.txt",
    "NAME": "ft_XBox()",
    "CATEGORY": "Menus/Prompts",
    "ONELINER": "Display a self-sizing message box and message",
    "SYNTAX": "ft_XBox( [ <cJustType> ], [ <cRetWait> ], [ <cBorType> ],   ;\n         [ <cBorColor> ], [ <cBoxColor> ], [ <nStartRow> ], ;\n         [ <nStartCol> ], <cLine1>,  <cLine2>, <cLine3>,    ;\n         <cLine4>, <cLine5>, <cLine6>, <cLine7>, <cLine8> ) --> NIL",
    "ARGUMENTS": "<cJustType> is a character indicating the type of text justification.\n<L> cause the text to be left-justified in the box.\nCentered text is the default.\n\n<cRetWait> is a character which determines if the function will wait\nfor a key-press after displaying the box.  <W> will cause the\nfunction to wait for a key-press before returning control to the\ncalling routine.  Not waiting is the default\n\n<cBorType> is a character which determines whether a single or double\nborder will be displayed.  <D> will cause a double border to\nbe displayed.  A single border is the default.\n\n<cBorColor> is a character string denoting the border color.  `N/W` is\nthe default if this parameter is not a string.\n\n<cBoxColor> is a character string denoting the text color.  `W/N` is\nthe default if this parameter is not a string.\n\n<nStartRow> is a number denoting the starting row.  If `99` is passed,\nthe box is centered vertically.  If necessary, <nStartRow> is decreased\nso the entire box can be displayed.\n\n<nStartCol> is a number denoting the starting column.  If `99` is passed,\nthe box is centered horizontally.  If necessary, <nStartCol> is decreased\nso the entire box can be displayed.\n\n<cLine1> thru <cLine8> are 1 to 8 character strings to be displayed.\nThey are truncated to fit on the screen if necessary.",
    "RETURNS": "NIL",
    "DESCRIPTION": "ft_XBox() allows the programmer to display a message box on the screen\nwithout needing to calculate the dimensions of the box.  Only the upper\nleft corner needs to be defined.  The function will calculate the lower\nright corner based on the number and length of strings passed.\n\nA maximum of eight strings can be displayed.  If a string is too long\nto fit on the screen it is truncated.\n\nThe first seven parameters are optional.  The default settings are:\n   Lines of text are centered.\n   Control is returned to the calling routine immediately.\n   A single line border is painted.\n   The border is black on white.\n   The text is white on black.\n   The box is centered both vertically and horizontally.",
    "EXAMPLES": "// The following displays a two-line box with default settings:\n\nft_XBox( ,,,,,,, \"This is a test\", \"of the ft_XBox() function\" )\n\n// The following uses all optional parameters and displays a three-line\n// box.  The box is left-justified with a double border.  It has a yellow\n// on red border and white on blue text.  The function will wait for a\n// key-press before returning control to the calling routine.\n\nft_XBox( \"L\", \"W\", \"D\", \"GR+/R\", \"W/B\", 5, 10, ;\n   \"It is so nice\", ;\n   \"to not have to do the messy chore\", ;\n   \"of calculating the box size!\" )"
  },
  {
    "_COMPONENT": "hbnf",
    "_LANG": "en",
    "_DOCSOURCE": "./hbnf/doc/en/year.txt",
    "NAME": "ft_Year()",
    "CATEGORY": "Date/Time",
    "ONELINER": "Return calendar or fiscal year data",
    "SYNTAX": "ft_Year( [ <dGivenDate> ] ) --> aDateInfo",
    "ARGUMENTS": "<dGivenDate> is any valid date in any date format.  Defaults\nto current system date if not supplied.",
    "RETURNS": "A three element array containing the following data:\n```\naDateInfo[ 1 ] - The year as a character string \"YYYY\"\naDateInfo[ 2 ] - The beginning date of the year\naDateInfo[ 3 ] - The ending date of the year\n```",
    "DESCRIPTION": "ft_Year() returns an array containing data about the year\ncontaining the given date.\n\nNormally the return data will be based on a year beginning\non January 1st.\n\nThe beginning of year date can be changed by using ft_DateCnfg(),\nwhich will affect all subsequent calls to ft_Year() until another\ncall to ft_DateCnfg().\n\nThe beginning of year date may be reset to January 1 by calling\nft_DateCnfg() with no parameters.",
    "EXAMPLES": "LOCAL aDateInfo\n\n// Get info about year containing 1990-09-15, assuming default\n// beginning of year is January 1st.\naDateInfo := ft_Year( 0d19900915 )\n? aDateInfo[ 1 ]  // --> 1990\n? aDateInfo[ 2 ]  // --> 1990-01-01  beginning of year\n? aDateInfo[ 3 ]  // --> 1990-12-31  end of year\n\n// get info about current year (1991).\naDateInfo := ft_Year()\n? aDateInfo[ 1 ]  // --> 1991\n? aDateInfo[ 2 ]  // --> 1991-01-01  beginning of year\n? aDateInfo[ 3 ]  // --> 1991-12-31  end of year",
    "SEEALSO": "ft_DateCnfg(), ft_Week(), ft_Month(), ft_Qtr()"
  }
]
