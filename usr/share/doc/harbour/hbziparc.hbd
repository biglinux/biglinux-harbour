[
  {
    "_COMPONENT": "hbziparc",
    "_LANG": "en",
    "_DOCSOURCE": "./hbziparc/doc/en/ziparc.txt",
    "NAME": "hb_SetZipComment()",
    "CATEGORY": "Zip Functions",
    "ONELINER": "Set an Zip archive Comment",
    "SYNTAX": "hb_SetZipComment( <cComment> ) --> NIL",
    "ARGUMENTS": "<cComment>   Comment to add to the zip archive",
    "RETURNS": "<NIL> this function always return NIL",
    "DESCRIPTION": "This function stored an global comment to an zip archive.\nIt should be called before any of the compression functions.",
    "EXAMPLES": "? hb_SetZipComment( \"This is an Test\" )\n? hb_ZipFile( \"test.zip\", { \"test.xml\", \"test.ini\" } )",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is hbziparc"
  },
  {
    "_COMPONENT": "hbziparc",
    "_LANG": "en",
    "_DOCSOURCE": "./hbziparc/doc/en/ziparc.txt",
    "NAME": "hb_GetZipComment()",
    "CATEGORY": "Zip Functions",
    "ONELINER": "Return the comment of an zip file",
    "SYNTAX": "hb_GetZipComment( <szFile> ) --> <szComment>",
    "ARGUMENTS": "<szFile>  File to get the comment from",
    "RETURNS": "<szComment>  The comment that was stored in <szFile>",
    "DESCRIPTION": "This function receives a valid zip file name as parameter,\nand returns the global comment stored within.",
    "EXAMPLES": "? \"The comment in test.zip is:\", hb_GetZipComment( \"test.zip\" )",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is hbziparc"
  },
  {
    "_COMPONENT": "hbziparc",
    "_LANG": "en",
    "_DOCSOURCE": "./hbziparc/doc/en/ziparc.txt",
    "NAME": "hb_ZipTestPK()",
    "CATEGORY": "Zip Functions",
    "ONELINER": "Test pkSpanned zip files",
    "SYNTAX": "hb_ZipTestPK( <cFile> ) --> nReturnCode",
    "ARGUMENTS": "<cFile>  File to be tested.",
    "RETURNS": "<nReturn> A code that tells if the current disk is the last of a\npkSpanned disk set.",
    "DESCRIPTION": "This function tests if the disk inserted is the last disk of an backup\nset or not.\nIt will return the follow return code when an error is found\n\n<table>\nError code     Meaning\n114            Incorrect Disk\n103            No Call back was set with hb_ZipTestPK()\n</table>\n\nCall this function to determine if the disk inserted is the correct\none before any other function.",
    "EXAMPLES": "IF hb_ZipTestPK( \"test22.zip\" ) == 114\n   ? \"Invalid Diskette\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is hbziparc"
  },
  {
    "_COMPONENT": "hbziparc",
    "_LANG": "en",
    "_DOCSOURCE": "./hbziparc/doc/en/ziparc.txt",
    "NAME": "hb_SetDiskZip()",
    "CATEGORY": "Zip Functions",
    "ONELINER": "Set a codeblock for disk changes",
    "SYNTAX": "hb_SetDiskZip( <bBlock> ) --> .T.",
    "ARGUMENTS": "<bBlock> a codeblock that contains an function that will be performed\nwhen the need of changing disk are need.",
    "RETURNS": "It always returns True",
    "DESCRIPTION": "This function will set a codeblock that will be evaluated every time\nthat an change-disk event is necessary. <bBlock> receives <nDisk> as a\ncodeblock param that corresponds to the diskette number to be processed.\n\nSet this function before opening archives that are in removable media.\nThis block will be released, when the caller finish it job.",
    "EXAMPLES": "hb_SetDiskZip( {| nDisk | Alert( \"Please insert disk no \" + hb_ntos( nDisk ) ) } )",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is hbziparc"
  },
  {
    "_COMPONENT": "hbziparc",
    "_LANG": "en",
    "_DOCSOURCE": "./hbziparc/doc/en/ziparc.txt",
    "NAME": "hb_SetBuffer()",
    "CATEGORY": "Zip Functions",
    "ONELINER": "",
    "SYNTAX": "hb_SetBuffer( [<nWriteBuffer>], [<nExtractBuffer>], [<nReadBuffer>] ) --> NIL",
    "ARGUMENTS": "<nWriteBuffer>   The size of the write buffer.\n\n<nExtractBuffer> The size of the extract buffer.\n\n<nReadBuffer>    The size of the read buffer.",
    "RETURNS": "<NIL>            This function always returns NIL.",
    "DESCRIPTION": "This function set the size of the internal buffers for write/extract/read\noperation.\n\nIf the size of the buffer is smaller then the default, the function\nwill automatically use the default values, which are 65535/16384/32768\nrespectively.\n\nThis function be called before any of the compression/decompression\nfunctions.",
    "EXAMPLES": "hb_SetBuffer( 100000, 115214, 65242 )",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is hbziparc"
  },
  {
    "_COMPONENT": "hbziparc",
    "_LANG": "en",
    "_DOCSOURCE": "./hbziparc/doc/en/ziparc.txt",
    "NAME": "hb_ZipFileByTDSpan()",
    "CATEGORY": "Zip Functions",
    "ONELINER": "Create a zip file",
    "SYNTAX": "hb_ZipFileByTDSpan( <cFile>, <cFileToCompress> | <aFiles>, <nLevel>,\n<bBlock>, <lOverWrite>, <cPassword>, <iSize>, <lWithPath>, <lWithDrive>,\n<pFileProgress>) --> lCompress",
    "ARGUMENTS": "<cFile>   Name of the zip file\n\n<cFileToCompress>  Name of a file to Compress, Drive and/or path\ncan be used\n    _or_\n<aFiles>  An array containing files to compress, Drive and/or path\ncan be used\n\n<nLevel>  Compression level ranging from 0 to 9\n\n<bBlock>  Codeblock to execute while compressing\n\n<lOverWrite>  Toggle to overwrite the file if exists\n\n<cPassword> Password to encrypt the files\n\n<iSize> Size of the archive, in bytes. Default is 1457664 bytes\n\n<lWithPath> Toggle to store the path or not\n\n<lWithDrive> Toggle to store the Drive letter and path or not\n\n<pFileProgress> Codeblock for File Progress",
    "RETURNS": "<lCompress>  .T. if file was create, otherwise .F.",
    "DESCRIPTION": "This function creates a zip file named <cFile>. If the extension\nis omitted, .zip will be assumed. If the second parameter is a\ncharacter string, this file will be added to the zip file. If the\nsecond parameter is an array, all file names contained in <aFiles>\nwill be compressed.\n\nIf <nLevel> is used, it determines the compression type where 0 means\nno compression and 9 means best compression.\n\nIf <bBlock> is used, every time the file is opened to compress it\nwill evaluate <bBlock>. Parameters of <bBlock> are <cFile> and <nPos>.\n\nIf <lOverWrite> is used, it toggles to overwrite or not the existing\nfile. Default is to overwrite the file, otherwise if <lOverWrite> is\nfalse the new files are added to the <cFile>.\n\nIf <lWithPath> is used, it tells that the path should also be stored\nwith the file name. Default is false.\n\nIf <lWithDrive> is used, it tells that the Drive and path should also\nbe stored with the file name. Default is false.\n\nIf <pFileProgress> is used, a codeblock is evaluated, `showing` the total\nof that file has being processed.\nThe codeblock must be defined as: `{| nPos, nTotal | GaugeUpdate( aGauge1, nPos / nTotal ) }`",
    "EXAMPLES": "LOCAL aFiles, nLen, aGauge\n\nIF hb_ZipFileByTDSpan( \"test.zip\", \"test.prg\" )\n   ? \"File was successfully created\"\nENDIF\n\nIF hb_ZipFileByTDSpan( \"test1.zip\", { \"test.prg\", \"test.hbp\" } )\n   ? \"File was successfully created\"\nENDIF\n\nIF hb_ZipFileByTDSpan( \"test2.zip\", { \"test.prg\", \"test.hbp\" }, 9, {| cFile, nPos | QOut( cFile ) }, \"hello\",, 521421 )\n   ? \"File was successfully created\"\nENDIF\n\naFiles := { \"test.prg\", \"test.hbp\" }\nhb_ZipFileByTDSpan( \"test33.zip\", aFiles, 9,,, \"hello\",, 6585452 )",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is hbziparc"
  },
  {
    "_COMPONENT": "hbziparc",
    "_LANG": "en",
    "_DOCSOURCE": "./hbziparc/doc/en/ziparc.txt",
    "NAME": "hb_ZipFileByPKSpan()",
    "CATEGORY": "Zip Functions",
    "ONELINER": "Create a zip file on removable media",
    "SYNTAX": "hb_ZipFileByPKSpan( <cFile>, <cFileToCompress> | <aFiles>, <nLevel>,\n<bBlock>, <lOverWrite>, <cPassword>, <lWithPath>, <lWithDrive>,\n<pFileProgress> ) --> lCompress",
    "ARGUMENTS": "<cFile>   Name of the zip file\n\n<cFileToCompress>  Name of a file to Compress, Drive and/or path\ncan be used\n    _or_\n<aFiles>  An array containing files to compress, Drive and/or path\ncan be used\n\n<nLevel>  Compression level ranging from 0 to 9\n\n<bBlock>  Codeblock to execute while compressing\n\n<lOverWrite>  Toggle to overwrite the file if exists\n\n<cPassword> Password to encrypt the files\n\n<lWithPath> Toggle to store the path or not\n\n<lWithDrive> Toggle to store the Drive letter and path or not\n\n<pFileProgress> Codeblock for File Progress",
    "RETURNS": "<lCompress>  .T. if file was create, otherwise .F.",
    "DESCRIPTION": "This function creates a zip file named <cFile>. If the extension\nis omitted, .zip will be assumed. If the second parameter is a\ncharacter string, this file will be added to the zip file. If the\nsecond parameter is an array, all file names contained in <aFiles>\nwill be compressed.  Also, the use of this function is for creating\nbackup in removable media like an floppy drive/zip drive.\n\nIf <nLevel> is used, it determines the compression type where 0 means\nno compression and 9 means best compression.\n\nIf <bBlock> is used, every time the file is opened to compress it\nwill evaluate <bBlock>. Parameters of <bBlock> are <cFile> and <nPos>.\n\nIf <lOverWrite> is used, it toggles to overwrite or not the existing\nfile. Default is to overwrite the file, otherwise if <lOverWrite> is false\nthe new files are added to the <cFile>.\n\nIf <cPassword> is used, all files that are added to the archive are encrypted\nwith the password.\n\nIf <lWithPath> is used, it tells that the path should also be stored with\nthe file name. Default is false.\n\nIf <lWithDrive> is used, it tells that the Drive and path should also be stored\nwith the file name. Default is false.\n\nIf <pFileProgress> is used, a codeblock is evaluated, showing the total\nof that file has being processed.\nThe codeblock must be defined as: `{| nPos, nTotal | GaugeUpdate( aGauge1, nPos / nTotal ) }`\n\nBefore calling this function, set a change-disk codeblock by calling\nthe hb_SetDiskZip().",
    "EXAMPLES": "LOCAL aFiles, nLen, aGauge\n\nhb_SetDiskZip( {| nDisk | Alert( \"Please insert disk no \" + hb_ntos( nDisk ) ) } )\n\nIF hb_ZipFileByPKSpan( \"test.zip\", \"test.prg\" )\n   ? \"File was successfully created\"\nENDIF\n\nIF hb_ZipFileByPKSpan( \"test1.zip\", { \"test.prg\", \"test.hbp\" } )\n   ? \"File was successfully created\"\nENDIF\n\nIF hb_ZipFileByPKSpan( \"test2.zip\", { \"test.prg\", \"test.hbp\" }, 9, {| cFile, nPos | QOut( cFile ) } )\n   ? \"File was successfully created\"\nENDIF\n\naFiles := { \"test.prg\", \"test.hbp\" }\nnLen   := Len( aFiles )\nhb_ZipFileByPKSpan( \"test33.zip\", aFiles, 9,,, \"hello\" )",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is hbziparc"
  },
  {
    "_COMPONENT": "hbziparc",
    "_LANG": "en",
    "_DOCSOURCE": "./hbziparc/doc/en/ziparc.txt",
    "NAME": "hb_ZipFile()",
    "CATEGORY": "Zip Functions",
    "ONELINER": "Create a zip file",
    "SYNTAX": "hb_ZipFile( <cFile>, <cFileToCompress> | <aFiles>, <nLevel>,\n<bBlock>, <lOverWrite>, <cPassword>, <lWithPath>, <lWithDrive>,\n<pFileProgress> ) --> lCompress",
    "ARGUMENTS": "<cFile>   Name of the zip file to create\n\n<cFileToCompress>  Name of a file to Compress, Drive and/or path\ncan be used\n   _or_\n<aFiles>  An array containing files to compress, Drive and/or path\ncan be used\n\n<nLevel>  Compression level ranging from 0 to 9\n\n<bBlock>  Codeblock to execute while compressing\n\n<lOverWrite>  Toggle to overwrite the file if exists\n\n<cPassword> Password to encrypt the files\n\n<lWithPath> Toggle to store the path or not\n\n<lWithDrive> Toggle to store the Drive letter and path or not\n\n<pFileProgress> Codeblock for File Progress",
    "RETURNS": "<lCompress>  .T. if file was create, otherwise .F.",
    "DESCRIPTION": "This function creates a zip file named <cFile>. If the extension\nis omitted, .zip will be assumed. If the second parameter is a\ncharacter string, this file will be added to the zip file. If the\nsecond parameter is an array, all file names contained in <aFiles>\nwill be compressed.\n\nIf <nLevel> is used, it determines the compression type where 0 means\nno compression and 9 means best compression.\n\nIf <bBlock> is used, every time the file is opened to compress it\nwill evaluate <bBlock>. Parameters of <bBlock> are <cFile> and <nPos>.\n\nIf <lOverWrite> is used, it toggles to overwrite or not the existing\nfile. Default is to overwrite the file, otherwise if <lOverWrite> is false\nthe new files are added to the <cFile>.\n\nIf <cPassword> is used, all files that are added to the archive are encrypted\nwith the password.\n\nIf <lWithPath> is used, it tells  the path should also be stored with\nthe file name. Default is false.\n\nIf <lWithDrive> is used, it tells that the Drive and path should also be stored\nwith the file name. Default is false.\n\nIf <pFileProgress> is used, a codeblock is evaluated, showing the total\nof that file has being processed.\nThe codeblock must be defined as: `{| nPos, nTotal | GaugeUpdate( aGauge1, nPos / nTotal ) }`",
    "EXAMPLES": "LOCAL aFiles, nLen, aGauge\n\nIF hb_ZipFile( \"test.zip\", \"test.prg\" )\n   ? \"File was successfully created\"\nENDIF\n\nIF hb_ZipFile( \"test1.zip\", { \"test.prg\", \"test.hbp\" } )\n   ? \"File was successfully created\"\nENDIF\n\nIF hb_ZipFile( \"test2.zip\", { \"test.prg\", \"test.hbp\" }, 9, {| cFile, nPos | QOut( cFile ) } )\n   ? \"File was successfully created\"\nENDIF\n\naFiles := { \"test.prg\", \"test.hbp\" }\nnLen   := Len( aFiles )\nhb_ZipFile( \"test33.zip\", aFiles, 9,,, \"hello\" )",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is hbziparc"
  },
  {
    "_COMPONENT": "hbziparc",
    "_LANG": "en",
    "_DOCSOURCE": "./hbziparc/doc/en/ziparc.txt",
    "NAME": "hb_UnzipFile()",
    "CATEGORY": "Zip Functions",
    "ONELINER": "Unzip a compressed file",
    "SYNTAX": "hb_UnzipFile( <cFile>, <bBlock>, <lWithPath>, <cPassword>, <cPath>,\n              <cFile> | <aFile>, <pFileProgress> ) --> lCompress",
    "ARGUMENTS": "<cFile>   Name of the zip file to extract\n\n<bBlock>  Codeblock to execute while extracting\n\n<lWithPath> Toggle to create directory if needed\n\n<cPassword> Password to use to extract files\n\n<cPath>    Path to extract the files to - mandatory\n\n<cFile> | <aFiles> A File or Array of files to extract - mandatory\n\n<pFileProgress> Codeblock for File Progress",
    "RETURNS": "<lCompress>  .T. if all file was successfully restored, otherwise .F.",
    "DESCRIPTION": "This function restores all files contained inside the <cFile>.\nIf the extension is omitted, .zip will be assumed. If a file already\nexists, it will be overwritten.\n\nIf <bBlock> is used, every time the file is opened to compress it\nwill evaluate <bBlock>. Parameters of <bBlock> are <cFile> and <nPos>.\n\nThe <cPath> is a mandatory parameter. Set to `./` to extract to the\ncurrent directory.\n\nIf <cFile> or <aFiles> are not provided, no files will be extracted!\nMake sure you provide the file or files you want extracted.\n\nIf <pFileProgress> is used, a codeblock is evaluated, showing the total\nof that file has being processed.\nThe codeblock must be defined as: `{| nPos, nTotal | GaugeUpdate( aGauge1, nPos / nTotal ) }`",
    "EXAMPLES": "LOCAL aExtract := hb_GetFilesInZip( \"test.zip\" )  // extract all files in zip\n\nIF hb_UnzipFile( \"test.zip\",,,, hb_DirSepToOS( \"./\" ), aExtract )\n   ? \"File was successfully extracted\"\nENDIF\n\naExtract := hb_GetFilesInZip( \"test2.zip\" )  // extract all files in zip\nIF hb_UnzipFile( \"test2.zip\", {| cFile | QOut( cFile ) },,, hb_DirSepToOS( \"./\" ), aExtract )\n   ? \"File was successfully extracted\"\nENDIF",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is hbziparc"
  },
  {
    "_COMPONENT": "hbziparc",
    "_LANG": "en",
    "_DOCSOURCE": "./hbziparc/doc/en/ziparc.txt",
    "NAME": "hb_ZipDeleteFiles()",
    "CATEGORY": "Zip Functions",
    "ONELINER": "Delete files from an zip archive",
    "SYNTAX": "hb_ZipDeleteFiles( <cFile>, <cFiletoDelete> | <aFiles> | <nFilePos> ) --> lDeleted",
    "ARGUMENTS": "<cFile>  The name of the zip files from where the files will be deleted\n\n<cFiletoDelete> An File to be removed\n   _or_\n<aFiles>    An Array of Files to be removed\n   _or_\n<nFilePos> The Position of the file to be removed",
    "RETURNS": "<lDeleted> If the files are deleted, it will return .T.; otherwise\nit will return .F. in the following cases: Spanned Archives; the file(s)\ncould not be found in the zip file.",
    "DESCRIPTION": "This  function removes files from an Zip archive.",
    "EXAMPLES": "? \"has the file zipnew.i been deleted:\", iif( hb_ZipDeleteFiles( \"test23.zip\", \"zipnew.i\" ), \"Yes\", \"No\" )",
    "STATUS": "R",
    "COMPLIANCE": "H",
    "PLATFORMS": "All",
    "FILES": "Library is hbziparc"
  }
]
